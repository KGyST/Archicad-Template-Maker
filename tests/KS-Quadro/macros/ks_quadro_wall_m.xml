<?xml version="1.0" encoding="UTF-8"?>
<Symbol IsArchivable="no" IsPlaceable="no" MainGUID="1BE0F1F7-CA08-4377-A53A-9C1C45CDB9A7" MigrationValue="Normal" Owner="1196638531" Signature="1196644685" Version="34">
<Ancestry SectVersion="1" SectionFlags="0" SubIdent="0" Template="no">
	<MainGUID>F938E33A-329D-4A36-BE3E-85E126820996</MainGUID>
	<MainGUID>103E8D2C-8230-42E1-9597-46F84CCE28C0</MainGUID>
	<MainGUID>784EAEA1-5041-4AA6-B6F4-EF263A891EE7</MainGUID>
	<MainGUID>21DE7666-EF71-4885-8222-629F88CB3F4A</MainGUID>
	<MainGUID>66F6D7C2-637D-4243-91FD-6DB3FC8F91BE</MainGUID>
	<MainGUID>8924BF73-5771-4731-9E84-F87F7C4BCEAB</MainGUID>
</Ancestry>

<CalledMacros SectVersion="2" SectionFlags="0" SubIdent="0">
	<Macro>
		<MName><![CDATA["ks_quadro_wall_database_m"]]></MName>
		<MainGUID>7DC27517-6E2E-45F1-9947-C6AE2694DA20</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["ks_quadro_beamSign"]]></MName>
		<MainGUID>B7053ECB-3415-4A41-85D6-5958DF89F4A9</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["ks_quadro_conn_sign"]]></MName>
		<MainGUID>747F6762-E566-49E9-A695-8331AAD5C4BE</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["ks_quadro_lintel_m"]]></MName>
		<MainGUID>7C7BDCAB-FB20-4578-8CF4-97490E05F8C5</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["ks_quadro_sign"]]></MName>
		<MainGUID>7BDF8326-C493-402A-AE3A-9AF395FCA7DF</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["ks_quadro_brick_m"]]></MName>
		<MainGUID>10D759A4-38F8-4042-A9CA-7BADDA47EA9C</MainGUID>
	</Macro>
</CalledMacros>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_3D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! -----------------------------------------------------------------------
! General Settings
! -----------------------------------------------------------------------
if iDetlevel3D = DETLEVEL_3D_NONE then end
pen pen3D
unID = 1
nCutAth			= 0
habarcsStatus	= 8
habarcsStatus2	= 15
isSectionView	= (GLOB_CONTEXT = 4 | GLOB_CONTEXT = 24 | GLOB_CONTEXT =44)
isSideView		= (bProj2D)
isMoving		= (int (GLOB_CONTEXT / 10) = 2)
paperToModel	= GLOB_SCALE / 1000
modelToPaper	= 1000 / GLOB_SCALE
if isMoving then iDetLevel3D = DETLEVEL_3D_BLOCK

define material "Sign_red" 2, 255/255, 0/255, 0/255

if bHasWarning then
	fontType	= "Arial"
	fontSize	= 100.0
	fontStyle	= 0
	qq = request("Pen_of_RGB", "255 0 0", fontPen)
	define style "warningTextStyle" fontType, fontSize, 2, fontStyle
	style "warningTextStyle"
!!	qq = request("Height_of_style", "warningTextStyle", fontHeight)
!!	fontHeight = fontHeight * paperToModel
	fontHeight = (fontSize / 1000) * 1.25
endif

! ==============================================================================
! Curved wall
! ==============================================================================
if bCurvedWall then
	pen fontPen
	material "Sign_red"
	text 0.01, 0, stCurvedWall
	end
endif


! ==============================================================================
! 2D Display Options
! ==============================================================================

!gs_2D_projection_type:
!	0 - Normal 3D
!	1 - View Edges
!	2 - View Polygons
!	3 - Overhead Edges
!	4 - Cut Lines
!	5 - Cut Polygons
!	6 - Bottom Range Cut Lines
!	7 - Top Range Cut Lines

nProjectionCut = 0
if gs_2D_projection then
	if AC_symb_show_projection_to = PROJECTION_FLOOR_PLAN_RANGE | (AC_symb_show_projection_to = PROJECTION_DISPLAY_LIMIT & gs_bottom_range_height < gs_cutplane_height) then
		addz gs_bottom_range_height
		cutplane{2} 180, 2
		nProjectionCut = nProjectionCut + 1
		del 1
	endif
	if gs_2D_projection_type <> 6 then
		addz gs_cutplane_height
		cutplane{2} 180 * (gs_2D_projection_type = 3), 1
		nProjectionCut = nProjectionCut + 1
		del 1
	endif
	if AC_symb_show_projection_to <> 3 then
		addz gs_top_range_height
		cutplane{2} 0, 2
		nProjectionCut = nProjectionCut + 1
		del 1
	endif
endif


! ------------------------------------------------------------------------------
! Base TransFormation
! ------------------------------------------------------------------------------
rotx 90
mulz surfaceDir

! ==============================================================================
!
! Materials
!
! ==============================================================================
define texture "ks_quadro_texture" "ks_quadro_texture",      0.6,      0.35,  1+2+4+8+16+32+128+256,          0

define material	"KS-Quadro_Concrete" 20,
	  0.9568,   0.9568,   0.9568,
	  0.8,   0.9,  0.05,     0,      1,     0,
	  0.463569,   0.453376,   0.397696,
	  0,          0,          0,
	  0, 		  0,    -1,
	  ind(texture, "ks_quadro_texture")

define texture "ks_quadro_grout" "ks_quadro_grout",      0.1,      0.1,  578,          0

define material	"KS-Quadro_Grout" 20,
	  0.560784,   0.568627,   0.517647,
	  0.8,   0.9,  0.05,     0,      1,     0,
	  0.463569,   0.453376,   0.397696,
	  0,          0,          0,
	  0, 0,    -1, ind(texture, "ks_quadro_grout")

define material	"KS-Quadro_vertical_glue" 20,
	  255/255, 0/255, 0/255,
	  0.8,   0.9,  0.05,     0.5,      1,     0,
	  0.463569,   0.453376,   0.397696,
	  0,          0,          0,
	  0, 0,    -1, 0

brickMat	= ind(material, "KS-Quadro_Concrete")
groutMat	= ind(material, "KS-Quadro_Grout")
glueMat		= ind(material, "KS-Quadro_vertical_glue")
q=REQUEST("Pen_of_RGB", "255 0 0", penGlue)

! ==============================================================================
!
! Hotspots
!
! ==============================================================================
! ------------------------------------------------------------------------------
! Contour Hotspots
! ------------------------------------------------------------------------------
unID=100
for i = 1 to nPolygonPoint-1
	hotspot contourPoints[i][1], contourPoints[i][2], 0, unID	:	unID=unID+1
	!!lin_ contourPoints[i][1], contourPoints[i][2], 0, contourPoints[i][1]+1, contourPoints[i][2], 0
next i
for i = 1 to nPolygonPoint-1
	hotspot contourOutPoints[i][1], contourOutPoints[i][2], -brickThk, unID	:	unID=unID+1
	!!lin_ contourOutPoints[i][1], contourOutPoints[i][2], -brickThk, contourOutPoints[i][1]+1, contourOutPoints[i][2], -brickThk
next i


! ------------------------------------------------------------------------------
! Windows/Doors Hotspots
! ------------------------------------------------------------------------------
unID = 1000
for i = 1 to nOpeningPolygons
	!!hotspot origOpeningBoundingBox[i][1], origOpeningBoundingBox[i][2], 0, unID			:unID=unID+1
	!!hotspot origOpeningBoundingBox[i][3], origOpeningBoundingBox[i][2], 0, unID			:unID=unID+1
	!!hotspot origOpeningBoundingBox[i][3], origOpeningBoundingBox[i][4], 0, unID			:unID=unID+1
	!!hotspot origOpeningBoundingBox[i][1], origOpeningBoundingBox[i][4], 0, unID			:unID=unID+1

	for j = origOpeningStartEnd[i][1] to origOpeningStartEnd[i][2] - 1
		hotspot origOpeningPoligons[j][1], origOpeningPoligons[j][2], 0,			unID	:unID=unID+1
		hotspot origOpeningPoligons[j][1], origOpeningPoligons[j][2], -brickThk,	unID	:unID=unID+1
	next j
next i

! ------------------------------------------------------------------------------
! Corner hotspots
! ------------------------------------------------------------------------------
unID = 8000
if bShowEdit then
	!if surfaceDir = -1 then mulz -1

	!rotx 90*surfaceDir
		signSize = 0.1
	
		addx boundingRef[1][1] - 3*signSize
		hotspot  0,  						0,    						0,  			unID,  jUiAngle1, 6		: unID = unID + 1
		hotspot  0,							1,							0,  			unID,  jUiAngle1, 4+128	: unID = unID + 1
		hotspot  0,  						0,    						-surfaceDir,  	unID,  jUiAngle1, 7		: unID = unID + 1
		hotspot  signSize*sin(jUiAngle1),  	signSize*cos(jUiAngle1),    0,				unID,  jUiAngle1, 5		: unID = unID + 1
		jUiAngle = jUiAngle1
		gosub "cornerSign"
		del 1
	
		addx boundingRef[1][3] + 3*signSize
		hotspot  0,  						0,    						0,  			unID,  jUiAngle2, 6		: unID = unID + 1
		hotspot  0,							1,							0,  			unID,  jUiAngle2, 4+128	: unID = unID + 1
		hotspot  0,  						0,    						-surfaceDir,  	unID,  jUiAngle2, 7		: unID = unID + 1
		hotspot  signSize*sin(jUiAngle2),  	signSize*cos(jUiAngle2),    0,				unID,  jUiAngle2, 5		: unID = unID + 1
		jUiAngle = jUiAngle2
		gosub "cornerSign"
		del 1
	!del 1

	!if surfaceDir = -1 then del 1
endif


! ------------------------------------------------------------------------------
! Beam Hotspots
! ------------------------------------------------------------------------------
unID = 9000
for i = 1 to nOpeningPolygons
	if bShowEdit then
		if i <= nBeams then
			opHalfX = (origOpeningBoundingBox[i][3]-origOpeningBoundingBox[i][1])/2
			add (origOpeningBoundingBox[i][1]+origOpeningBoundingBox[i][3])/2, origOpeningBoundingBox[i][4], plasterThkIn + BIGEPS
			signSize = 0.2/2

			hotspot  0, 	0,	0,  	unID : unID = unID + 1
			
			hotspot  0,  							0,    							0,  			unID,  beamAngles[i], 6,		beamStrings[i]	: unID = unID + 1
			hotspot  0,								1,								0,  			unID,  beamAngles[i], 4+128,	beamStrings[i]	: unID = unID + 1
			hotspot  0,  							0,    							-surfaceDir,  	unID,  beamAngles[i], 7,		beamStrings[i]	: unID = unID + 1
			hotspot  signSize*sin(beamAngles[i]),  	signSize*cos(beamAngles[i]),    0,				unID,  beamAngles[i], 5,		beamStrings[i]	: unID = unID + 1			

			gosub "beamTypeSign"

			if iBeamFamilys[i] = BEAM_FAMILY_CUSTOM then
				hotspot  opHalfX+customBeamOverlaps[i],	 0,  					0, unID,  customBeamHeights[i], 1+128	: unID = unID + 1
				hotspot  opHalfX+customBeamOverlaps[i],  -1,  					0, unID,  customBeamHeights[i], 3		: unID = unID + 1
				hotspot  opHalfX+customBeamOverlaps[i],  customBeamHeights[i],	0, unID,  customBeamHeights[i], 2		: unID = unID + 1	

				hotspot  opHalfX+customBeamOverlaps[i],	 0,  					-brickThk, unID,  customBeamHeights[i], 1+128	: unID = unID + 1
				hotspot  opHalfX+customBeamOverlaps[i],  -1,  					-brickThk, unID,  customBeamHeights[i], 3		: unID = unID + 1
				hotspot  opHalfX+customBeamOverlaps[i],  customBeamHeights[i],	-brickThk, unID,  customBeamHeights[i], 2		: unID = unID + 1	

				hotspot -opHalfX-customBeamOverlaps[i],	 0,  					0, unID,  customBeamHeights[i], 1+128	: unID = unID + 1
				hotspot -opHalfX-customBeamOverlaps[i],  -1,  					0, unID,  customBeamHeights[i], 3		: unID = unID + 1
				hotspot -opHalfX-customBeamOverlaps[i],  customBeamHeights[i],	0, unID,  customBeamHeights[i], 2		: unID = unID + 1	

				hotspot -opHalfX-customBeamOverlaps[i],	 0,  					-brickThk, unID,  customBeamHeights[i], 1+128	: unID = unID + 1
				hotspot -opHalfX-customBeamOverlaps[i],  -1,  					-brickThk, unID,  customBeamHeights[i], 3		: unID = unID + 1
				hotspot -opHalfX-customBeamOverlaps[i],  customBeamHeights[i],	-brickThk, unID,  customBeamHeights[i], 2		: unID = unID + 1	

				hotspot  opHalfX,	 					0, 0, unID,  customBeamOverlaps[i], 1+128	: unID = unID + 1
				hotspot  opHalfX-1,  					0, 0, unID,  customBeamOverlaps[i], 3		: unID = unID + 1
				hotspot  opHalfX+customBeamOverlaps[i],	0, 0, unID,  customBeamOverlaps[i], 2		: unID = unID + 1	

				hotspot  opHalfX,	 					0, -brickThk, unID,  customBeamOverlaps[i], 1+128	: unID = unID + 1
				hotspot  opHalfX-1,  					0, -brickThk, unID,  customBeamOverlaps[i], 3		: unID = unID + 1
				hotspot  opHalfX+customBeamOverlaps[i], 0, -brickThk, unID,  customBeamOverlaps[i], 2		: unID = unID + 1	

				hotspot  -opHalfX,	 						0, 0, unID,  customBeamOverlaps[i], 1+128	: unID = unID + 1
				hotspot  -opHalfX+1,  						0, 0, unID,  customBeamOverlaps[i], 3		: unID = unID + 1
				hotspot  -opHalfX-customBeamOverlaps[i],	0, 0, unID,  customBeamOverlaps[i], 2		: unID = unID + 1	

				hotspot  -opHalfX,	 						0, -brickThk, unID,  customBeamOverlaps[i], 1+128	: unID = unID + 1
				hotspot  -opHalfX+1,  						0, -brickThk, unID,  customBeamOverlaps[i], 3		: unID = unID + 1
				hotspot  -opHalfX-customBeamOverlaps[i],	0, -brickThk, unID,  customBeamOverlaps[i], 2		: unID = unID + 1		
			endif

!!			if iBeamFamilys[i] = BEAM_FAMILY_CUSTOM then
!!				hotspot  linderCoords[i][LINDER_LENGTH]/2,	 0,  					0, unID,  customBeamHeights[i], 1+128	: unID = unID + 1
!!				hotspot  linderCoords[i][LINDER_LENGTH]/2,  -1,  					0, unID,  customBeamHeights[i], 3		: unID = unID + 1
!!				hotspot  linderCoords[i][LINDER_LENGTH]/2,  customBeamHeights[i],	0, unID,  customBeamHeights[i], 2		: unID = unID + 1	
!!
!!				hotspot  linderCoords[i][LINDER_LENGTH]/2,	 0,  					-brickThk, unID,  customBeamHeights[i], 1+128	: unID = unID + 1
!!				hotspot  linderCoords[i][LINDER_LENGTH]/2,  -1,  					-brickThk, unID,  customBeamHeights[i], 3		: unID = unID + 1
!!				hotspot  linderCoords[i][LINDER_LENGTH]/2,  customBeamHeights[i],	-brickThk, unID,  customBeamHeights[i], 2		: unID = unID + 1	
!!
!!				hotspot -linderCoords[i][LINDER_LENGTH]/2,	 0,  					0, unID,  customBeamHeights[i], 1+128	: unID = unID + 1
!!				hotspot -linderCoords[i][LINDER_LENGTH]/2,  -1,  					0, unID,  customBeamHeights[i], 3		: unID = unID + 1
!!				hotspot -linderCoords[i][LINDER_LENGTH]/2,  customBeamHeights[i],	0, unID,  customBeamHeights[i], 2		: unID = unID + 1	
!!
!!				hotspot -linderCoords[i][LINDER_LENGTH]/2,	 0,  					-brickThk, unID,  customBeamHeights[i], 1+128	: unID = unID + 1
!!				hotspot -linderCoords[i][LINDER_LENGTH]/2,  -1,  					-brickThk, unID,  customBeamHeights[i], 3		: unID = unID + 1
!!				hotspot -linderCoords[i][LINDER_LENGTH]/2,  customBeamHeights[i],	-brickThk, unID,  customBeamHeights[i], 2		: unID = unID + 1	
!!
!!				hotspot  linderCoords[i][LINDER_OPENING_SIZE]/2,	 					0, 0, unID,  customBeamOverlaps[i], 1+128	: unID = unID + 1
!!				hotspot  linderCoords[i][LINDER_OPENING_SIZE]/2-1,  					0, 0, unID,  customBeamOverlaps[i], 3		: unID = unID + 1
!!				hotspot  linderCoords[i][LINDER_OPENING_SIZE]/2+customBeamOverlaps[i],  0, 0, unID,  customBeamOverlaps[i], 2		: unID = unID + 1	
!!
!!				hotspot  linderCoords[i][LINDER_OPENING_SIZE]/2,	 					0, -brickThk, unID,  customBeamOverlaps[i], 1+128	: unID = unID + 1
!!				hotspot  linderCoords[i][LINDER_OPENING_SIZE]/2-1,  					0, -brickThk, unID,  customBeamOverlaps[i], 3		: unID = unID + 1
!!				hotspot  linderCoords[i][LINDER_OPENING_SIZE]/2+customBeamOverlaps[i],  0, -brickThk, unID,  customBeamOverlaps[i], 2		: unID = unID + 1	
!!
!!				hotspot  -linderCoords[i][LINDER_OPENING_SIZE]/2,	 					0, 0, unID,  customBeamOverlaps[i], 1+128	: unID = unID + 1
!!				hotspot  -linderCoords[i][LINDER_OPENING_SIZE]/2+1,  					0, 0, unID,  customBeamOverlaps[i], 3		: unID = unID + 1
!!				hotspot  -linderCoords[i][LINDER_OPENING_SIZE]/2-customBeamOverlaps[i], 0, 0, unID,  customBeamOverlaps[i], 2		: unID = unID + 1	
!!
!!				hotspot  -linderCoords[i][LINDER_OPENING_SIZE]/2,	 					0, -brickThk, unID,  customBeamOverlaps[i], 1+128	: unID = unID + 1
!!				hotspot  -linderCoords[i][LINDER_OPENING_SIZE]/2+1,  					0, -brickThk, unID,  customBeamOverlaps[i], 3		: unID = unID + 1
!!				hotspot  -linderCoords[i][LINDER_OPENING_SIZE]/2-customBeamOverlaps[i],	0, -brickThk, unID,  customBeamOverlaps[i], 2		: unID = unID + 1		
!!			endif
	
			del 1
		endif
	endif
next i


! ------------------------------------------------------------------------------
! T connection hotspots
! ------------------------------------------------------------------------------
if tConnections & bShowEdit then
	unID = 10000
	rotx -90
	for i = 1 to nConnTParam
		if tConnWallPos[i] > EPS then
			conTop 		= tConnWallHmax[i]
			conBot 		= tConnWallHmin[i]
			conCenter	= (conTop + conBot) /2

			muly -1
			addy -brickThk
				hotspot 0,					tConnWallDir[i],	conCenter,	unID,	tConnWallPos[i], 1+128	: unID = unID + 1
				hotspot -1,					tConnWallDir[i],	conCenter,	unID,	tConnWallPos[i], 3		: unID = unID + 1
				hotspot tConnWallPos[i],	tConnWallDir[i],	conCenter,	unID,	tConnWallPos[i], 2		: unID = unID + 1
		
				hotspot tConnWallPos[i],	0,					conCenter,	unID,	tConnWallDir[i], 1+128	: unID = unID + 1
				hotspot tConnWallPos[i],	-1,					conCenter,	unID,	tConnWallDir[i], 3		: unID = unID + 1
				hotspot tConnWallPos[i],	tConnWallDir[i],	conCenter,	unID,	tConnWallDir[i], 2		: unID = unID + 1
		
				add tConnWallPos[i], tConnWallDir[i], 0
					lin_ -tConnWallThk[i]/2, 0, conBot, tConnWallThk[i]/2, 0, conBot
					lin_ -tConnWallThk[i]/2, 0, conTop, tConnWallThk[i]/2, 0, conTop
					lin_ -tConnWallThk[i]/2, 0, conBot, -tConnWallThk[i]/2, 0, conTop
					lin_  tConnWallThk[i]/2, 0, conBot,  tConnWallThk[i]/2, 0, conTop

					hotspot 0,	0,	0,					unID,	tConnWallHmin[i], 1+128	: unID = unID + 1
					hotspot 0,	0,	-1,					unID,	tConnWallHmin[i], 3		: unID = unID + 1
					hotspot 0,	0,	tConnWallHmin[i],	unID,	tConnWallHmin[i], 2		: unID = unID + 1

					hotspot 0,	0,	0,					unID,	tConnWallHmax[i], 1+128	: unID = unID + 1
					hotspot 0,	0,	-1,					unID,	tConnWallHmax[i], 3		: unID = unID + 1
					hotspot 0,	0,	tConnWallHmax[i],	unID,	tConnWallHmax[i], 2		: unID = unID + 1
				del 1
			del 2
		endif
	next i
	del 1
endif


!!! ------------------------------------------------------------------------------
!!! Debug
!!! ------------------------------------------------------------------------------
!!model wire
!!pen 1
!!!!for i = 1 to nPolygonPoint
!!!!	put contourPoints[i][1], contourPoints[i][2], 15
!!!!next i
!!!!put contourPoints[1][1], contourPoints[1][2], -1
!!for i = 1 to nUniContourPoint
!!	put uniContourPoint[i][1], uniContourPoint[i][2], 15
!!next i
!!put uniContourPoint[1][1], uniContourPoint[1][2], -1
!!for i = 1 to nOpeningPolygons
!!	for j = origOpeningStartEnd[i][1] to origOpeningStartEnd[i][2]
!!		if j = origOpeningStartEnd[i][2] then
!!			put origOpeningPoligons[j][1], origOpeningPoligons[j][2], -1
!!		else
!!			put origOpeningPoligons[j][1], origOpeningPoligons[j][2], 15
!!		endif
!!	next j
!!next i
!!prism_ nsp/3, brickThk,
!!	get(nsp)


! ==============================================================================
!
! 3D Cutting
!
! ==============================================================================
unID		= 20000
nCutWD		= 0
nCut		= 0
cutStatus	= 15
nSideCut	= 0
minCubeX	= min(boundingRef[1][1],boundingOther[1][1])
maxCubeX	= max(boundingRef[1][3],boundingOther[1][3])

!gosub "sideCut"
gosub "polygonCut"
gosub "openingCut"
del 2	!del base transform
muly surfaceDir



! ==============================================================================
!
! Linders
!
! ==============================================================================
model solid
material brickMat
sect_fill gs_fill_type, gs_back_pen, gs_fill_pen, gs_cont_pen
for i = 1 to nLinderUsed
	if usedLinderTypes[i][LINDER_FAMILY_NAME] <> BEAM_FAMILY_NONE and usedLinderTypes[i][LINDER_FAMILY_NAME] <> BEAM_FAMILY_CUSTOM then
		add usedLinderCoords[i][LINDER_CENTER_X], 0, usedLinderCoords[i][LINDER_CENTER_Y]
		if usedLinderTypes[i][LINDER_MULTI_IDX] > 0 then !multi
			multiIdx = usedLinderTypes[i][LINDER_MULTI_IDX]
			for j = 1 to nMultiSubBeams[multiIdx]
				idx = multiBeamsIdxs[multiIdx][j]
				posY = multiBeamsPos[multiIdx][j] + brickThk/2 - datBeamSize[idx][BRICKSIZE_THK]/2
				addy posY
				call "ks_quadro_lintel_m" parameters	beamName			= datBeamName[idx],
													iBeamFamily			= usedLinderTypes[i][LINDER_FAMILY_NAME],!	datBeamFamily[idx],
													iBeamType			= usedLinderTypes[i][LINDER_TYPE],
													iBeam				= datBeamIdx[idx],
													iBeamFamilyIdx		= usedLinderTypes[i][LINDER_FAMILY_IDX],
													iBeamIdx			= idx,
													bOverLapped			= usedLinderTypes[i][LINDER_OVERLAPPED],
													bOversized			= usedLinderTypes[i][LINDER_OVERSIZED],
													bPosError			= usedLinderTypes[i][LINDER_POSERROR],
			
													overhang			= usedLinderCoords[i][LINDER_OVERHANG],
													customLength		= usedLinderCoords[i][LINDER_LENGTH],
													brickWidthOne		= datBeamSize[idx][BRICKSIZE_WIDTH],
													beamWidth			= datBeamSize[idx][BRICKSIZE_WIDTH],
													beamThk				= datBeamSize[idx][BRICKSIZE_THK],
													beamHeight			= datBeamSize[idx][BRICKSIZE_HEIGHT]
				del 1
			next j
		else
			idx = usedLinderTypes[i][LINDER_IDX]
			call "ks_quadro_lintel_m" parameters	iBeamFamily			= usedLinderTypes[i][LINDER_FAMILY_NAME],
												iBeamType			= usedLinderTypes[i][LINDER_TYPE],
												iBeam				= usedLinderTypes[i][LINDER_NAME],
												iBeamFamilyIdx		= usedLinderTypes[i][LINDER_FAMILY_IDX],
												iBeamIdx			= usedLinderTypes[i][LINDER_IDX],
												bOverLapped			= usedLinderTypes[i][LINDER_OVERLAPPED],
												bOversized			= usedLinderTypes[i][LINDER_OVERSIZED],
												bPosError			= usedLinderTypes[i][LINDER_POSERROR],
		
												overhang			= usedLinderCoords[i][LINDER_OVERHANG],
												customLength		= usedLinderCoords[i][LINDER_LENGTH],
												brickWidthOne		= datBeamSize[idx][BRICKSIZE_WIDTH],
												beamWidth			= datBeamSize[idx][BRICKSIZE_WIDTH],
												beamThk				= datBeamSize[idx][BRICKSIZE_THK],
												beamHeight			= datBeamSize[idx][BRICKSIZE_HEIGHT],
		
												bNoHotspot			= 1,
												iDetlevel3D			= iDetlevel3D,
												pen3D				= pen3D,
												gs_cont_pen			= gs_cont_pen,
												gs_fill_type		= gs_fill_type,
												gs_fill_pen			= gs_fill_pen,
												gs_back_pen			= gs_back_pen,
												brickMat			= brickMat,
												unID				= unID,
				returned_parameters unID
		endif
		del 1
	endif
next i

pen penGlue
material "KS-Quadro_vertical_glue"
for i = 1 to nVerticalGlue
	add verticalGlue[i][1], 0, verticalGlue[i][2]
	rotx 90
	for j = 1 to 2
		if j = 1 then
			addz BIGEPS
		else
			addz -brickThk - BIGEPS
		endif

		poly_ 5,
			-verticalGlue[i][3]/2,	0,	1,
			 verticalGlue[i][3]/2,	0,	1,
			 verticalGlue[i][3]/2,	verticalGlue[i][4],	1,
			-verticalGlue[i][3]/2,	verticalGlue[i][4],	1,
			-verticalGlue[i][3]/2,	0,	-1

		del 1
	next j
	del 2
next i


! ==============================================================================
!
! Habarcs (csak az áthidalokhoz)
!
! ==============================================================================
!----Linder Cut Habarcs----	
pen pen3D
if not(isSideView) & not(isMoving) & bShowGrout then
	del 1
	nCutAth		= 0
	rotx 90
	mulz surfaceDir
	gosub "linderCutGrout"
	del 2	!del base transform
	muly surfaceDir
	
	model solid
	material groutMat
	for i = 1 to nLinderUsed
		if usedLinderTypes[i][LINDER_TYPE] <> BEAM_TYP_CUSTOM & usedLinderTypes[i][LINDER_TYPE] <> BEAM_TYP_NONE then
			grThkBot	= max(beamGroutThk, groutHorizontal)
			add usedLinderCoords[i][LINDER_CENTER_X], 0, usedLinderCoords[i][LINDER_CENTER_Y]-grThkBot
				prism_ 5, usedLinderCoords[i][4]+grThkBot,
					-usedLinderCoords[i][LINDER_LENGTH]/2-beamSideGroutThk, groutOffset,			habarcsStatus2, 
					 usedLinderCoords[i][LINDER_LENGTH]/2+beamSideGroutThk, groutOffset,			habarcsStatus2, 
					 usedLinderCoords[i][LINDER_LENGTH]/2+beamSideGroutThk, brickThk-groutOffset,	habarcsStatus2, 
					-usedLinderCoords[i][LINDER_LENGTH]/2-beamSideGroutThk, brickThk-groutOffset,	habarcsStatus2,
					-usedLinderCoords[i][LINDER_LENGTH]/2-beamSideGroutThk, groutOffset,			-1
			del 1
		endif
	next i
	
	for i = 1 to nCutAth
		cutend
	next i
endif

!----Linder Cut----
del 1
nCutAth		= 0
rotx 90
mulz surfaceDir
gosub "linderCut"
del 2	!del base transform
muly surfaceDir


! ==============================================================================
!
! Bricks
!
! ==============================================================================
method = 0
gosub "brickPlacer"

! ------------------------------------------------------------------------------
! Linder Cut End
! ------------------------------------------------------------------------------
for i = 1 to nCutAth
	cutend
next i

! ------------------------------------------------------------------------------
! Windows Doors Cut End
! ------------------------------------------------------------------------------
for i = 1 to nCutWD
	cutend
next i

gosub "brickPlacerWindow"



! ==============================================================================
!
! 3D Cutting End
!
! ==============================================================================
! ------------------------------------------------------------------------------
! Polygon Cut End
! ------------------------------------------------------------------------------
for i = 1 to nCut
	cutend
next i

! ------------------------------------------------------------------------------
! Side Cut End
! ------------------------------------------------------------------------------
for i = 1 to nSideCut
	cutend
next i

del 1


! ------------------------------------------------------------------------------
! Projection Cut End
! ------------------------------------------------------------------------------
for i = 1 to nProjectionCut
	cutend
next i



! ==============================================================================
! Warnings
! ==============================================================================
if nOverlappedLinders + nOversizedLinder + nLinderPosError > 0 then
	signSize	= 0.2
	pen fontPen
	material "Sign_red"

	for i = 1 to nLinderUsed
		nWarning = 0
		add usedLinderCoords[i][LINDER_CENTER_X], 0, usedLinderCoords[i][LINDER_CENTER_Y]
		rotx 90
			if usedLinderTypes[i][LINDER_OVERSIZED] | usedLinderTypes[i][LINDER_POSERROR] then
				addx nWarning * signSize
				iSignType = 1
				gosub "drawWarningSign"
				nWarning = nWarning + 1
				if usedLinderTypes[i][LINDER_POSERROR] then
					mulz -surfaceDir
					addz -(plasterThkIn + BIGEPSCM)
					textThk = brickThk + plasterThkOut + plasterThkIn + 2*BIGEPSCM

					dim outStrs[]
					inputStr		= stPosIncorrect
					strSeparator	= "\n"
					gosub "textSplitter"
					for z = 1 to vardim1(outStrs)
						addy -(z-1) * fontHeight
						text textThk, 0, outStrs[z]
						del 1
					next z

					del 2
				endif
				del 1
			endif
	
			if usedLinderTypes[i][LINDER_OVERLAPPED] then
				addx nWarning * signSize
				iSignType = 2
				gosub "drawWarningSign"
				nWarning = nWarning + 1
				del 1
			endif
		del 2
	next i
endif



! ==============================================================================
!
end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
!
! ==============================================================================


! ==============================================================================
!
! Subrutines
!
! ==============================================================================
! ------------------------------------------------------------------------------
"drawWarningSign":
! ------------------------------------------------------------------------------
	sA = signSize
	sB = signSize
	if iSignType = 2 then sB = signSize/2
	mulz -surfaceDir

	addz -(plasterThkIn + BIGEPSCM)
	call "ks_quadro_sign" parameters	A			= sA,
									B			= sB,
									iSignType	= iSignType
	del 1

	addz brickThk + plasterThkOut + BIGEPSCM
	call "ks_quadro_sign" parameters	A			= sA,
									B			= sB,
									iSignType	= iSignType
	del 1

	del 1
return

! ------------------------------------------------------------------------------
"brickPlacer":
! ------------------------------------------------------------------------------
	for nSor = 1 to nMagPoint
		model solid
		material brickMat

		!Cutters definitions
		for nCurCut = 1 to nRowCutters[nSor]
			for j = 1 to nBrickCutter
				if brickCuttersType[j] = rowCutters[nSor][nCurCut] then
					!prism_ 4, 3,
					cutpolya 4, 1, 0,
						brickCutters[j][1], brickCutters[j][2], 15,
						brickCutters[j][3], brickCutters[j][4], 15,
						brickCutters[j][5], brickCutters[j][6], 15,
						brickCutters[j][7], brickCutters[j][8], 15	
					j		= nBrickCutter
				endif
			next j
		next nCurCut

		!Bricks
		if iDetlevel3D = DETLEVEL_3D_BLOCK | isSectionView then
			for i = rowIndex[nSor][1] to rowIndex[nSor][2]
				add brickCoord[i][1]+brickCut[i][1], 0, brickCoord[i][2]
				!if brickCoord[i][5]-brickCut[i][3] < EPS then
					block brickCoord[i][3], brickThk,  brickCoord[i][5]-brickCut[i][3]
				!endif
				if bBrickDebug then
					if brickCoord[i][3] < brickWidth - BIGEPSCM then
						lin_ 0,brickThk,0,  brickCoord[i][3], brickThk, brickCoord[i][5]-brickCut[i][3]
						lin_ 0,0,0,  brickCoord[i][3], 0, brickCoord[i][5]-brickCut[i][3]
					endif
				endif
				del 1
			next i
		else
			for i = rowIndex[nSor][1] to rowIndex[nSor][2]
				pType	= brickDef[i][3]
				pIdx	= brickDef[i][4]
				if pIdx > 0 & pIdx <> elemWindowIdx then
					add brickCoord[i][1], 0, brickCoord[i][2]
					call "ks_quadro_brick_m" parameters	iFamily				= datBrickFamily[pIdx],
													iProductType		= pType,
													iProductIdx			= pIdx,
													brickWidth			= datBrickSize[pIdx][BRICKSIZE_WIDTH],
													brickThk			= datBrickSize[pIdx][BRICKSIZE_THK],
													brickHeight			= datBrickSize[pIdx][BRICKSIZE_HEIGHT],
													minBrickSize		= minBrickSize,
													minBrickOverlap		= minBrickOverlap,
													bMirrored			= brickDef[i][2],
													startCut			= brickCut[i][1],
													endCut				= brickCut[i][2],
													topCut				= brickCut[i][3],
													bNoHotspot			= 1,
													iDetlevel3D			= iDetlevel3D,
													gs_cont_pen			= gs_cont_pen,
													gs_fill_type		= gs_fill_type,
													gs_fill_pen			= gs_fill_pen,
													gs_back_pen			= gs_back_pen,
													brickMat			= brickMat,
													gs_resol			= gs_resol,
													unID				= unID,
								returned_parameters unID	
					del 1
				endif
			next i
		endif

		!---------------Grouts
		if not(isSectionView) & not(isMoving) & bShowGrout then
			model solid
			material groutMat
	
			!Horizontal grout
			for nCol = 1 to nColumnDatas[nSor]
				n		= (nCol-1)*nColData
				xx1		= columnDatas[nSor][n+7]
				xx2		= columnDatas[nSor][n+8]
				yPos	= columnDatas[nSor][n+9]
				if nSor > 1 then
					grBot	= yPos - groutHorizontal
					grTop	= yPos
				else
					grBot	= surfaceYmin
					grTop	= surfaceYmin + groutBase
				endif
				dist	= xx2 - xx1
				dd		= grTop - grBot
	
				if dd > EPS & dist > EPS then
					addz grBot
					prism_ 5, dd,
						xx1, groutOffset, habarcsStatus,
						xx2, groutOffset, habarcsStatus,
						xx2, brickThk-groutOffset, habarcsStatus,
						xx1, brickThk-groutOffset, habarcsStatus,
						xx1, groutOffset, -1
					del 1
				endif
			next nCol
	
	
			!Vertical grout
			for i = rowIndex[nSor][1] to rowIndex[nSor][2]-1
				brickEnd	= brickCoord[i+1][4]
				brickStart	= brickCoord[i][3] + brickCoord[i][4]
				grWidth		= brickEnd - brickStart
				if grWidth > EPS & grWidth < BIGEPSCM then
					yB1		= brickCoord[i][2]
					heigth1	= datBrickSize[brickDef[i][4]] [BRICKSIZE_HEIGHT] - brickCut[i][3]
	
					yB2		= brickCoord[i+1][2]
					heigth2	= datBrickSize[brickDef[i+1][4]] [BRICKSIZE_HEIGHT] - brickCut[i+1][3]
	
					yB		= max(yB1, yB2)
					yTop	= min(yB1+heigth1, yB2+heigth2)
					height	= yTop-yB
	
					if height > EPS then
						addz yB
						prism_ 5, height,
							brickStart, groutOffset, habarcsStatus,
							brickEnd, groutOffset, habarcsStatus,
							brickEnd, brickThk-groutOffset, habarcsStatus,
							brickStart, brickThk-groutOffset, habarcsStatus,
							brickStart, groutOffset, -1
						del 1
					endif
				endif
			next i
		endif
	
		for nCurCut = 1 to nRowCutters[nSor]
			cutend
		next nCurCut
	next nSor

return

! ------------------------------------------------------------------------------
"brickPlacerWindow":
! ------------------------------------------------------------------------------
	for nSor = 1 to nMagPoint
		model solid
		material brickMat

		!Cutters definitions
		for nCurCut = 1 to nRowCutters[nSor]
			for j = 1 to nBrickCutter
				if brickCuttersType[j] = rowCutters[nSor][nCurCut] then
					!prism_ 4, 3,
					cutpolya 4, 1, 0,
						brickCutters[j][1], brickCutters[j][2], 15,
						brickCutters[j][3], brickCutters[j][4], 15,
						brickCutters[j][5], brickCutters[j][6], 15,
						brickCutters[j][7], brickCutters[j][8], 15	
					j		= nBrickCutter
				endif
			next j
		next nCurCut

		!Bricks
		if iDetlevel3D = DETLEVEL_3D_BLOCK | isSectionView then
		else
			for i = rowIndex[nSor][1] to rowIndex[nSor][2]
				pType	= brickDef[i][3]
				pIdx	= brickDef[i][4]
				if pIdx > 0 & pIdx = elemWindowIdx then
					add brickCoord[i][1], 0, brickCoord[i][2]
					call "ks_quadro_brick_m" parameters	iFamily				= datBrickFamily[pIdx],
													iProductType		= pType,
													iProductIdx			= pIdx,
													brickWidth			= datBrickSize[pIdx][BRICKSIZE_WIDTH],
													brickThk			= datBrickSize[pIdx][BRICKSIZE_THK],
													brickHeight			= datBrickSize[pIdx][BRICKSIZE_HEIGHT],
													minBrickSize		= minBrickSize,
													minBrickOverlap		= minBrickOverlap,
													bMirrored			= brickDef[i][2],
													startCut			= brickCut[i][1],
													endCut				= brickCut[i][2],
													topCut				= brickCut[i][3],
													bNoHotspot			= 1,
													iDetlevel3D			= iDetlevel3D,
													gs_cont_pen			= gs_cont_pen,
													gs_fill_type		= gs_fill_type,
													gs_fill_pen			= gs_fill_pen,
													gs_back_pen			= gs_back_pen,
													brickMat			= brickMat,
													gs_resol			= gs_resol,
													unID				= unID,
								returned_parameters unID	
					del 1
				endif
			next i
		endif
	
		for nCurCut = 1 to nRowCutters[nSor]
			cutend
		next nCurCut
	next nSor
return


! ------------------------------------------------------------------------------
! Szélso vágások
! ------------------------------------------------------------------------------
"sideCut":
	if bCut then
		if not(bCsorba1) then
			add boundingRef[1][1], 0, 0
			roty 270+cutAngle01
				cutplane
				!!lin_ -1,0,0,1,0,0
				nSideCut = nSideCut+1
			del 2
		endif
		
		if not(bCsorba2) then
			add boundingRef[1][3], 0, 0
			roty 90+cutAngle02
				cutplane
				!!lin_ -1,0,0,1,0,0
				nSideCut = nSideCut+1
			del 2
		endif
	endif
return

"sideCutU":
	if bCut then
		add boundingRef[1][1], 0, 0
		rotz cutAngle01
		roty 270
			cutplane
			!!lin_ -1,0,0,1,0,0
			nSideCutU = nSideCutU+1
		del 3
	
		add boundingRef[1][3], 0, 0
		rotz cutAngle02
		roty 90
			cutplane
			!!lin_ -1,0,0,1,0,0
			nSideCutU = nSideCutU+1
		del 3
	endif
return


! ------------------------------------------------------------------------------
! Áthidaló vágások
! ------------------------------------------------------------------------------
"linderCut":
	if bCut then
		for i = 1 to nLinderGeomUnified
			add unifiedGeomLinderCoords[i][LINDER_CENTER_X], unifiedGeomLinderCoords[i][LINDER_CENTER_Y]+beamTopGroutThk, 0
			cutpolya 4, 1, 0,
				-unifiedGeomLinderCoords[i][LINDER_LENGTH]/2, -beamTopGroutThk,								cutStatus, 
				 unifiedGeomLinderCoords[i][LINDER_LENGTH]/2, -beamTopGroutThk,								cutStatus, 
				 unifiedGeomLinderCoords[i][LINDER_LENGTH]/2, unifiedGeomLinderCoords[i][LINDER_HEIGHT],	cutStatus, 
				-unifiedGeomLinderCoords[i][LINDER_LENGTH]/2, unifiedGeomLinderCoords[i][LINDER_HEIGHT],	cutStatus

			nCutAth = nCutAth + 1
			del 1
		next i
	endif
return

"linderCutGrout":
	if bCut then
		for i = 1 to nLinderUsed
			add usedLinderCoords[i][LINDER_CENTER_X], usedLinderCoords[i][LINDER_CENTER_Y], 0
			cutpolya 4, 1, 0,
				-usedLinderCoords[i][LINDER_LENGTH]/2+0.005, 0,							cutStatus, 
				 usedLinderCoords[i][LINDER_LENGTH]/2-0.005, 0,							cutStatus, 
				 usedLinderCoords[i][LINDER_LENGTH]/2-0.005, usedLinderCoords[i][LINDER_HEIGHT],	cutStatus, 
				-usedLinderCoords[i][LINDER_LENGTH]/2+0.005, usedLinderCoords[i][LINDER_HEIGHT],	cutStatus

			nCutAth = nCutAth + 1
			del 1
		next i

		for i = 1 to nOpeningPolygons
			cutpolya 4,1,0,
				origOpeningBoundingBox[i][1], origOpeningBoundingBox[i][2], cutStatus,
				origOpeningBoundingBox[i][3], origOpeningBoundingBox[i][2], cutStatus,
				origOpeningBoundingBox[i][3], origOpeningBoundingBox[i][4]+groutCutTop, cutStatus,
				origOpeningBoundingBox[i][1], origOpeningBoundingBox[i][4]+groutCutTop, cutStatus

			nCutAth = nCutAth + 1
		next i
	endif
return



! ------------------------------------------------------------------------------
! Cut Polygon Contour
! ------------------------------------------------------------------------------
"polygonCut":
	if bCut then
		if minXpointNumber < maxXpointNumber then
			for i = minXpointNumber to maxXpointNumber
				put baseCubePoints[i][1], baseCubePoints[i][2], cutStatus
			next i
			put maxCubeX+cutOffset, surfaceYmin-cutOffset, cutStatus
			put minCubeX-cutOffset, surfaceYmin-cutOffset, cutStatus
	
			cutpolya NSP/3, 1, 0,
				get (NSP)
			nCut = nCut + 1
		
			put minCubeX-cutOffset, surfaceYmin-cutOffset, cutStatus
		
			for i = minXpointNumber to 1 step -1
				put baseCubePoints[i][1], baseCubePoints[i][2], cutStatus
			next i
		
			for i = nPolygonPoint-1 to maxXpointNumber step -1
				put baseCubePoints[i][1], baseCubePoints[i][2], cutStatus
			next i
		
			put maxCubeX+cutOffset, surfaceYmin-cutOffset, cutStatus
			put maxCubeX+cutOffset, surfaceYmax+cutOffset, cutStatus
			put minCubeX-cutOffset, surfaceYmax+cutOffset, cutStatus
	
			cutpolya NSP/3, 1, 0,
				get (NSP)
			nCut = nCut + 1
		else
			for i = minXpointNumber to maxXpointNumber step -1
				put baseCubePoints[i][1], baseCubePoints[i][2], cutStatus
			next i
		
			put maxCubeX+cutOffset, surfaceYmin-cutOffset, cutStatus
			put maxCubeX+cutOffset, surfaceYmax+cutOffset, cutStatus
			put minCubeX-cutOffset, surfaceYmax+cutOffset, cutStatus
			put minCubeX-cutOffset, surfaceYmin-cutOffset, cutStatus
		
			cutpolya NSP/3, 1, 0,
				get (NSP)
			nCut = nCut + 1	
		
			put minCubeX-cutOffset, surfaceYmin-cutOffset, cutStatus
			for i = minXpointNumber to nPolygonPoint-1
				put baseCubePoints[i][1], baseCubePoints[i][2], cutStatus
			next i
			for i = 1 to maxXpointNumber
				put baseCubePoints[i][1], baseCubePoints[i][2], cutStatus
			next i
			put maxCubeX+cutOffset, surfaceYmin-cutOffset, cutStatus

			cutpolya NSP/3, 1, 0,
				get (NSP)
			nCut = nCut + 1
		endif
	endif
	
	for i = 1 to NSP
		eee = get(1)
	next i
return


! ------------------------------------------------------------------------------
"beamTypeSign":
! ------------------------------------------------------------------------------
	
	sA = signSize
	sB = signSize*0.4
	rr = signSize
	circRad	= 0.01

	for j = 1 to nBtype
		ang = -(j-1)*aBAnle + 90
		add cos(ang)*rr + sA/2*cos(ang), sin(ang)*rr + sB/2*sin(ang), EPS
		call "ks_quadro_beamSign" parameters	A		= sA,
											B		= sB,
											iBeam	= iBManual[j],
											iPen	= gs_cont_pen,
											iDir	= surfaceDir
		del 1
	next j

	mul signSize/0.01, signSize/0.01, signSize/0.01
	circRad = 0.01	
	for po=1 to 36
		lin_ circRad*cos((po-1)*10),circRad*sin((po-1)*10),0,circRad*cos(po*10),circRad*sin(po*10),0
	next po
	
	lin_    0, 0, 0, 0.01*sin(beamAngles[i]),  	0.01*cos(beamAngles[i]),    	0

	del  1
return


! ------------------------------------------------------------------------------
"cornerSign":
! ------------------------------------------------------------------------------
	sA		= signSize
	sB		= signSize
	rr		= signSize

	for j = 1 to nJointTypes
		ang = -(j-1)*dAng + 90
		add cos(ang)*rr + sA/2*cos(ang), sin(ang)*rr + sB/2*sin(ang), EPS
		call "ks_quadro_conn_sign" parameters	A			= sA,
											B			= sB,
											iJointType	= jointTypes[j],
											iPen		= gs_cont_pen
		del 1
	next j

	for po=1 to 36
		lin_ rr*cos((po-1)*10),rr*sin((po-1)*10),0,rr*cos(po*10),rr*sin(po*10),0
	next po
	
	lin_    0, 0, 0, rr*sin(jUiAngle),  	rr*cos(jUiAngle),    	0
return



! ------------------------------------------------------------------------------
! Cut Windows / Doors
! ------------------------------------------------------------------------------
"openingCut":
	if nOpeningPolygons > 0 & bCut then
		for i = 1 to nOpeningPolygons
			for ii = origOpeningStartEnd[i][1] to origOpeningStartEnd[i][2]
				put origOpeningPoligons[ii][1], origOpeningPoligons[ii][2], origOpeningPoligons[ii][3]
			next ii
		
			if NSP>11 then
				cutpolya NSP/3,1,0,
					get(NSP)
		
				nCutWD = nCutWD + 1
			endif
	
			for j = 1 to NSP
				eee = get(1)
			next j
		next i
	endif
return

]]>
</Script_3D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_2D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! ==============================================================================
! Constans
! ==============================================================================
tConnX = 0.15		!T wall connection 2d segédvonal
paperToModel		= GLOB_SCALE / 1000
modelToPaper		= 1000 / GLOB_SCALE
isMoving			= (int (GLOB_CONTEXT / 10) = 2)
if isMoving then iDetlevel2D = DETLEVEL_2D_BLOCK

if bHasWarning then
	fontType	= "Arial"
	fontSize	= 2.0
	fontStyle	= 0
	qq = request("Pen_of_RGB", "255 0 0", fontPen)
	define style "warningTextStyle" fontType, fontSize, 5, fontStyle
	style "warningTextStyle"
	qq = request("Height_of_style", "warningTextStyle", fontHeight)
	fontHeight = fontHeight * paperToModel
endif

! ==============================================================================
! Curved wall
! ==============================================================================
if bCurvedWall then
	pen fontPen
	text2 0, 0, stCurvedWall
	end
endif

! ==============================================================================
! Fill
! ==============================================================================
define translucent_fill "ks_quadro_vertical_glue" 136, 34, 136, 34, 136, 34, 136, 34,	25
q=REQUEST("Pen_of_RGB", "255 0 0", penGlue)
pen gs_cont_pen
fill gs_fill_type

! ==============================================================================
! SideView
! ==============================================================================
if GLOB_CONTEXT = 6 then
	gosub "sideView"
	end
endif


! ==============================================================================
! Floor Plan View
! ==============================================================================
! ----- Display with floorplan cutplane ------------------------------------
gs_cutplane_height	= GLOB_CSTORY_ELEV - GLOB_HSTORY_ELEV + GLOB_CUTPLANES_INFO[1]
gs_top_range_height	= GLOB_CSTORY_ELEV - GLOB_HSTORY_ELEV + GLOB_CUTPLANES_INFO[2]
if AC_symb_show_projection_to = PROJECTION_FLOOR_PLAN_RANGE | AC_symb_display_option = DISPLAY_SYMBOLIC  then
	gs_bottom_range_height = GLOB_CSTORY_ELEV - GLOB_HSTORY_ELEV + GLOB_CUTPLANES_INFO[3]	! to Floor Plan Range
else
	gs_bottom_range_height = GLOB_CUTPLANES_INFO[4]	! Absolute Display Limit
endif

doCutplane	= (AC_symb_display_option = DISPLAY_PROJECTED | AC_symb_display_option = DISPLAY_OVERHEAD_PROJ)
curZ		= SYMB_POS_Z - GLOB_HSTORY_ELEV


! ==============================================================================
! Hotspots
! ==============================================================================
mul2 1, surfaceDir

! ------------------------------------------------------------------------------
! Contour Hotspots
! ------------------------------------------------------------------------------
unID = 100
hotspot2 boundingRef[1][1],  0,			 	  unID	:	unID=unID+1
hotspot2 boundingRef[1][3],	 0,				  unID	:	unID=unID+1
hotspot2 boundingOther[1][1], brickThk, unID	:	unID=unID+1
hotspot2 boundingOther[1][3], brickThk, unID	:	unID=unID+1


! ------------------------------------------------------------------------------
! Windows/Doors Hotspots
! ------------------------------------------------------------------------------
unID = 1000
for i=1 to nOpeningPolygons
	windowBottom	= origOpeningBoundingBox[i][2] + curZ
	windowTop		= origOpeningBoundingBox[i][4] + curZ
	if (windowBottom <= gs_cutplane_height & windowTop >= gs_cutplane_height) | (windowBottom <= gs_top_range_height & windowTop >= gs_top_range_height) then
		if origOpeningBoundingBox[i][1] >=  boundingRef[1][1] then
			hotspot2 origOpeningBoundingBox[i][1], 0, 				unID		:unID=unID+1
			hotspot2 origOpeningBoundingBox[i][1], brickThk,	unID		:unID=unID+1
			hotline2 origOpeningBoundingBox[i][1], 0, origOpeningBoundingBox[i][1], brickThk
		endif

		if origOpeningBoundingBox[i][3] <= boundingRef[1][3] then
			hotspot2 origOpeningBoundingBox[i][3], 0, 				unID		:unID=unID+1
			hotspot2 origOpeningBoundingBox[i][3], brickThk,	unID		:unID=unID+1
			hotline2 origOpeningBoundingBox[i][3], 0, origOpeningBoundingBox[i][3], brickThk
		endif
	endif
next i

! ------------------------------------------------------------------------------
! Corner hotspots
! ------------------------------------------------------------------------------
unID = 8000
if bShowEdit then
	if surfaceDir = -1 then mul2 1, -1

	signSize = 0.1

	add2 boundingRef[1][1] - 3*signSize, 0
	hotspot2  0,						0,							unID	: unID = unID + 1
	hotspot2  0,  						0,    						unID,  jUiAngle1, 6+512	: unID = unID + 1
	hotspot2  0,						1,							unID,  jUiAngle1, 4+128	: unID = unID + 1
	hotspot2  signSize*sin(jUiAngle1),  signSize*cos(jUiAngle1),    unID,  jUiAngle1, 5		: unID = unID + 1
	jUiAngle = jUiAngle1
	gosub "cornerSign"
	del 1

	add2 boundingRef[1][3] + 3*signSize, 0
	hotspot2  0,						0,							unID	: unID = unID + 1
	hotspot2  0,  						0,    						unID,  jUiAngle2, 6+512	: unID = unID + 1
	hotspot2  0,						1,							unID,  jUiAngle2, 4+128	: unID = unID + 1
	hotspot2  signSize*sin(jUiAngle2),  signSize*cos(jUiAngle2),    unID,  jUiAngle2, 5		: unID = unID + 1
	jUiAngle = jUiAngle2
	gosub "cornerSign"
	del 1

	if surfaceDir = -1 then del 1
endif

! ------------------------------------------------------------------------------
! Colum hotspots
! ------------------------------------------------------------------------------
unID = 9000
if bColPos & bShowEdit then

	for i = 1 to nColumnParam
		if colPosX[i] > surfaceXmin then
			mul2 1, -1
			add2 0, -brickThk/2
				hotspot2 0,				0,	unID,		colPosX[i], 1+128	: unID = unID + 1
				hotspot2 -1,			0,	unID,		colPosX[i], 3		: unID = unID + 1
				hotspot2 colPosX[i],	0,	unID,		colPosX[i], 2		: unID = unID + 1

				add2 colPosX[i], 0
					circle2 0, 0, 0.02
				del 1
			del 2
		endif
	next i

	if firstFreePosC > 0 then
		mul2 1, -1
		add2 0, -brickThk/2

			hotspot2 0,							0,	unID,		colPosX[firstFreePosC], 1+128	: unID = unID + 1
			hotspot2 -1,						0,	unID,		colPosX[firstFreePosC], 3		: unID = unID + 1
			hotspot2 colPosX[firstFreePosC],	0,	unID,		colPosX[firstFreePosC], 2		: unID = unID + 1

			rectSize = 0.25
			add2 cDefPosOut-rectSize/2,-rectSize/2
				circle2 rectSize/2, rectSize/2, 0.07
				rect2 0,0,rectSize,rectSize
			del 1
		del 2
	endif
endif


! ------------------------------------------------------------------------------
! T connection hotspots
! ------------------------------------------------------------------------------
unID = 10000
if tConnections & bShowEdit then

	for i = 1 to nConnTParam
		if tConnWallPos[i] > surfaceXmin then
			mul2 1, -1
			add2 0, -brickThk
				hotspot2 0,					tConnWallDir[i],	unID,		tConnWallPos[i], 1+128	: unID = unID + 1
				hotspot2 -1,				tConnWallDir[i],	unID,		tConnWallPos[i], 3		: unID = unID + 1
				hotspot2 tConnWallPos[i],	tConnWallDir[i],	unID,		tConnWallPos[i], 2		: unID = unID + 1
		
				hotspot2 tConnWallPos[i],	0,					unID,		tConnWallDir[i], 1+128	: unID = unID + 1
				hotspot2 tConnWallPos[i],	-1,					unID,		tConnWallDir[i], 3		: unID = unID + 1
				hotspot2 tConnWallPos[i],	tConnWallDir[i],	unID,		tConnWallDir[i], 2		: unID = unID + 1
		
				add2 tConnWallPos[i], tConnWallDir[i]
					if tConnWallDir[i] < brickThk/2 then mul2 1, -1
					line2 0, -0.02, 0, tConnX
					line2 -tConnWallThk[i]/2, -0.02, tConnWallThk[i]/2, -0.02
					if tConnWallDir[i] < brickThk/2 then del 1
				del 1
			del 2
		endif
	next i

	if firstFreePosT > 0 then
		mul2 1, -1
		add2 0, -brickThk

			hotspot2 0,								tConnWallDir[firstFreePosT],	unID,		tConnWallPos[firstFreePosT], 1+128	: unID = unID + 1
			hotspot2 -1,							tConnWallDir[firstFreePosT],	unID,		tConnWallPos[firstFreePosT], 3		: unID = unID + 1
			hotspot2 tConnWallPos[firstFreePosT],	tConnWallDir[firstFreePosT],	unID,		tConnWallPos[firstFreePosT], 2		: unID = unID + 1
	
			hotspot2 tConnWallPos[firstFreePosT],	0,							unID,		tConnWallDir[firstFreePosT], 1+128	: unID = unID + 1
			hotspot2 tConnWallPos[firstFreePosT],	-1,							unID,		tConnWallDir[firstFreePosT], 3		: unID = unID + 1
			hotspot2 tConnWallPos[firstFreePosT],	tConnWallDir[firstFreePosT],	unID,		tConnWallDir[firstFreePosT], 2		: unID = unID + 1
	
			rectSize = 0.25
			add2 tDefPosOut-rectSize/2,tConnWallDir[firstFreePosT]-rectSize/2
		
				dx1 = 0.015
				dL1 = 0.1
				dL2 = 0.05
				dL3 = 0.1
				
				add2 rectSize/2,rectSize/2-dL3/2
					line2 -dL1, 0,-dL2+dx1,0
					line2  dL1, 0, dL2-dx1,0
					
					line2 -dL1, dx1,-dL2, dx1
					line2  dL1, dx1, dL2, dx1
				
					line2 -dL2+dx1, 0,		-dL2+dx1,	dL3
					line2 -dL2, 	dx1,	-dL2,		dL3
				
					line2  dL2-dx1, 0,		dL2-dx1,	dL3
					line2  dL2, 	dx1,	dL2,		dL3
				del  1
			
				rect2 0,0,rectSize,rectSize
			del 1
		del 2
	endif
endif


! ------------------------------------------------------------------------------
! Contour Hotlines
! ------------------------------------------------------------------------------
hotline2 boundingRef[1][1], 0, boundingRef[1][3], 0
hotline2 boundingRef[1][3], 0, boundingOther[1][3], brickThk
hotline2 boundingOther[1][3], brickThk, boundingOther[1][1], brickThk
hotline2 boundingOther[1][1], brickThk, boundingRef[1][1], 0



! ==============================================================================
! Floor Plan
! ==============================================================================

if bSideView then
	unID = 30000
	del 1
	add2 0, 1
	gosub "EditViewHotspots"
	gosub "sideView"
	del 3
	mul2 1, surfaceDir
endif


unID = 100000
AC_symb_display_option = DISPLAY_SYMBOLIC 

if AC_symb_display_option = DISPLAY_SYMBOLIC then
	nSor = min(int(gs_cutplane_height / brickHeight) + 1, nMagPoint)
	gosub "polyOpOpen"
	for i = rowIndex[nSor][1] to rowIndex[nSor][2]
		if rowIndex[nSor][1] > 0 then
			add2 brickCoord[i][1], 0
			gosub "brickDrawer2D"
			del 1
		endif
	next i
	gosub "polyOpClose"
	del 1
else
	del 1
	! ----- View Edges ---------------------------------------------------------
	pen gs_cont_pen
	line_type gs_cont_line

	if AC_symb_display_option = DISPLAY_OVERHEAD_ALL then
		pen AC_overhead_pen
		line_type AC_overhead_linetype
	endif

	project2{3} 3,270,2 + 32 * (AC_symb_display_option = DISPLAY_OVERHEAD_ALL | not(gs_use_3D_view_attributes)), 8,
		parameters	gs_2D_projection		= doCutplane,
					gs_2D_projection_type	= 1,
					gs_cutplane_height		= gs_cutplane_height,
					gs_top_range_height		= gs_top_range_height,
					gs_bottom_range_height	= gs_bottom_range_height,
					iDetlevel3D				= DETLEVEL_3D_BLOCK,
					bShowEdit				= 0

	if AC_symb_display_option <> DISPLAY_OVERHEAD_ALL then
		! ----- View Polygons --------------------------------------------------
		pen gs_fill_pen
		fill gs_fill_type

		project2{3} 3,270,3+32+1024+2048, 4,
						gs_back_pen,
			parameters	gs_2D_projection		= doCutplane,
						gs_2D_projection_type	= 2,
						gs_cutplane_height		= gs_cutplane_height,
						gs_top_range_height		= gs_top_range_height,
						gs_bottom_range_height	= gs_bottom_range_height,
						iDetlevel3D				= DETLEVEL_3D_BLOCK,
						bShowEdit				= 0
	endif


	if AC_symb_display_option = DISPLAY_OVERHEAD_PROJ then

		! ----- Overhead View -----------------------------------------------------
		pen AC_overhead_pen
		line_type AC_overhead_linetype

		project2{3} 3,270,2+32, 2+8,
			parameters	gs_2D_projection		= doCutplane,
						gs_2D_projection_type	= 3,
						gs_cutplane_height		= gs_cutplane_height,
						gs_top_range_height		= gs_top_range_height,
						gs_bottom_range_height	= gs_bottom_range_height,
						iDetlevel3D				= DETLEVEL_3D_BLOCK,
						bShowEdit				= 0
	endif

	if doCutplane then

		! ----- Cut Lines ---------------------------------------------------------
		pen SYMB_SECT_pen
		line_type AC_cut_linetype
		line_property 2

		project2{3} 3,270,2+16+32+256+4096, 2,
			parameters	gs_2D_projection		= 1,
						gs_2D_projection_type	= 4,
						gs_cutplane_height		= gs_cutplane_height,
						gs_top_range_height		= gs_top_range_height,
						gs_bottom_range_height	= gs_bottom_range_height,
						iDetlevel3D				= DETLEVEL_3D_BLOCK,
						bShowEdit				= 0


		! ----- Cut Polygons ------------------------------------------------------
		pen SYMB_fill_pen
		fill SYMB_fill

		project2{3} 3,270,3+512, 1, SYMB_FBGD_pen,
			parameters	gs_2D_projection		= 1,
						gs_2D_projection_type	= 5,
						gs_cutplane_height		= gs_cutplane_height,
						gs_top_range_height		= gs_top_range_height,
						gs_bottom_range_height	= gs_bottom_range_height,
						iDetlevel3D				= DETLEVEL_3D_BLOCK,
						bShowEdit				= 0
	endif
endif


! ==============================================================================
! Warnings
! ==============================================================================
if nOverlappedLinders + nOversizedLinder + nLinderPosError +  bOpeningFormWarning + bHasCornerWindow > 0 then
	pen fontPen

!!	if bHasCornerWindow then
!!		text2 0, 0, stCornerWindow
!!	endif

	for i = 1 to min(nOpeningPolygons, vardim1(origOpeningForms))
		if origOpeningForms[i] = POLY_FORM_POLYGON_SLANT then
			text2 (origOpeningBoundingBox[i][1]+origOpeningBoundingBox[i][3])/2, -fontHeight, stOpeningForm
		endif
	next i

	for i = 1 to nLinderUsed
		nWarning = 0
		if usedLinderTypes[i][LINDER_OVERSIZED] then
			text2 usedLinderCoords[i][LINDER_CENTER_X], (nWarning+1)*fontHeight, stOversized
			nWarning = nWarning + 1
		endif

		if usedLinderTypes[i][LINDER_POSERROR] then
			text2 usedLinderCoords[i][LINDER_CENTER_X], (nWarning+1)*fontHeight, stPosIncorrect
			nWarning = nWarning + 1
		endif

		if usedLinderTypes[i][LINDER_OVERLAPPED] then
			text2 usedLinderCoords[i][LINDER_CENTER_X], (nWarning+1)*fontHeight, stCollision
			nWarning = nWarning + 1
		endif
	next i

	if bSideView then
		add2 0, 1
		add2 sideViewPos[1][1], sideViewPos[1][2]
		rot2 sideViewRot

		for i = 1 to min(nOpeningPolygons, vardim1(origOpeningForms))
			if origOpeningForms[i] = POLY_FORM_POLYGON_SLANT then
				text2 (origOpeningBoundingBox[i][1]+origOpeningBoundingBox[i][3])/2, origOpeningBoundingBox[i][4]-fontHeight, stOpeningForm
			endif
		next i

		for i = 1 to nLinderUsed
			nWarning = 0
			if usedLinderTypes[i][LINDER_OVERSIZED] then
				text2 usedLinderCoords[i][LINDER_CENTER_X], usedLinderCoords[i][LINDER_CENTER_Y]+(nWarning+1)*fontHeight, stOversized
				nWarning = nWarning + 1
			endif

			if usedLinderTypes[i][LINDER_POSERROR] then
				text2 usedLinderCoords[i][LINDER_CENTER_X], usedLinderCoords[i][LINDER_CENTER_Y]+(nWarning+1)*fontHeight, stPosIncorrect
				nWarning = nWarning + 1
			endif
	
			if usedLinderTypes[i][LINDER_OVERLAPPED] then
				text2 usedLinderCoords[i][LINDER_CENTER_X], usedLinderCoords[i][LINDER_CENTER_Y]+(nWarning+1)*fontHeight, stCollision
				nWarning = nWarning + 1
			endif
		next i
	endif
endif



! ==============================================================================
!
end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
!
! ==============================================================================


! ==============================================================================
!
! Subrutines
!
! ==============================================================================
!!! ------------------------------------------------------------------------------
!!"drawSymbol2D":
!!! ------------------------------------------------------------------------------
!!	nSor = min(int(gs_cutplane_height / brickHeight) + 1, nMagPoint)
!!	for i = rowIndex[nSor][1] to rowIndex[nSor][2]
!!		if rowIndex[nSor][1] > 0 then
!!			add2 brickCoord[i][1], 0
!!
!!			pType	= brickDef[i][3]
!!			pIdx	= brickDef[i][4]
!!			call "ks_quadro_brick_m" parameters	iFamily				= datBrickFamily[pIdx],
!!											iProductType		= pType,
!!											iProductIdx			= pIdx,
!!											brickWidth			= datBrickSize[pIdx][BRICKSIZE_WIDTH],
!!											brickThk			= datBrickSize[pIdx][BRICKSIZE_THK],
!!											brickHeight			= datBrickSize[pIdx][BRICKSIZE_HEIGHT],
!!											minBrickSize		= minBrickSize,
!!											minBrickOverlap		= minBrickOverlap,
!!											bMirrored			= brickDef[i][2],
!!											startCut			= brickCut[i][1],
!!											endCut				= brickCut[i][2],
!!											bNoHotspot			= 1,
!!											iDetlevel2D			= iDetlevel2D,
!!											gs_cont_pen			= gs_cont_pen,
!!											gs_fill_type		= gs_fill_type,
!!											gs_fill_pen			= gs_fill_pen,
!!											gs_back_pen			= gs_back_pen,
!!											unID				= unID,
!!						returned_parameters unID
!!			del 1
!!		endif
!!	next i
!!return


! ------------------------------------------------------------------------------
"EditViewHotspots":
! ------------------------------------------------------------------------------
	hotspot2 0,					sideViewPos[1][2], unID, sideViewPos[1][1], 1+128	: unID = unID + 1
	hotspot2 sideViewPos[1][1], sideViewPos[1][2], unID, sideViewPos[1][1], 2		: unID = unID + 1
	hotspot2 -1,				sideViewPos[1][2], unID, sideViewPos[1][1], 3		: unID = unID + 1

	hotspot2 sideViewPos[1][1], 0,					unID, sideViewPos[1][2], 1+128	: unID = unID + 1
	hotspot2 sideViewPos[1][1], sideViewPos[1][2],	unID, sideViewPos[1][2], 2		: unID = unID + 1
	hotspot2 sideViewPos[1][1], -1,					unID, sideViewPos[1][2], 3		: unID = unID + 1

	add2 sideViewPos[1][1], sideViewPos[1][2]

	hotspot2 0,										0,										unID, sideViewRot, 6		: unID = unID + 1
	hotspot2 boundingRef[1][3],						0,										unID, sideViewRot, 4 + 128	: unID = unID + 1
	hotspot2 boundingRef[1][3] * cos(sideViewRot),	boundingRef[1][3] * sin(sideViewRot),	unID, sideViewRot, 5		: unID = unID + 1

	rot2 sideViewRot
return

! ------------------------------------------------------------------------------
"beamHotspots":
! ------------------------------------------------------------------------------
	unID = 9000
	for i = 1 to nOpeningPolygons
		if bShowEdit then
			if i <= nBeams then
				opHalfX = (origOpeningBoundingBox[i][3]-origOpeningBoundingBox[i][1])/2
				add2 (origOpeningBoundingBox[i][1]+origOpeningBoundingBox[i][3])/2, origOpeningBoundingBox[i][4]
				signSize = 0.2/2
	
				hotspot2  0, 	0,	unID : unID = unID + 1
				
				hotspot2  0,  								0,    							unID,  beamAngles[i], 6+512,	beamStrings[i]	: unID = unID + 1
				hotspot2  0,								1,								unID,  beamAngles[i], 4+128,	beamStrings[i]	: unID = unID + 1
				hotspot2  signSize*sin(beamAngles[i]),  	signSize*cos(beamAngles[i]),    unID,  beamAngles[i], 5,		beamStrings[i]	: unID = unID + 1			
	
				gosub "beamTypeSign"

				if iBeamFamilys[i] = BEAM_FAMILY_CUSTOM then
					hotspot2  opHalfX+customBeamOverlaps[i],	0,  					unID,  customBeamHeights[i], 1+128	: unID = unID + 1
					hotspot2  opHalfX+customBeamOverlaps[i],  -1,  						unID,  customBeamHeights[i], 3		: unID = unID + 1
					hotspot2  opHalfX+customBeamOverlaps[i],  customBeamHeights[i],		unID,  customBeamHeights[i], 2		: unID = unID + 1	
	
					hotspot2  -opHalfX-customBeamOverlaps[i],	0,  					unID,  customBeamHeights[i], 1+128	: unID = unID + 1
					hotspot2  -opHalfX-customBeamOverlaps[i],  -1,  					unID,  customBeamHeights[i], 3		: unID = unID + 1
					hotspot2  -opHalfX-customBeamOverlaps[i],  customBeamHeights[i],	unID,  customBeamHeights[i], 2		: unID = unID + 1	
	
					hotspot2  -opHalfX,	 					 	0, unID,  customBeamOverlaps[i], 1+128	: unID = unID + 1
					hotspot2  -opHalfX+1,  					 	0, unID,  customBeamOverlaps[i], 3		: unID = unID + 1
					hotspot2  -opHalfX-customBeamOverlaps[i],	0, unID,  customBeamOverlaps[i], 2		: unID = unID + 1	
	
					hotspot2  opHalfX,	 						0, unID,  customBeamOverlaps[i], 1+128	: unID = unID + 1
					hotspot2  opHalfX-1,  						0, unID,  customBeamOverlaps[i], 3		: unID = unID + 1
					hotspot2  opHalfX+customBeamOverlaps[i],	0, unID,  customBeamOverlaps[i], 2		: unID = unID + 1	
				endif
	
!!				if iBeamFamilys[i] = BEAM_FAMILY_CUSTOM then
!!					hotspot2  linderCoords[i][LINDER_LENGTH]/2,	 0,  					unID,  customBeamHeights[i], 1+128	: unID = unID + 1
!!					hotspot2  linderCoords[i][LINDER_LENGTH]/2,  -1,  					unID,  customBeamHeights[i], 3		: unID = unID + 1
!!					hotspot2  linderCoords[i][LINDER_LENGTH]/2,  customBeamHeights[i],	unID,  customBeamHeights[i], 2		: unID = unID + 1	
!!	
!!					hotspot2  linderCoords[i][LINDER_LENGTH]/2,	 0,  					unID,  customBeamHeights[i], 1+128	: unID = unID + 1
!!					hotspot2  linderCoords[i][LINDER_LENGTH]/2,  -1,  					unID,  customBeamHeights[i], 3		: unID = unID + 1
!!					hotspot2  linderCoords[i][LINDER_LENGTH]/2,  customBeamHeights[i],	unID,  customBeamHeights[i], 2		: unID = unID + 1	
!!	
!!					hotspot2  linderCoords[i][LINDER_OPENING_SIZE]/2,	 					 0, unID,  customBeamOverlaps[i], 1+128	: unID = unID + 1
!!					hotspot2  linderCoords[i][LINDER_OPENING_SIZE]/2-1,  					 0, unID,  customBeamOverlaps[i], 3			: unID = unID + 1
!!					hotspot2  linderCoords[i][LINDER_OPENING_SIZE]/2+customBeamOverlaps[i],  0, unID,  customBeamOverlaps[i], 2			: unID = unID + 1	
!!	
!!					hotspot2  linderCoords[i][LINDER_OPENING_SIZE]/2,	 					 0, unID,  customBeamOverlaps[i], 1+128	: unID = unID + 1
!!					hotspot2  linderCoords[i][LINDER_OPENING_SIZE]/2-1,  					 0, unID,  customBeamOverlaps[i], 3			: unID = unID + 1
!!					hotspot2  linderCoords[i][LINDER_OPENING_SIZE]/2+customBeamOverlaps[i],  0, unID,  customBeamOverlaps[i], 2			: unID = unID + 1	
!!				endif
		
				del 1
			endif
		endif
	next i
return


! ------------------------------------------------------------------------------
"sideView":
! ------------------------------------------------------------------------------
	unID = 30100
	for i = 1 to nPolygonPoint-1
		hotspot2 contourPoints[i][1], contourPoints[i][2], unID	:	unID=unID+1
	next i
	for i = 1 to nPolygonPoint-1
		hotspot2 contourOutPoints[i][1], contourOutPoints[i][2], unID	:	unID=unID+1
	next i

	gosub "beamHotspots"

	unID = 30200
	for i = 1 to nOpeningPolygons
		for j = origOpeningStartEnd[i][1] to origOpeningStartEnd[i][2] - 1
			hotspot2 origOpeningPoligons[j][1], origOpeningPoligons[j][2], unID	:unID=unID+1
		next j
	next i

	
	for n = 1 to nMagPoint
		currentMag	= surfaceYmin + rowHeights[n][2]
		nSegment	= int(nEdgePoint[n]/2)
		for i = 1 to nSegment
			distance = edgeSection[n][(i-1)*4+3] - edgeSection[n][(i-1)*4+1]
	
			if distance > eps then			! Ha kicsi a távolság akkor nem számolunk
				hotline2 edgeSection[n][(i-1)*4+1], edgeSection[n][(i-1)*4+2], edgeSection[n][(i-1)*4+3], edgeSection[n][(i-1)*4+4]
			endif
		next i
	next n

	pen pen3D
	project2{3} 4, 270, 3+32+512, 1+2+4+8, gs_back_pen,
		parameters	iDetlevel3D		= DETLEVEL_3D_BLOCK,
					bProj2D			= 1,
					bShowEdit		= 0

	pen penGlue
	fill "ks_quadro_vertical_glue"
	for i = 1 to nVerticalGlue
		add2 verticalGlue[i][1], verticalGlue[i][2]
			poly2_b 5, 1+2, penGlue, gs_back_pen,
				-verticalGlue[i][3]/2,	0,	1,
				 verticalGlue[i][3]/2,	0,	1,
				 verticalGlue[i][3]/2,	verticalGlue[i][4],	1,
				-verticalGlue[i][3]/2,	verticalGlue[i][4],	1,
				-verticalGlue[i][3]/2,	0,	-1
		del 1
	next i

	pen gs_cont_pen
	fill gs_fill_type
return


! ------------------------------------------------------------------------------
"beamTypeSign":
! ------------------------------------------------------------------------------

	sA = signSize
	sB = signSize*0.4
	rr = signSize
	circRad	= 0.01

	for j = 1 to nBtype
		ang = -(j-1)*aBAnle + 90
		add2 cos(ang)*rr + sA/2*cos(ang), sin(ang)*rr + sB/2*sin(ang)
		call "ks_quadro_beamSign" parameters	A		= sA,
											B		= sB,
											iBeam	= iBManual[j],
											iPen	= gs_cont_pen,
											iDir	= surfaceDir
		del 1
	next j

	mul2 signSize/0.01, signSize/0.01

	circle2 0, 0, circRad
	line2    0, 0, circRad*sin(beamAngles[i]),  	circRad*cos(beamAngles[i])

	del  1
return

! ------------------------------------------------------------------------------
"cornerSign":
! ------------------------------------------------------------------------------
	sA		= signSize
	sB		= signSize
	rr		= signSize

	for j = 1 to nJointTypes
		ang = -(j-1)*dAng + 90
		add2 cos(ang)*rr + sA/2*cos(ang), sin(ang)*rr + sB/2*sin(ang)
		call "ks_quadro_conn_sign" parameters	A			= sA,
											B			= sB,
											iJointType	= jointTypes[j],
											iPen		= gs_cont_pen
		del 1
	next j

	circle2 0, 0, rr
	line2   0, 0, rr*sin(jUiAngle),  	rr*cos(jUiAngle)
return


! ==============================================================================
!
! Brick Drawer
!
! ==============================================================================
! ------------------------------------------------------------------------------
"polyOpOpen":
! ------------------------------------------------------------------------------
	ch = INITADDONSCOPE ("PolyOperations", "", "")

	nDestContainer		= 1
	prevSourceContainer	= "mySourceCont"
	lastDestContainer	= "myDestinationCont" + STR(nDestContainer,1,0)

	PREPAREFUNCTION ch, "CreateContainer", prevSourceContainer, ""
	PREPAREFUNCTION ch, "CreateContainer", lastDestContainer, ""

	PREPAREFUNCTION ch, "SetSourceContainer",		prevSourceContainer, ""
	PREPAREFUNCTION ch, "SetDestinationContainer",	lastDestContainer, ""
return

! ------------------------------------------------------------------------------
"polyOpClose":
! ------------------------------------------------------------------------------
	CLOSEADDONSCOPE ch
return

! ------------------------------------------------------------------------------
"polyOpCutters":
! ------------------------------------------------------------------------------
	!---- Cutters -----------
	dim vertArr[4][3]
	dim contArr[], cutterNames[]
	nVertices	= 4
	nContour	= 1
	contArr[1]	= 5
	for cc = 1 to nRowCutters[nSor]
		cutterNames[cc]		= "cutter_" + str(cc,1,0)

		vertArr[1][1] 		= brickCutters[cc][1]
		vertArr[1][2] 		= brickCutters[cc][2]
		vertArr[1][3] 		= 0.0

		vertArr[2][1] 		= brickCutters[cc][3]
		vertArr[2][2] 		= brickCutters[cc][4]
		vertArr[2][3] 		= 0.0

		vertArr[3][1] 		= brickCutters[cc][5]
		vertArr[3][2] 		= brickCutters[cc][6]
		vertArr[3][3] 		= 0.0

		vertArr[4][1] 		= brickCutters[cc][7]
		vertArr[4][2] 		= brickCutters[cc][8]
		vertArr[4][3] 		= 0.0

		PREPAREFUNCTION ch, "Store", cutterNames[cc], nVertices, nContour, vertArr, contArr
	next cc

	dim cutPolyArray[]
	nPgonCut = CALLFUNCTION (ch, "GetSourcePolygons", "", cutPolyArray)
return

! ------------------------------------------------------------------------------
"polyOpBrick":
! ------------------------------------------------------------------------------
	!---- Brick -----------
	dim contourNames[]
	contourNames[1]	= "brick_" + str(i, 1, 0)
	PREPAREFUNCTION ch, "Store", contourNames[1], nVertices, nContour, vertArr, contArr
	numContour		= 1

	!---- sCut -----------
	if bsCut then
		sCutname = "sCut_" + str(i, 1, 0)
		dim vertArr[4][3]
		dim contArr[]
	
		vertArr[1][1] 		= -cutOverSizeX
		vertArr[1][2] 		= cutOverSizeY
		vertArr[1][3] 		= 0.0
	
		vertArr[2][1] 		= -cutOverSizeX
		vertArr[2][2] 		= -cutOverSizeY
		vertArr[2][3] 		= 0.0
	
		if abs(sAngle-90) < eps then
			vertArr[3][1] 		= sCut
			vertArr[3][2] 		= -cutOverSizeY
			vertArr[3][3] 		= 0.0
	
			vertArr[4][1] 		= sCut
			vertArr[4][2] 		= cutOverSizeY
			vertArr[4][3] 		= 0.0
		else
			vertArr[3][1] 		= sCut-cutOverSizeY/tan(sAngle)
			vertArr[3][2] 		= -cutOverSizeY
			vertArr[3][3] 		= 0.0
	
			vertArr[4][1] 		= sCut+cutOverSizeY/tan(sAngle)
			vertArr[4][2] 		= cutOverSizeY
			vertArr[4][3] 		= 0.0
		endif

!!poly2 4, 1+4,
!!	vertArr[1][1], vertArr[1][2],
!!	vertArr[2][1], vertArr[2][2],
!!	vertArr[3][1], vertArr[3][2],
!!	vertArr[4][1], vertArr[4][2]
	
		nVertices	= 4
		nContour	= 1
		contArr[1]	= 5
	
		PREPAREFUNCTION ch, "Store", sCutname, nVertices, nContour, vertArr, contArr

		dim tempResPolyIDArr[]
		numContour		= CALLFUNCTION(ch, contourNames[1] + " - " + sCutname, "", tempResPolyIDArr)
		contourNames	= tempResPolyIDArr

		if prevSourceContainer <> "" then
			PREPAREFUNCTION ch, "DeleteContainer",		prevSourceContainer, ""
		endif
		PREPAREFUNCTION ch, "SetSourceContainer",		lastDestContainer, ""
		prevSourceContainer	= lastDestContainer
		nDestContainer = nDestContainer + 1
		lastDestContainer = "myDestinationCont" + STR(nDestContainer,1,0)
		PREPAREFUNCTION ch, "CreateContainer",			lastDestContainer, ""
		PREPAREFUNCTION ch, "SetDestinationContainer",	lastDestContainer, ""
	endif


	!---- EndtCut -----------
	if beCut then
		eCutname = "eCut_" + str(i, 1, 0)
		dim vertArr[4][3]
		dim contArr[]
	
		vertArr[1][1] 		= bWidth+cutOverSizeX
		vertArr[1][2] 		= cutOverSizeY
		vertArr[1][3] 		= 0.0
	
		vertArr[2][1] 		= bWidth+cutOverSizeX
		vertArr[2][2] 		= -cutOverSizeY
		vertArr[2][3] 		= 0.0
	
		if abs(eAngle-90) < eps then
			vertArr[3][1] 		= bWidth-eCut
			vertArr[3][2] 		= -cutOverSizeY
			vertArr[3][3] 		= 0.0
	
			vertArr[4][1] 		= bWidth-eCut
			vertArr[4][2] 		= cutOverSizeY
			vertArr[4][3] 		= 0.0
		else
			vertArr[3][1] 		= bWidth-eCut-cutOverSizeY/tan(eAngle)
			vertArr[3][2] 		= -cutOverSizeY
			vertArr[3][3] 		= 0.0
	
			vertArr[4][1] 		= bWidth-eCut+cutOverSizeY/tan(eAngle)
			vertArr[4][2] 		= cutOverSizeY
			vertArr[4][3] 		= 0.0
		endif

!!poly2 4, 1+4,
!!	vertArr[1][1], vertArr[1][2],
!!	vertArr[2][1], vertArr[2][2],
!!	vertArr[3][1], vertArr[3][2],
!!	vertArr[4][1], vertArr[4][2]
	
		nVertices	= 4
		nContour	= 1
		contArr[1]	= 5
	
		PREPAREFUNCTION ch, "Store", eCutname, nVertices, nContour, vertArr, contArr

		dim tempResPolyIDArr[]
		for nC = 1 to numContour
			tempNumPoly = CALLFUNCTION(ch, contourNames[nC] + " - " + eCutname, "", tempResPolyIDArr)
		next nC
		contourNames = tempResPolyIDArr

		if prevSourceContainer <> "" then
			PREPAREFUNCTION ch, "DeleteContainer",		prevSourceContainer, ""
		endif
		PREPAREFUNCTION ch, "SetSourceContainer",		lastDestContainer, ""
		prevSourceContainer	= lastDestContainer
		nDestContainer = nDestContainer + 1
		lastDestContainer = "myDestinationCont" + STR(nDestContainer,1,0)
		PREPAREFUNCTION ch, "CreateContainer",			lastDestContainer, ""
		PREPAREFUNCTION ch, "SetDestinationContainer",	lastDestContainer, ""
	endif

	for cc = 1 to nRowCutters[nSor]
		bFound = 0
		for j = 1 to nBrickCutter
			if brickCuttersType[j] = rowCutters[nSor][cc] then
				bFound	= j
				j		= nBrickCutter
			endif
		next j
		j = bFound

		if j > 0 then
			numContour = CALLFUNCTION (ch, "GetSourcePolygons", "", contourNames)
	
			dim vertArr[4][3]
			dim contArr[]
			nVertices	= 4
			nContour	= 1
			contArr[1]	= 5
			cutterName	= "cutter_" + "_" + str(i,1,0) + "_" + str(cc,1,0)

			if bMir then
				vertArr[1][1] 	= -(brickCutters[j][1] - sp)
				vertArr[1][2] 	= -brickCutters[j][2] + bThk
				vertArr[1][3] 	= 0.0
		
				vertArr[2][1] 	= -(brickCutters[j][3] - sp)
				vertArr[2][2] 	= -brickCutters[j][4] + bThk
				vertArr[2][3] 	= 0.0
		
				vertArr[3][1] 	= -(brickCutters[j][5] - sp)
				vertArr[3][2] 	= -brickCutters[j][6] + bThk
				vertArr[3][3] 	= 0.0
		
				vertArr[4][1] 	= -(brickCutters[j][7] - sp)
				vertArr[4][2] 	= -brickCutters[j][8] + bThk
				vertArr[4][3] 	= 0.0 
			else
				vertArr[1][1] 	= sp + brickCutters[j][1]
				vertArr[1][2] 	= brickCutters[j][2]
				vertArr[1][3] 	= 0.0
		
				vertArr[2][1] 	= sp + brickCutters[j][3]
				vertArr[2][2] 	= brickCutters[j][4]
				vertArr[2][3] 	= 0.0
		
				vertArr[3][1] 	= sp + brickCutters[j][5]
				vertArr[3][2] 	= brickCutters[j][6]
				vertArr[3][3] 	= 0.0
		
				vertArr[4][1] 	= sp + brickCutters[j][7]
				vertArr[4][2] 	= brickCutters[j][8]
				vertArr[4][3] 	= 0.0
			endif

!!poly2 4, 1+4,
!!	vertArr[1][1], vertArr[1][2],
!!	vertArr[2][1], vertArr[2][2],
!!	vertArr[3][1], vertArr[3][2],
!!	vertArr[4][1], vertArr[4][2]
	
			PREPAREFUNCTION ch, "Store", cutterName, nVertices, nContour, vertArr, contArr
	
			dim tempResPolyIDArr[]
			for nC = 1 to numContour
				tempNumPoly = CALLFUNCTION(ch, contourNames[nC] + " - " + cutterName, "", tempResPolyIDArr)
			next nC
			contourNames = tempResPolyIDArr
	
			if prevSourceContainer <> "" then
				PREPAREFUNCTION ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			PREPAREFUNCTION ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			nDestContainer = nDestContainer + 1
			lastDestContainer = "myDestinationCont" + STR(nDestContainer,1,0)
			PREPAREFUNCTION ch, "CreateContainer",			lastDestContainer, ""
			PREPAREFUNCTION ch, "SetDestinationContainer",	lastDestContainer, ""
		endif
	next cc

	if lastDestContainer <> "" then
		PREPAREFUNCTION ch, "DeleteContainer",		lastDestContainer, ""
	endif
	lastDestContainer = prevSourceContainer
	PREPAREFUNCTION ch, "SetDestinationContainer",	lastDestContainer, ""

	dim resPolyIDArr[]
	numPoly = CALLFUNCTION(ch, "GetDestinationPolygons", "", resPolyIDArr)
	for cP = 1 to numPoly
		polygonID	= resPolyIDArr[cP]
		mask		= 1
		gosub "getGDLpolygonFromAPI"
		if nsp > 8 then
			poly2_b nsp/3, 1+2, gs_fill_pen, gs_back_pen, get(nsp)
		else
			for k = 1 to nsp
				temp = get(1)
			next k
		endif
	next cP

	prevSourceContainer	= lastDestContainer
	nDestContainer = nDestContainer + 1
	lastDestContainer = "myDestinationCont" + STR(nDestContainer,1,0)
	PREPAREFUNCTION ch, "EmptyContainer",			prevSourceContainer, ""
	PREPAREFUNCTION ch, "CreateContainer",			lastDestContainer, ""
	PREPAREFUNCTION ch, "SetDestinationContainer",	lastDestContainer, ""
return

! ------------------------------------------------------------------------------
"polyToPolyopPoly":
! ------------------------------------------------------------------------------
	nContour = 0
	dim contArr[]

	! Save Quene
	nQuene = nsp/3
	dim quene[][3]
	quene[nQuene][3] = 0

	for ii = 1 to nQuene
		quene[ii][1] = get(1)
		quene[ii][2] = get(1)
		quene[ii][3] = get(1)
	next ii

	!Rearrange
	n = 0
	for ii = 1 to nQuene
		if quene[ii][3] < 0 then
			n					= n + 1
			nContour			= nContour + 1
			contArr[nContour]	= n
			put quene[ii][1], quene[ii][2], 0
		else
			!TODO itt lehet vizsgálni hogy jó e a zárás
			if quene[ii+1][3] > 800 & quene[ii+1][3] < 1000 then
				n = n + 1
				put quene[ii][1], quene[ii][2], quene[ii+2][2]
				ii = ii + 2		!TODO ez lehetne szebb is
			else
				n = n + 1
				put quene[ii][1], quene[ii][2], 0
			endif
		endif
	next ii

	!!print nsp/3, nContour, contArr
	!!if nContour > 1 then
	!!	print nContour, nsp/3, contArr
	!!	print use(nsp)
	!!endif

	!Put vertives
	nVertices	= nsp/3
	dim vertArr[][3]
	vertArr[nVertices][1] = 0
	for ii = 1 to nVertices
		vertArr[ii][1] = get(1)
		vertArr[ii][2] = get(1)
		vertArr[ii][3] = get(1)
	next ii
return

! ------------------------------------------------------------------------------
"brickDrawer2D":
! ------------------------------------------------------------------------------
	pType	= brickDef[i][3]
	pIdx	= brickDef[i][4]
	!if pIdx > 0 then
		bWidth			= datBrickSize[pIdx][BRICKSIZE_WIDTH]
		bThk			= datBrickSize[pIdx][BRICKSIZE_THK]
		bHeight			= datBrickSize[pIdx][BRICKSIZE_HEIGHT]
		bMir			= brickDef[i][2]
	
		cutOverSizeX	= 1
		cutOverSizeY	= 1
		sAngle			= 90.0
		eAngle			= 90.0
	
		if not(bMir) then
			sCut	= brickCut[i][1]
			eCut	= brickCut[i][2]
			bsCut	= (sCut > BIGEPS)
			beCut	= (eCut > BIGEPS)
			sp		= -brickCoord[i][1]
		else
			sCut	= brickCut[i][2]
			eCut	= brickCut[i][1]
			bsCut	= (sCut > BIGEPS)
			beCut	= (eCut > BIGEPS)
			sp		= brickCoord[i][1] + bWidth
		endif
	
		!----------- Hotspots -------------------
		if bMir then
			rot2 180
			add2 -bWidth, -bThk
		endif
		hotspot2 sCut,						0,		unID		: unID = unID + 1
		hotspot2 bWidth-eCut,				0,		unID		: unID = unID + 1
		hotspot2 bWidth-eCut,				bThk,	unID		: unID = unID + 1
		hotspot2 sCut,						bThk,	unID		: unID = unID + 1
		hotspot2 sCut+(bWidth-sCut-eCut)/2,	bThk/2,	unID		: unID = unID + 1
	
	
		!----------Stack---------------------------------
		bCustom = (datBrickFamily[pIdx] = BRICK_FAMILY_NONE)		!Ezek a custom elemek
		if bCustom then
			gosub pType
		else
			gosub "boxPut"
		endif
		gosub "polyToPolyopPoly"
		gosub "polyOpBrick"
	
		del 2*bMir
	!endif
return

! ==============================================================================
!
! Brick Subrutines
!
! ==============================================================================
10900:		! BRICK_DE_PP_CORNER_2_40_010_240
10901:		! BRICK_DE_PP_CORNER_2_40_010_300
10902:		! BRICK_DE_PP_CORNER_2_40_010_365
10903:		! BRICK_DE_PP_CORNER_2_40_010_400
10904:		! BRICK_DE_PP_CORNER_2_40_010_425
10905:		! BRICK_DE_PP_CORNER_2_40_010_480
109001:		! FR_CORNER_150
109002:		! FR_CORNER_200
109003:		! FR_CORNER_225
109004:		! FR_CORNER_250
109005:		! FR_CORNER_300
109006:		! FR_CORNER_365
109007:		! FR_CORNER_420
119001:		! ES_CORNER_625_200_500
119002:		! ES_CORNER_625_250_500
119003:		! ES_CORNER_625_300_500
119004:		! ES_CORNER_625_150_250
119005:		! ES_CORNER_625_200_250
119006:		! ES_CORNER_625_250_250
119007:		! ES_CORNER_625_300_250
119008:		! ES_CORNER_625_365_250
139001:		! BRICK_IT_CORNER_200
139002:		! BRICK_IT_CORNER_240
139003:		! BRICK_IT_CORNER_300
139004:		! BRICK_IT_CORNER_360
139005:		! BRICK_IT_CORNER_400
149001:		! XK_CORNER_250
149002:		! XK_CORNER_300
149003:		! XK_CORNER_375
159001:		! SI_CORNER_PZB_1
159002:		! SI_CORNER_PZB_2
159003:		! SI_CORNER_PZB_3
159004:		! SI_CORNER_PZB_4
159005:		! SI_CORNER_PZB_9
159006:		! SI_CORNER_PZB_10
159007:		! SI_CORNER_PZB_8
169001:		! BA_CORNER_PB_25
169002:		! BA_CORNER_PB_25_STAR
169003:		! BA_CORNER_PB_25_20
169004:		! BA_CORNER_PB_25_20_STAR
169005:		! BA_CORNER_PB_30
169006:		! BA_CORNER_PB_30_STAR
169007:		! BA_CORNER_PB_40
169008:		! BA_CORNER_PB_40_STAR
170901:		! HR_ZIDNI_CORNER_300
170902:		! HR_ZIDNI_CORNER_400
189001:		! RS_CORNER_250
189002:		! RS_CORNER_300
189003:		! RS_CORNER_375
189004:		! RS_CORNER_PLUS_300
189005:		! RS_CORNER_PLUS_375
199001:		! HU_P2_50_CORNER_300
199002:		! HU_P2_50_CORNER_375
199003:		! HU_P4_60_CORNER_300
199004:		! HU_P4_60_CORNER_375
209001:		! BG_CORNER_EXTRA_PLUS_600_250_250
209002:		! BG_CORNER_EXTRA_PLUS_600_300_250
209003:		! BG_CORNER_EXTRA_PLUS_600_350_250
209004:		! BG_CORNER_A_PLUS_600_250_250
209005:		! BG_CORNER_A_PLUS_600_300_250
209006:		! BG_CORNER_A_PLUS_600_350_250
209007:		! BG_CORNER_B50_D600_600_250_250
209008:		! BG_CORNER_B50_D600_600_300_250
209009:		! BG_CORNER_B50_D600_600_350_250
219001:		! RO_CORNER_200
219002:		! RO_CORNER_250
219003:		! RO_CORNER_300
219004:		! RO_CORNER_350
219005:		! RO_CORNER_400
239001:		! SK_CORNER_300
249001:		! CZ_CORNER_300

	r = 0.1
	!!if pType = P_PP_CORNER_2_40_010_240 then r = 0.075
	!!if pType = BRICK_IT_CORNER_200		then r = 0.05
	!!if pType = BRICK_IT_CORNER_240		then r = 0.075
	if bThk < 0.2+EPS then r = 0.05
	if bThk < 0.25+EPS then r = 0.075

	put 0, 0, 1,
		bWidth, 0, 1,
		bWidth, bThk, 1,
		0, bThk, 1,
		0, 0, -1,

		bThk/2, bThk/2-r, 1,
		bThk/2, bThk/2, 901,
		0, 180, 4001,
		bThk/2, bThk/2+r, 1,
		bThk/2, bThk/2, 901,
		0, 180, 4001,
		bThk/2, bThk/2-r, -1

	hotspot2 sp+bThk/2, bThk/2, unID : unID=unID+1
return

31001:		! CH_ANSCHLAG_600_300_250
31002:		! CH_ANSCHLAG_600_365_250
31003:		! CH_ANSCHLAG_600_400_250
31004:		! CH_ANSCHLAG_600_480_250
31005:		! CH_ANSCHLAG_600_500_250
	
	if bMir then
		put -0.08, bThk, 1,
			-0.08, bThk-0.2, 1,
			0, bThk-0.2, 1,
			0, 0, 1,
			bWidth, 0, 1,
			bWidth, 0.2, 1,
			bWidth-0.08, 0.2, 1,
			bWidth-0.08, bThk, 1,
			-0.08, bThk, -1

		hotspot2 -0.08, bThk,		unID : unID=unID+1
		hotspot2 -0.08, bThk-0.2,	unID : unID=unID+1
		hotspot2  0,	bThk-0.2,	unID : unID=unID+1
	else
		put -0.08, 0, 1,
			-0.08, 0.2, 1,
			0, 0.2, 1,
			0, bThk, 1,
			bWidth, bThk, 1,
			bWidth, bThk-0.2, 1,
			bWidth-0.08, bThk-0.2, 1,
			bWidth-0.08, 0, 1,
			-0.08, 0, -1

		hotspot2 -0.08, 0,		unID : unID=unID+1
		hotspot2 -0.08, 0.2,	unID : unID=unID+1
		hotspot2  0,	0.2,	unID : unID=unID+1
	endif
return


"boxPut":
	put 0, 0, 1,
		bWidth, 0, 1,
		bWidth, bThk, 1,
		0, bThk, 1,
		0, 0, -1
return


]]>
</Script_2D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_1D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! ------------------------------------------------------------------------------
! AC version
! ------------------------------------------------------------------------------
gdlVersion = req("GDL_version")
!!ArchiCAD 13.0: 1.604
!!ArchiCAD 14.0: 1.605
!!ArchiCAD 15.0: 1.650
!!ArchiCAD 16.0: 1.702
!!ArchiCAD 17.0: 1.752
!!ArchiCAD 18.0: 1.804
!!ArchiCAD 19.0: 1.912
ACVERSION = 0
if gdlVersion > 1.604-0.001 then ACVERSION = 13
if gdlVersion > 1.605-0.001 then ACVERSION = 14
if gdlVersion > 1.650-0.001 then ACVERSION = 15
if gdlVersion > 1.700		then ACVERSION = 16
if gdlVersion > 1.750		then ACVERSION = 17
if gdlVersion > 1.800		then ACVERSION = 18
if gdlVersion > 1.900		then ACVERSION = 19


! ------------------------------------------------------------------------------
! Variables
! ------------------------------------------------------------------------------
EPS					= 0.0001
EPSZILON			= 0.0015	!Ajtó ablak 2D
BIGEPS				= 0.001
BIGEPSBRICK			= 0.005
BIGEPSCM			= 0.01
BIGEPSEPS			= BIGEPS + EPS
HALFEPS				= 0.07+BIGEPS
BEAM_UNIEPS			= 0.01/2
bDefaultElem 		= (GLOB_INTGUID = "" OR GLOB_INTGUID = "{00000000-0000-0000-0000-000000000000}")
cutOffset 			= 10	! 10m ez elég leszz
cutOverSize			= 0.1
athSpace			= 5*eps
mmMultiplier		= 1000


! ------------------------------------------------------------------------------
! Brick Variables
! ------------------------------------------------------------------------------
bKiosztasFelulrol		= 0		!Felülröl osz (már nem kell javult annyit az algoritmus)
bAlsoSorAlattiOsztas	= 1		!Az alsó sor alá még kalkulál egy osztást hátha jobb az eredmény

! ------------------------------------------------------------------------------
! Debug Variables
! ------------------------------------------------------------------------------
bCut 					= 1			! Vágunk e (csak debug miatt)
bPrintError				= 0			! Mokás hibaüzeneteket dob fel
bFugaDebug				= 0			! A roszz fugákra köröket rajzol
bFugaSectionDebug 		= 0			! Kirajzolva a felette lévő sor sectionjait
bBrickDebug				= 0			! A vágot téglákat beátlózza
bBrickRevealDebug		= 0			! A lerakott reveal téglák pozicióját mutatja
teglaVisszaSzedLimit	= 5			! Ez határozza meg mennyi a maximális téglavisszaszedés limitje

! ------------------------------------------------------------------------------
! UI buttons
! ------------------------------------------------------------------------------
BUTTON_UI_T_START 	= 1500
BUTTON_UI_T_UP		= BUTTON_UI_T_START + 1
BUTTON_UI_T_DOWN	= BUTTON_UI_T_START + 2
BUTTON_UI_T_END		= BUTTON_UI_T_START + 3
BUTTON_UI_C_START 	= 1600
BUTTON_UI_C_UP		= BUTTON_UI_C_START + 1
BUTTON_UI_C_DOWN	= BUTTON_UI_C_START + 2
BUTTON_UI_C_END		= BUTTON_UI_C_START + 3
BUTTON_UI_T_SELECT	= 2000
BUTTON_UI_T_PLUS	= 3000
BUTTON_UI_T_MINUS	= 4000
BUTTON_UI_C_SELECT	= 7000
BUTTON_UI_C_PLUS	= 8000
BUTTON_UI_C_MINUS	= 9000

! ==============================================================================
! Definitions
! ==============================================================================
!iLang
	LANG_NONE	= 0
	LANG_DE		= 1
	LANG_AT		= 2
	LANG_CH		= 3
	LANG_FI		= 4
	LANG_SE		= 5
	LANG_NO		= 6
	LANG_DK		= 7
	LANG_NL		= 8
	LANG_BE		= 9
	LANG_FR		= 10
	LANG_ES		= 11
	LANG_UK		= 12
	LANG_IT		= 13
	LANG_XK		= 14
	LANG_SI		= 15
	LANG_BA		= 16
	LANG_HR		= 17
	LANG_RS		= 18
	LANG_HU		= 19
	LANG_BG		= 20
	LANG_RO		= 21
	LANG_PL		= 22
	LANG_SK		= 23
	LANG_CZ		= 24
	LANG_RU		= 25
	LANG_US		= 26
	LANG_CN		= 27
	LANG_MX		= 28
	LANG_TR		= 29

!iDetlevel3D:
	DETLEVEL_3D_NONE		= 0
	DETLEVEL_3D_SIMPLE		= 1
	DETLEVEL_3D_DETAILED	= 2
	DETLEVEL_3D_BLOCK		= 3
	DETLEVEL_3D_WIRE		= 4

!iDetlevel2D:
	DETLEVEL_2D_BLOCK		= 1
	DETLEVEL_2D_SIMPLE		= 2
	DETLEVEL_2D_DETAILED	= 3

!AC_symb_display_option
	DISPLAY_PROJECTED			= 1
	DISPLAY_OVERHEAD_PROJ		= 2
	DISPLAY_SYMBOLIC			= 3
	DISPLAY_OUTLINES			= 4
	DISPLAY_OVERHEAD_ALL		= 5

!AC_symb_show_projection_to
	PROJECTION_FLOOR_PLAN_RANGE	= 1
	PROJECTION_DISPLAY_LIMIT	= 2
	PROJECTION_ENTIRE_ELEMENT	= 3

!iBorderModes							Oldalak kialakítása
	BORDER_TOP_HOR			= 1			! Felso vízszintes él
	BORDER_TOP_SLANT		= 2			! Felso ferde él
	BORDER_BOT_HOR			= 3			! Alsó vízszintes él
	BORDER_BOT_SLANT		= 4			! Alsó ferde él
	BORDER_VERT_UP			= 5			! Függöleges él felfelé
	BORDER_VERT_DOWN		= 6			! Függöleges él lefelé

	BORDERDOOR_VERT			= 10
	BORDERDOOR_HOR			= 11
	BORDERDOOR_SLANT		= 12

! iPolyForm
	POLY_FORM_UNKNOWN		= 0
	POLY_FORM_RECT			= 1
	POLY_FORM_POLYGON_RECT	= 2
	POLY_FORM_POLYGON_SLANT	= 3

!borderStatus
	STATUS_NONE			= 1
	STATUS_CSORBA_1		= 2
	STATUS_CSORBA_2		= 3
	STATUS_PROFIL		= 4
	STATUS_VEG			= 5
	STATUS_DOOR			= 6
	STATUS_TWALL		= 7
	STATUS_LINDER		= 8
	STATUS_UNDER_LINDER	= 9
	STATUS_ABOVE_LINDER	= 10
	STATUS_WINBOTTOM	= 11

!iJointType
	JOINT_SIDE_AUTO			= -1
	JOINT_SIDE_NONE			= 0
	JOINT_SIDE_PROFILE		= 1
	JOINT_SIDE_END			= 2
	JOINT_SIDE_CORNER_1		= 3
	JOINT_SIDE_CORNER_2		= 4
	JOINT_SIDE_CORNER_T_1	= 5
	JOINT_SIDE_CORNER_T_2	= 6

! iBrickType
	BRICK_FAMILY_TYPE_BLOCK		= 10
	BRICK_FAMILY_TYPE_ELEMENT	= 20

! iFamily
	BRICK_FAMILY_NONE				= 0
	BRICK_DE_KSQ_12_18_DM			= 10000
	BRICK_DE_KSQ_16_18_DM			= 10100
	BRICK_DE_KSQ_20_18_DM			= 10200
	BRICK_DE_KSQ_20_20_DM			= 10300
	BRICK_DE_KSQ_20_22_DM			= 10400
	BRICK_DE_KSQE_12_18_DM			= 10500
	BRICK_DE_KSQE_20_18_DM			= 10600
	BRICK_DE_KSQE_12_20_DM			= 10700
	BRICK_DE_KSQE_20_20_DM			= 10800

! iProductType
	BRICK_NONE = 0

!Linder Arrays
	LINDER_FAMILY_NAME	= 1
	LINDER_FAMILY_IDX	= 2
	LINDER_NAME			= 3
	LINDER_IDX			= 4
	LINDER_TYPE			= 5
	LINDER_MULTI_IDX	= 6
	LINDER_OVERLAPPED	= 7
	LINDER_OVERSIZED	= 8
	LINDER_POSERROR		= 9

	LINDER_CENTER_X		= 1
	LINDER_CENTER_Y		= 2
	LINDER_LENGTH		= 3
	LINDER_HEIGHT		= 4
	LINDER_OPENING_SIZE	= 5
	LINDER_OVERHANG		= 6

! iBeamType
	BEAM_TYP_NONE		= 0
	BEAM_TYP_CUSTOM		= 1
	BEAM_TYP_NORMAL		= 2
	BEAM_TYP_RANGE		= 3
	BEAM_TYP_BLOCK		= 4

! iBeamFamily
	BEAM_FAMILY_AUTO				= 1
	BEAM_FAMILY_NONE				= 2
	BEAM_FAMILY_CUSTOM				= 3

defaultBeamFam = BEAM_FAMILY_NONE

	BEAM_FAMILY_MAX   = vardim1(datProdBeamIdx)    !Ez az utolsó áthidaló típus

! iBeamProductType
	! BEAM_FAMILY_NONE
	BEAM_NONE		= 0
	BEAM_CUSTOM		= 1

! iWallType
	WALLTYPE_NONE			= 0
	WALLTYPE_INTERNAL_WALL	= 1
	WALLTYPE_EXTERNAL_WALL	= 2
	WALLTYPE_INSULATED_WALL	= 3

! iHasEndElem
	HAS_END_ELEM_NONE		= 0
	HAS_END_ELEM_NORMAL		= 1
	HAS_END_ELEM_SPECIAL	= 2

! Column element
	COLUMN_NONE				= 0
	COLUMN_EMPTY			= 1
	COLUMN_CONCRETE			= 2
	COLUMN_CONCRETE_OFFSET	= 3

!iFuga
	FUGA_NONE		= 0
	FUGA_BRICK		= 1
	FUGA_SECTION	= 2

!iRowLength
	ROWLENGTH_SMALL		= 1
	ROWLENGTH_MEDIUM	= 2
	ROWLENGTH_NORMAL	= 3
	ROWLENGTH_LARGE		= 4

!iConnDir
	CONN_REF_SIDE		= 0
	CONN_OTHER_SIDE		= 1

! iRowType
	ROWTYPE_UNKNOWN		= 0
	ROWTYPE_NORMAL		= 1
	ROWTYPE_HALF		= 2
	ROWTYPE_CUTTED		= 3

! iBrickSubType
	TYPE_NORMAL		= 0
	TYPE_END		= 1
	TYPE_LOW		= 2
	TYPE_LOW_END	= 3
	TYPE_FINE		= 4
	TYPE_FINE_END	= 5
	TYPE_BEAM		= 6
	TYPE_COLUMN		= 7
	TYPE_WINDOW		= 8

! iSize
	BRICKSIZE_THK		= 1
	BRICKSIZE_HEIGHT	= 2
	BRICKSIZE_WIDTH		= 3

!iSpecialData
	SPEC_LENGTHTYPE		= 1
	SPEC_TYPE			= 2
	SPEC_MIRROR			= 3
	SPEC_FIXPOINT		= 1
	SPEC_LENGTH			= 2
	SPEC_MINLENGTH		= 3
	SPEC_MAXLENGTH		= 4
	SPEC_MINPOS			= 5
	SPEC_MAXPOS			= 6

! iAngle
	ANGLE_UNKNOWN		= 0
	ANGLE_LINE			= 1	! Egyenes
	ANGLE_PERPENDICULAR	= 2	! Merőleges
	ANGLE_ACUTE			= 3	! Hegyes szög
	ANGLE_OBTUSE		= 4	! Tompa szög

! Special brick length type
	BRICK_LENGTH_FIX	= 1     !Fix Length brick
	BRICK_LENGTH_VAR	= 2     !Brick length min, max
	BRICK_LENGTH_POS	= 3     !Brick length position depend
	BRICK_LENGTH_CHOICE	= 4		!

! Brick cutters
	BR_CUT_NONE				= 0
	BR_CUT_CORNER_LEFT_1	= 1
	BR_CUT_CORNER_LEFT_2	= 2
	BR_CUT_CORNER_RIGHT_1	= 3
	BR_CUT_CORNER_RIGHT_2	= 4

! iVerticalGlue
    BEAM_GLUE_VERTICAL_NONE        = 0
    BEAM_GLUE_VERTICAL_CUTTED_ROW  = 1
    BEAM_GLUE_VERTICAL_ONE_METER   = 2

! ------------------------------------------------------------------------------
! Localization
! ------------------------------------------------------------------------------
dim stDetlevel3D[5]
	stDetlevel3D[1] = `None`
	stDetlevel3D[2] = `Simple`
	stDetlevel3D[3] = `Detailed`
	stDetlevel3D[4] = `Block`
	stDetlevel3D[5] = `Wireframe`

dim stDetlevel2D[3]
	stDetlevel2D[1] = `Block`
	stDetlevel2D[2] = `Simple`
	stDetlevel2D[3] = `Detailed`

!dim stDisplayOptions[5]
!	stDisplayOptions[1]		= `Projected`
!	stDisplayOptions[2]		= `Projected with Overhead`
!	stDisplayOptions[3]		= `Symbolic View`
!	stDisplayOptions[4]		= `Outlines Only`
!	stDisplayOptions[5]		= `Overhead All`
!
!dim stProjectionTypes[3]
!	stProjectionTypes[1]	= `to Floor Plan Range`
!	stProjectionTypes[2]	= `Absolute Display Limit`
!	stProjectionTypes[3]	= `Entire Element`

stAddOnErrorLength	= `Accessory Add-On parameter transfer bug.\nBug in 2D & List data calculation!\nTry to generate the surface from more,\nseparated polygon!`
stBrickError		= `Block error, please send file for BimObject mail: info@bimobject.com`
stOversized			= `Error: The opening exceeds the maximum length, please use other beams`
stCollision			= `Error: Beams are overlap, please check beams positions`
stPosIncorrect		= `Warning:\nThis position is incorrect.\nPlease contact with\nthe manufacturer support!`
stCurvedWall		= `Error: Curved wall is not supported!`
stOpeningForm		= `Warning: Polygon shape opening is not supported!`
stCornerWindow		= `Warning: Corner opening is not supported!`

! ------------------------------------------------------------------------------
! Migration
! ------------------------------------------------------------------------------
nLastVersion	= vardim1(nVersionNumber)
nLocalVersion	= vardim1(iVersionNumber)

if iVersionNumber[nLocalVersion][1] < nVersionNumber[nLastVersion][1] then
	bModifiedByAPI = 1
endif

if iDetlevel2D < 1 then
	iDetlevel2D = DETLEVEL_2D_BLOCK
	parameters iDetlevel2D = iDetlevel2D
endif

dim iVersionNumber[][2]
iVersionNumber = nVersionNumber

if bUpdateDatas then
	call "ks_quadro_wall_database_m" parameters all
	parameters bUpdateDatas	= 0
endif


! ==============================================================================
!
! Reset
!
! ==============================================================================
nConnTParam		= vardim1(tConnWallDir)
nColumnParam	= vardim1(colPosX)
if bDefaultElem then bModifiedByAPI = 1
bResetGeom = 1
if bModifiedByAPI then
	bResetGeom = 1
else
	if	GLOB_MODPAR_NAME = "bUseTopContour"		|\
		GLOB_MODPAR_NAME = "bUseBottomContour"	|\
		!Csatlakozások
		GLOB_MODPAR_NAME = "iJointType1"		|\
		GLOB_MODPAR_NAME = "bJointAngle1"		|\
		GLOB_MODPAR_NAME = "jointAngle1"		|\
		GLOB_MODPAR_NAME = "jUiAngle1"			|\
		GLOB_MODPAR_NAME = "bCustomCsorba1"		|\
		GLOB_MODPAR_NAME = "csorbaW1"			|\
		GLOB_MODPAR_NAME = "iJointType2"		|\
		GLOB_MODPAR_NAME = "bJointAngle2"		|\
		GLOB_MODPAR_NAME = "jointAngle2"		|\
		GLOB_MODPAR_NAME = "jUiAngle2"			|\
		GLOB_MODPAR_NAME = "bCustomCsorba2"		|\
		GLOB_MODPAR_NAME = "csorbaW2"			|\
		!Family
		GLOB_MODPAR_NAME = "iLang"				|\
		GLOB_MODPAR_NAME = "iFamily"			|\
		GLOB_MODPAR_NAME = "iThickness"			|\
		GLOB_MODPAR_NAME = "iProductType"		\
	then
		bResetGeom = 1
	endif
endif
gosub "geometryChecksum"
if ACVERSION < 19 then
	if GLOB_CONTEXT = 1 then bResetGeom = 1
endif
bCurvedWall = 0
if abs(ac_wall_radius) > EPS then
	bCurvedWall	= 1
	bResetGeom	= 0
endif

bResetBrick	= 1
if bResetGeom then
	bResetBrick = 1
else
	if	GLOB_MODPAR_NAME = "brickDir"			|\
		GLOB_MODPAR_NAME = "startRow"			|\
		GLOB_MODPAR_NAME = "bHalfStone"			|\
		GLOB_MODPAR_NAME = "baseMortarThk"		|\
		GLOB_MODPAR_NAME = "mortarThk"			|\
		GLOB_MODPAR_NAME = "iStartBrickHeight"	|\
		GLOB_MODPAR_NAME = "bTopWallConnection"	|\
		GLOB_MODPAR_NAME = "bBotWallConnection"	|\
		GLOB_MODPAR_NAME = "iWindowBrick"		|\

		!T-connections
		GLOB_MODPAR_NAME = "tConnections"		|\
		GLOB_MODPAR_NAME = "tConnWallDir"		|\
		GLOB_MODPAR_NAME = "tConnWallPos"		|\
		GLOB_MODPAR_NAME = "tConnWallThk"		|\
		GLOB_MODPAR_NAME = "tConnWallHmin"		|\
		GLOB_MODPAR_NAME = "tConnWallHmax"		|\
		GLOB_MODPAR_NAME = "tConnWallAngle"		|\

		!Beams
		iPrevBeamFamily <> iBeamFamily 			|\
		GLOB_MODPAR_NAME = "iBeamFamily"		|\
		GLOB_MODPAR_NAME = "beamAngles"			|\
		GLOB_MODPAR_NAME = "iBeamFamilys"		|\
		GLOB_MODPAR_NAME = "customBeamOverlaps"	|\
		GLOB_MODPAR_NAME = "customBeamHeights"	|\

		!Colums
		GLOB_MODPAR_NAME = "bColPos"			|\
		GLOB_MODPAR_NAME = "colPosX"			|\

!!		!Family
!!		GLOB_MODPAR_NAME = "iLang"				|\
!!		GLOB_MODPAR_NAME = "iFamily"			|\
!!		GLOB_MODPAR_NAME = "iThickness"			|\
!!		GLOB_MODPAR_NAME = "iProductType"		|\

		GLOB_UI_BUTTON_ID = BUTTON_UI_T_PLUS	|\
		GLOB_UI_BUTTON_ID = BUTTON_UI_C_PLUS	\
	then
		bResetBrick = 1
	endif
	for i = 1 to nConnTParam
		if GLOB_UI_BUTTON_ID = BUTTON_UI_T_MINUS + i then
			bResetBrick = 1
		endif
		if GLOB_UI_BUTTON_ID = BUTTON_UI_C_MINUS + i then
			bResetBrick = 1
		endif
	next i
endif



! ==============================================================================
!
! Brick Datas
!
! ==============================================================================
!-------- Family Values ------------
nFamilys			= vardim1(datProdIdx)
nAvailableFamilys	= 0
bValidFamily		= 0
dim avaFamilys[], avaFamilysIdxs[]
for i = 1 to nFamilys
	if datProdLang[i] = iLang then
		nAvailableFamilys					= nAvailableFamilys + 1
		avaFamilysIdxs[nAvailableFamilys]	= i
		avaFamilys[nAvailableFamilys]		= datProdIdx[i]
	endif
next i
if nAvailableFamilys > 0 then
	bValidFamily = 1
else
	goto "endMasterSript"
endif

!-------- Family Index ------------
idxFamily = 0
for i = 1 to nAvailableFamilys
	if iFamily = avaFamilys[i] then
		idxFamily = avaFamilysIdxs[i]
	endif
next i
if idxFamily = 0 then		!Nem találtunk familyt (ekkor átdobjuk az elsőre)
	idxFamily	= avaFamilysIdxs[1]
	iFamily		= avaFamilys[1]
	parameters iFamily = iFamily
endif

startRow	= startRow * not(datProdDisableFlipRow[idxFamily])
brickDir	= brickDir * not(datProdDisableBrickDir[idxFamily])


!--------- Fill All Product Types -------------
nProductsAll		= vardim1(datBrickIdx)
nAvaSpecialElemsAll	= 0
nAvaProductTypesAll	= 0
dim avaProductTypesAll[], avaProductTypesAllIdxs[]
dim avaSpecialElemsAll[], avaSpecialElemsAllIdxs[]
for i = 1 to nProductsAll
	if datBrickLang[i] = iLang then
		if datBrickFamily[i] = BRICK_FAMILY_NONE then
			nAvaSpecialElemsAll							= nAvaSpecialElemsAll + 1
			avaSpecialElemsAllIdxs[nAvaSpecialElemsAll]	= i
			avaSpecialElemsAll[nAvaSpecialElemsAll]		= datBrickIdx[i]
		else
			if datBrickFamily[i] = iFamily then
				nAvaProductTypesAll							= nAvaProductTypesAll + 1
				avaProductTypesAllIdxs[nAvaProductTypesAll]	= i
				avaProductTypesAll[nAvaProductTypesAll]		= datBrickIdx[i]
			endif
		endif
	endif
next i


!-------- Fill Thickness ------------
dim brickThicknesses[]
n = 0
for i = 1 to nAvaProductTypesAll
	idx	= avaProductTypesAllIdxs[i]
	thk = datBrickSize[idx][BRICKSIZE_THK]
	if thk > EPS then
		bFoundThk = 0
		for j = 1 to vardim1(brickThicknesses)
			if abs(thk - brickThicknesses[j]) < EPS then
				bFoundThk	= 1
				j			= vardim1(brickThicknesses)
			endif
		next j
	
		if not(bFoundThk)then
			n					= n + 1
			brickThicknesses[n] = thk
		endif
	endif
next i
dim unsortedCoords1[]
unsortedCoords1 = brickThicknesses
gosub "insertionSort1"
brickThicknesses = unsortedCoords1
iThickness = max(min(iThickness, vardim1(brickThicknesses)), 1)


!-------- Fill Product Types ------------
dim avaProductTypes[], avaProductTypesIdxs[]
nAvaProductTypes = 0
for i = 1 to nAvaProductTypesAll
	idx	= avaProductTypesAllIdxs[i]
	thk = datBrickSize[idx][BRICKSIZE_THK]
	if thk > EPS then
		if abs(thk - brickThicknesses[iThickness]) < EPS then
			nAvaProductTypes						= nAvaProductTypes + 1
			avaProductTypesIdxs[nAvaProductTypes]	= idx
			avaProductTypes[nAvaProductTypes]		= datBrickIdx[idx]
		endif
	endif
next i

!-------------- Get Product Type Idx --------------------
idxProduct = 0
for i = 1 to nAvaProductTypes
	if iProductType = avaProductTypes[i] then
		idxProduct = avaProductTypesIdxs[i]
	endif
next i
if idxProduct = 0 then
	idxProduct		= avaProductTypesIdxs[1]
	iProductType	= avaProductTypes[1]
	parameters iProductType = iProductType
endif

!-------- Grout ------------
groutVertical			= 0.001
groutHorizontal			= mortarThk
groutBase				= baseMortarThk
if bBotWallConnection then
	groutBase			= mortarThk
endif
groutOffset				= 0.001	! ennyivel van beljebb a habarcs


!-------- Brick Sizes ------------
brickThk				= datBrickSize[idxProduct][BRICKSIZE_THK]
brickHeight				= datBrickSize[idxProduct][BRICKSIZE_HEIGHT]
brickWidth				= datBrickSize[idxProduct][BRICKSIZE_WIDTH]
minBrickSize			= datProdMinbrickSize[idxFamily]
minBrickOverlap			= datProdMinBrickOverlap[idxFamily]
rowHeight				= brickHeight + groutHorizontal
brickWidthGrout			= brickWidth + groutVertical

!-------- Brick Datas --------------
dim brickCerts[]
brickName				= datBrickName[idxProduct]
brickCert				= datBrickCert[idxProduct]
brickEan				= datBrickEan[idxProduct]
brickCustomName			= datBrickCustomName[idxProduct]
brickNutProf			= datBrickNutProf[idxProduct]
brickLambdaDry			= datBrickLambdaDry[idxProduct]
brickLambdaNormal		= datBrickLambdaNormal[idxProduct]
brickNperMm2			= datBrickNperMm2[idxProduct]
brickKgPerM3			= datBrickKgPerM3[idxProduct]
brickKgPerPc			= datBrickKgPerPc[idxProduct]
brickPcPerM2			= datBrickPcPerM2[idxProduct]
brickM2PerPc			= datBrickM2PerPc[idxProduct]
brickGrossDensity		= datBrickGrossDensity[idxProduct]
brickShearStrength		= datBrickShearStrength[idxProduct]
brickFk					= datBrickFk[idxProduct]
brickKNperm3			= datBrickKNperm3[idxProduct]
brickMortarPerM2		= datBrickMortarPerM2[idxProduct]
brickMortarPerM2str		= datBrickMortarPerM2Str[idxProduct]
brickWorkHperStructure	= datBrickWorkHperStructure[idxProduct]
brickWorkHperFull		= datBrickWorkHperFull[idxProduct]
brickFireResistance		= datBrickFireResistance[idxProduct]
brickAcustic			= datBrickAcustic[idxProduct]
brickUvalue				= datBrickUvalue[idxProduct]
minBrickHeight			= 0.01

!-------- Brick Types ------------
iWallType				= datBrickWallType[idxProduct]
iHasEndElem				= datBrickHasEndElem[idxProduct]
elemEnd					= datBrickEndElemIdx[idxProduct]
elemHalf				= datBrickHalfIdx[idxProduct]
elemHalfEnd				= 0		! TODO
elemWindow				= datBrickWindowIdx[idxProduct]
elemColumn				= datBrickColumn[idxProduct]
bHasProfile				= datBrickHasProfile[idxProduct]
halfElemHeight			= datBrickHalfElemHeight[idxProduct]
endElemWidth			= datBrickEndElemWith[idxProduct]

findIdx			= elemEnd
gosub "findSpecElemIdx"
elemEndIdx		= resIdx

findIdx			= elemHalf
gosub "findSpecElemIdx"
elemHalfIdx		= resIdx

findIdx			= elemHalfEnd
gosub "findSpecElemIdx"
elemHalfEndIdx	= resIdx

findIdx			= elemWindow
gosub "findSpecElemIdx"
elemWindowIdx	= resIdx

findIdx			= elemColumn
gosub "findSpecElemIdx"
elemColumnIdx	= resIdx


!-------- Brick Misc ----------------
brickNutSize			= 0.0		! TODO
topSpace				= 0.01	! A fal felső része ahová nem téglázunk
if bTopWallConnection then
	topSpace			= 0.0
endif
minCsorbaWidth			= minBrickOverlap
maxCsorbaWidth			= max(ceil(brickWidth*100)/200, brickThk)	!Egész cetinre kerekítve
KOZEPEPS				= brickWidth / 4
dim rowLengthLimit[3]
	rowLengthLimit[1]	= 2*brickWidth		!Ez maradjon két tégla
	rowLengthLimit[2]	= 3*brickWidth
	rowLengthLimit[3]	= 5*brickWidth

!-------- Brick Window ----------------
bUseWindowBrick = (iWindowBrick <> BRICK_NONE)

! ------------------------------------------------------------------------------
! Beams
! ------------------------------------------------------------------------------
! -------- Available Beam types -------
dim iAvaBeamFamilysAll[], iAvaBeamFamilysAllIdxs[]
nBeamFamilysAll				= vardim1(datProdBeamIdx)
iAvaBeamFamilysAll[2]		= BEAM_FAMILY_CUSTOM
iAvaBeamFamilysAllIdxs[2]	= 0
iAvaBeamFamilysAll[1]		= BEAM_FAMILY_NONE
iAvaBeamFamilysAllIdxs[1]	= 0
nAvaBeamFamilysAll			= vardim1(iAvaBeamFamilysAll)
for i = 1 to nBeamFamilysAll
	if datProdBeamLang[i] = iLang then
		nAvaBeamFamilysAll							= nAvaBeamFamilysAll + 1
		iAvaBeamFamilysAllIdxs[nAvaBeamFamilysAll]	= i
		iAvaBeamFamilysAll[nAvaBeamFamilysAll]		= datProdBeamIdx[i]
		if datProdBeamGroutBottom[i] < EPS then datProdBeamGroutBottom[i]	= groutHorizontal / 2
		if datProdBeamGroutTop[i]	 < EPS then datProdBeamGroutTop[i]		= groutHorizontal / 2
	endif
next i
!! TODO de
!!		if brickThk > 0.4-BIGEPS then
!!			iAvaBeamTypes[vardim1(iAvaBeamTypes)+1] = BEAM_FAMILY_UBLOCK
!!		endif

beamMinHoleWidth	= brickWidth - 2*minBrickOverlap
beamOverhangPlus	= 0.05			!Ha vágható az áthidaló ott számít

! ------------ Find Lang Beams ------------------
dim avaBeamTypesAll[], avaBeamTypesIdxsAll[]
nBeamTypesAll		= vardim1(datBeamIdx)
nAvaBeamTypesAll	= 0
for i = 1 to nBeamTypesAll
	if datBeamLang[i] = iLang then
		nAvaBeamTypesAll						= nAvaBeamTypesAll + 1
		avaBeamTypesIdxsAll[nAvaBeamTypesAll]	= i
		avaBeamTypesAll[nAvaBeamTypesAll]		= datBeamIdx[i]
	endif
next i


! -------- Multiple Beams Thks -------
dim avaMultiBeamThks[][], avaMultiBeamPos[][], nAvaMultiBeamSub[]
nMaxMultiSub	= 0
nAvaMultiBeam	= 0
! TODO lehet hogy kell finomitani
if abs(brickThk - 0.090) < BIGEPS then
	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 1
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.1
	avaMultiBeamPos[nAvaMultiBeam][1]	= 0.0
endif
if abs(brickThk - 0.190) < BIGEPS then
	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 1
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.175
	avaMultiBeamPos[nAvaMultiBeam][1]	= 0.0
endif
if abs(brickThk - 0.215) < BIGEPS then
	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 1
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.20
	avaMultiBeamPos[nAvaMultiBeam][1]	= 0.0

	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 2
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.10
	avaMultiBeamThks[nAvaMultiBeam][2]	= 0.10
	avaMultiBeamPos[nAvaMultiBeam][1]	= -0.0575
	avaMultiBeamPos[nAvaMultiBeam][2]	= 0.0575
endif
if abs(brickThk - 0.240) < BIGEPS then
	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 2
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.115
	avaMultiBeamThks[nAvaMultiBeam][2]	= 0.115
	avaMultiBeamPos[nAvaMultiBeam][1]	= -0.0625
	avaMultiBeamPos[nAvaMultiBeam][2]	= 0.0625
endif
if abs(brickThk - 0.250) < BIGEPS then
	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 2
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.125
	avaMultiBeamThks[nAvaMultiBeam][2]	= 0.125
	avaMultiBeamPos[nAvaMultiBeam][1]	= -0.0625
	avaMultiBeamPos[nAvaMultiBeam][2]	= 0.0625
endif
if abs(brickThk - 0.300) < BIGEPS then
	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 2
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.15
	avaMultiBeamThks[nAvaMultiBeam][2]	= 0.15
	avaMultiBeamPos[nAvaMultiBeam][1]	= -0.075
	avaMultiBeamPos[nAvaMultiBeam][2]	= 0.075

	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 2
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.115
	avaMultiBeamThks[nAvaMultiBeam][2]	= 0.175
	avaMultiBeamPos[nAvaMultiBeam][1]	= -0.0925
	avaMultiBeamPos[nAvaMultiBeam][2]	= 0.0625
endif
if abs(brickThk - 0.350) < BIGEPS then
	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 2
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.175
	avaMultiBeamThks[nAvaMultiBeam][2]	= 0.175
	avaMultiBeamPos[nAvaMultiBeam][1]	= -0.0875
	avaMultiBeamPos[nAvaMultiBeam][2]	= 0.0875
endif
if abs(brickThk - 0.360) < BIGEPS then
	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 2
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.175
	avaMultiBeamThks[nAvaMultiBeam][2]	= 0.175
	avaMultiBeamPos[nAvaMultiBeam][1]	= -0.0925
	avaMultiBeamPos[nAvaMultiBeam][2]	= 0.0925

	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 3
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.115
	avaMultiBeamThks[nAvaMultiBeam][2]	= 0.115
	avaMultiBeamThks[nAvaMultiBeam][3]	= 0.115
	avaMultiBeamPos[nAvaMultiBeam][1]	= -0.1225
	avaMultiBeamPos[nAvaMultiBeam][2]	= 0.0
	avaMultiBeamPos[nAvaMultiBeam][3]	= 0.1225
endif
if abs(brickThk - 0.365) < BIGEPS then
	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 2
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.175
	avaMultiBeamThks[nAvaMultiBeam][2]	= 0.175
	avaMultiBeamPos[nAvaMultiBeam][1]	= -0.095
	avaMultiBeamPos[nAvaMultiBeam][2]	= 0.095
endif
if abs(brickThk - 0.375) < BIGEPS then
	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 3
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.125
	avaMultiBeamThks[nAvaMultiBeam][2]	= 0.125
	avaMultiBeamThks[nAvaMultiBeam][3]	= 0.125
	avaMultiBeamPos[nAvaMultiBeam][1]	= -0.125
	avaMultiBeamPos[nAvaMultiBeam][2]	= 0.0
	avaMultiBeamPos[nAvaMultiBeam][3]	= 0.125
endif
if abs(brickThk - 0.400) < BIGEPS then
	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 2
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.2
	avaMultiBeamThks[nAvaMultiBeam][2]	= 0.2
	avaMultiBeamPos[nAvaMultiBeam][1]	= -0.1
	avaMultiBeamPos[nAvaMultiBeam][2]	= 0.1

	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 3
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.115
	avaMultiBeamThks[nAvaMultiBeam][2]	= 0.175
	avaMultiBeamThks[nAvaMultiBeam][3]	= 0.115
	avaMultiBeamPos[nAvaMultiBeam][1]	= -0.1425
	avaMultiBeamPos[nAvaMultiBeam][2]	= 0.0
	avaMultiBeamPos[nAvaMultiBeam][3]	= 0.1425
endif
if abs(brickThk - 0.420) < BIGEPS then
	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 3
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.115
	avaMultiBeamThks[nAvaMultiBeam][2]	= 0.15
	avaMultiBeamThks[nAvaMultiBeam][3]	= 0.15
	avaMultiBeamPos[nAvaMultiBeam][1]	= -0.1525
	avaMultiBeamPos[nAvaMultiBeam][2]	= -0.015
	avaMultiBeamPos[nAvaMultiBeam][3]	= 0.135
endif
if abs(brickThk - 0.425) < BIGEPS then
	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 3
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.175
	avaMultiBeamThks[nAvaMultiBeam][2]	= 0.115
	avaMultiBeamThks[nAvaMultiBeam][3]	= 0.115
	avaMultiBeamPos[nAvaMultiBeam][1]	= -0.125
	avaMultiBeamPos[nAvaMultiBeam][2]	= 0.025
	avaMultiBeamPos[nAvaMultiBeam][3]	= 0.155
endif
if abs(brickThk - 0.45) < BIGEPS then
	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 3
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.150
	avaMultiBeamThks[nAvaMultiBeam][2]	= 0.150
	avaMultiBeamThks[nAvaMultiBeam][3]	= 0.150
	avaMultiBeamPos[nAvaMultiBeam][1]	= -0.150
	avaMultiBeamPos[nAvaMultiBeam][2]	= 0.0
	avaMultiBeamPos[nAvaMultiBeam][3]	= 0.150
endif
if abs(brickThk - 0.480) < BIGEPS then
	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 2
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.24
	avaMultiBeamThks[nAvaMultiBeam][2]	= 0.24
	avaMultiBeamPos[nAvaMultiBeam][1]	= -0.12
	avaMultiBeamPos[nAvaMultiBeam][2]	= 0.12

	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 3
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.175
	avaMultiBeamThks[nAvaMultiBeam][2]	= 0.115
	avaMultiBeamThks[nAvaMultiBeam][3]	= 0.175
	avaMultiBeamPos[nAvaMultiBeam][1]	= -0.1525
	avaMultiBeamPos[nAvaMultiBeam][2]	= 0.0
	avaMultiBeamPos[nAvaMultiBeam][3]	= 0.1525

	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 4
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.115
	avaMultiBeamThks[nAvaMultiBeam][2]	= 0.115
	avaMultiBeamThks[nAvaMultiBeam][3]	= 0.115
	avaMultiBeamThks[nAvaMultiBeam][4]	= 0.115
	avaMultiBeamPos[nAvaMultiBeam][1]	= -0.1825
	avaMultiBeamPos[nAvaMultiBeam][2]	= -0.06
	avaMultiBeamPos[nAvaMultiBeam][3]	= 0.06
	avaMultiBeamPos[nAvaMultiBeam][4]	= 0.1825
endif
if abs(brickThk - 0.500) < BIGEPS | abs(brickThk - 0.499) < BIGEPS then
	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 2
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.24
	avaMultiBeamThks[nAvaMultiBeam][2]	= 0.24
	avaMultiBeamPos[nAvaMultiBeam][1]	= -0.13
	avaMultiBeamPos[nAvaMultiBeam][2]	= 0.13

	nAvaMultiBeam						= nAvaMultiBeam + 1
	nAvaMultiBeamSub[nAvaMultiBeam]		= 2
	avaMultiBeamThks[nAvaMultiBeam][1]	= 0.25
	avaMultiBeamThks[nAvaMultiBeam][2]	= 0.25
	avaMultiBeamPos[nAvaMultiBeam][1]	= -0.125
	avaMultiBeamPos[nAvaMultiBeam][2]	= 0.125
endif

!Max subtype
for i = 1 to nAvaMultiBeam
	if nAvaMultiBeamSub[i] > nMaxMultiSub then
		nMaxMultiSub = nAvaMultiBeamSub[i]
	endif
next i
!Fill array
for i = 1 to nAvaMultiBeam
	for j = nAvaMultiBeamSub[i] + 1 to nMaxMultiSub
		avaMultiBeamThks[i][j]	= 0.0
		avaMultiBeamPos[i][j]	= 0.0
	next j
next i


! ------------ Find valid beams (Single)------------------
dim avaBeamTypes[][], avaBeamTypesIdxs[][], avaBeamTypesMulti[][], nMaxAvaBeams[]
nMaxBeam				= 1
avaBeamTypes[2][1]		= BEAM_CUSTOM
avaBeamTypesIdxs[2][1]	= 0
avaBeamTypesMulti[2][1]	= 0
nMaxAvaBeams[2]			= 1
avaBeamTypes[1][1]		= BEAM_NONE
avaBeamTypesIdxs[1][1]	= 0
avaBeamTypesMulti[1][1]	= 0
nMaxAvaBeams[1]			= 1
for i = nAvaBeamFamilysAll to 1 step -1
	avaBeamTypes[i][1]		= 0
	avaBeamTypesIdxs[i][1]	= 0
	nMaxAvaBeams[i]			= 0
	fam						= iAvaBeamFamilysAll[i]
	if fam <> BEAM_FAMILY_NONE and fam <> BEAM_FAMILY_CUSTOM then
		n = 0
		for j = 1 to nAvaBeamTypesAll
			idx = avaBeamTypesIdxsAll[j]
			if datBeamFamily[idx] = fam then
				if abs(brickThk - datBeamSize[idx][BRICKSIZE_THK]) < BIGEPSCM then
					n						= n + 1
					avaBeamTypes[i][n]		= datBeamIdx[idx]
					avaBeamTypesIdxs[i][n]	= idx
					avaBeamTypesMulti[i][n]	= 0
				endif
			endif
		next j

		if n > nMaxBeam then nMaxBeam = n
		nMaxAvaBeams[i] = n
	endif
next i


! ------------ Find valid beams (Multi)------------------
dim multiBeamsIdxs[][], multiBeamsPos[][], nMultiSubBeams[], multiBeamFams[]
nMaxMultiSubBeam	= 0
nMultiBeams 		= 0
!!if brickThk > 0.2 + EPS then
if brickThk > EPS then
	for i = 1 to nAvaBeamFamilysAll
		fam	= iAvaBeamFamilysAll[i]
		if fam <> BEAM_FAMILY_NONE and fam <> BEAM_FAMILY_CUSTOM then
			famIdx = iAvaBeamFamilysAllIdxs[i]
			if datProdBeamMulti[famIdx] then	! Lehetséges ebben a familyben multi
				for j = 1 to nAvaMultiBeam
					!chekkoljuk hogy vannak e gerendák ebben a vastagságban
					bFoundAllThk = 1
					for z = 1 to nAvaMultiBeamSub[j]
						findBeamThk = avaMultiBeamThks[j][z]
						gosub "findBeamThickness"
						if not(foundBeamThk) then
							bFoundAllThk	= 0
							z				= nAvaMultiBeamSub[j]
						endif
					next z

					!Ha talál akkor megkeressük
					if bFoundAllThk then
						!Megkeressük az első vastagsággal rendelkező hosszúságú elemeket
						dim beamMultiLengths[]
						findBeamThk = avaMultiBeamThks[j][1]
						gosub "findBeamLengths"

						! Na most megkeressük a lengtekhez tartozo gerendákat
						for k = 1 to nMulitBeamLengths
							foundAll = 1
							dim idxs[]
							for z = nAvaMultiBeamSub[j] to 1 step -1
								findBeamThk		= avaMultiBeamThks[j][z]
								findBeamLength	= beamMultiLengths[k]
								gosub "findBeamThkWithLength"
								idxs[z] = foundBeamIdx
								if foundBeamIdx = 0 then
									foundAll	= 0
									z			= 1
								endif
							next z

							!Ha megtalálta mindhez akkor benyomjuk
							if foundAll then
								nMultiBeams = nMultiBeams + 1
								if nMaxMultiSubBeam < nAvaMultiBeamSub[j] then
									nMaxMultiSubBeam = nAvaMultiBeamSub[j]
								endif
								nMultiSubBeams[nMultiBeams] = nAvaMultiBeamSub[j]
								multiBeamsIdxs[nMultiBeams]	= idxs
								multiBeamsPos[nMultiBeams]	= avaMultiBeamPos[j]
								multiBeamFams[nMultiBeams]	= i
							endif
						next k
					endif
				next j
			endif
		endif
	next i
endif
!Empty array
for i = 1 to nMultiBeams
	for j = nMultiSubBeams[i]+1 to nMaxMultiSubBeam
		multiBeamsIdxs[i][j]	= 0
		multiBeamsPos[i][j]		= 0
	next j
next i

!Fill to Normal array
for i = 1 to nMultiBeams
	famN	= multiBeamFams[i]
	beamIdx	= multiBeamsIdxs[i][1]

	if famN then
		nMaxAvaBeams[famN]							= nMaxAvaBeams[famN] + 1
		if nMaxAvaBeams[famN] > nMaxBeam then
			nMaxBeam = nMaxAvaBeams[famN]
		endif
		avaBeamTypes[famN][nMaxAvaBeams[famN]] 		= datBeamIdx[beamIdx]
		avaBeamTypesIdxs[famN][nMaxAvaBeams[famN]] 	= beamIdx
		avaBeamTypesMulti[famN][nMaxAvaBeams[famN]] 	= i
	endif
next i
!print nMultiBeams, nMultiSubBeams, multiBeamsPos, multiBeamsIdxs

!Fill Empty array
for i = 1 to nAvaBeamFamilysAll
	for j = nMaxAvaBeams[i]+1 to nMaxBeam
		avaBeamTypes[i][j]		= 0
		avaBeamTypesIdxs[i][j]	= 0
		avaBeamTypesMulti[i][j]	= 0
	next j
next i
nAvaBeamTypes = vardim1(avaBeamTypes)


!print nAvaBeamFamilysAll, nAvaBeamTypes, iAvaBeamFamilysAll, "ava", avaBeamTypes


!-------- Fill Beam Infield ----------
dim beamParametersArray[], beamParametersArrayIdxs[]
nBeamParameters 		= 0
idxBeamFamily			= 0
bFoundBeamFam			= 0
uBlockRangeAvailable	= 0
uBlockAvailable			= 0
for i = 1 to nAvaBeamTypes
	if nMaxAvaBeams[i] > 0 then
		nBeamParameters								= nBeamParameters + 1
		beamParametersArray[nBeamParameters]		= iAvaBeamFamilysAll[i]
		beamParametersArrayIdxs[nBeamParameters]	= iAvaBeamFamilysAllIdxs[i]
		if iBeamFamily = iAvaBeamFamilysAll[i] then
			bFoundBeamFam	= 1
			idxBeamFamily	= iAvaBeamFamilysAllIdxs[i]
			!iBeamFamily		= iAvaBeamFamilysAll[i]
			!parameters iBeamFamily = iBeamFamily
		endif
		if datProdType[iAvaBeamFamilysAllIdxs[i]]  = BEAM_TYP_RANGE then
			uBlockRangeAvailable = 1
		endif
		if datProdType[iAvaBeamFamilysAllIdxs[i]]  = BEAM_TYP_BLOCK then
			uBlockAvailable = 1
		endif
	endif
next i
!nBeamParameters								= nBeamParameters + 1
!beamParametersArray[nBeamParameters]		= BEAM_FAMILY_CUSTOM
!beamParametersArrayIdxs[nBeamParameters]	= 0


! ------------------------------------------------------------------------------
! Joint Types
! ------------------------------------------------------------------------------
dim jointTypes[]
if datProdDisableJoint[idxFamily] then
	jointTypes[1] = JOINT_SIDE_NONE
else
	jointTypes[7] = JOINT_SIDE_CORNER_T_2
	jointTypes[6] = JOINT_SIDE_CORNER_T_1
	jointTypes[5] = JOINT_SIDE_CORNER_2
	jointTypes[4] = JOINT_SIDE_CORNER_1
	jointTypes[3] = JOINT_SIDE_END
	jointTypes[2] = JOINT_SIDE_NONE
	jointTypes[1] = JOINT_SIDE_AUTO
endif
nJointTypes = vardim1(jointTypes)
dAng		= 360 / nJointTypes




! ==============================================================================
!
! Debug Function
!
! ==============================================================================
if gs_gdl_debug then
	print "- GDL Debug --- GDL Debug --- GDL Debug --- GDL Debug -"
	print "ac_wall_height=",ac_wall_height
	print "ac_wall_radius=",ac_wall_radius
	print "ac_wall_length=",ac_wall_length
	print "ac_refside=",ac_refside
	print "ac_angles"
	for i=1 to vardim1(ac_angles)
		print ac_angles[i]
	next i
	print "ac_side_poly"
	for i=1 to vardim1(ac_side_poly)
		print ac_side_poly[i]
	next i
	print "ac_top_poly"
	for i=1 to vardim1(ac_top_poly)
		print ac_top_poly[i]
	next i

	print "ac_bot_poly"
	for i=1 to vardim1(ac_bot_poly)
		print ac_bot_poly[i]
	next i

	print "ac_wd_poly"
	for i=1 to vardim1(ac_wd_poly)
		print ac_wd_poly[i]
	next i
endif


! ==============================================================================
!
! Geometry
!
! ==============================================================================
if bResetGeom then
	! ==============================================================================
	!
	! Contoure
	!
	! ==============================================================================

	! ------------------------------------------------------------------------------
	! Contours
	! ------------------------------------------------------------------------------
	dim contourPoints[][2]
	
	! -------Contour definitions---------------------
	nPolygonPoint		= 0
	nWallSide			= 0
	bWallPolyMirrored	= 0
	if ac_top_poly[2][2] < EPS then bWallPolyMirrored = 1
	
	! -------Bottom Cut---------------------			! Csak tudnam mért forgatja az api
	dim tempPolyCoords[][2]
	if bUseBottomContour then
		if bWallPolyMirrored then
			tempPolyCoords		= ac_top_poly
			contourDirection	= 1						! Körbejárási irány
		else
			tempPolyCoords		= ac_bot_poly
			contourDirection	= -1
		endif
	
		if ACVERSION > 16 then
			if abs(tempPolyCoords[1][1]) > EPS then
				vx = tempPolyCoords[2][1] - tempPolyCoords[1][1]
				vy = tempPolyCoords[2][2] - tempPolyCoords[1][2]
				gosub "directionAngle"
		
				tempPolyCoords[1][2]	= tempPolyCoords[1][2] - tempPolyCoords[1][1] * tan(angle)
				tempPolyCoords[1][1]	= 0
			endif
	
			n = vardim1(tempPolyCoords)
			if abs(tempPolyCoords[n][1] - ac_wall_length) > EPS then
				vx = tempPolyCoords[n][1] - tempPolyCoords[n-1][1]
				vy = tempPolyCoords[n][2] - tempPolyCoords[n-1][2]
				gosub "directionAngle"
				
				tempPolyCoords[n][2]	= tempPolyCoords[n][2] + (ac_wall_length-tempPolyCoords[n][1]) * tan(angle)
				tempPolyCoords[n][1]	= ac_wall_length
			endif
		endif
	else
		tempPolyCoords[2][2] = 0
		tempPolyCoords[2][1] = ac_wall_length
		tempPolyCoords[1][2] = 0
		tempPolyCoords[1][1] = 0
	endif
	nPolygonPoint = vardim1(tempPolyCoords)
	for i=nPolygonPoint to 1 step -1
		contourPoints[i][1] = tempPolyCoords[i][1]
		contourPoints[i][2] = tempPolyCoords[i][2]
	next i
	
	! -------Top Cut--------------------
	dim tempPolyCoords[][2]
	if bUseTopContour then
		if bWallPolyMirrored then
			tempPolyCoords		= ac_bot_poly
			contourDirection	= 1
		else
			tempPolyCoords		= ac_top_poly
			contourDirection	= -1
		endif
	
		if ACVERSION > 16 then
			if abs(tempPolyCoords[1][1]) > EPS then
				vx = tempPolyCoords[2][1] - tempPolyCoords[1][1]
				vy = tempPolyCoords[2][2] - tempPolyCoords[1][2]
				gosub "directionAngle"
		
				tempPolyCoords[1][2]	= tempPolyCoords[1][2] - tempPolyCoords[1][1] * tan(angle)
				tempPolyCoords[1][1]	= 0
			endif
	
			n = vardim1(tempPolyCoords)
			if abs(tempPolyCoords[n][1] - ac_wall_length) > EPS then
				vx = tempPolyCoords[n][1] - tempPolyCoords[n-1][1]
				vy = tempPolyCoords[n][2] - tempPolyCoords[n-1][2]
				gosub "directionAngle"
				
				tempPolyCoords[n][2]	= tempPolyCoords[n][2] + (ac_wall_length-tempPolyCoords[n][1]) * tan(angle)
				tempPolyCoords[n][1]	= ac_wall_length
			endif
		endif
	else
		tempPolyCoords[2][2] = ac_wall_height
		tempPolyCoords[2][1] = ac_wall_length
		tempPolyCoords[1][2] = ac_wall_height
		tempPolyCoords[1][1] = 0
	endif
	for i = vardim1(tempPolyCoords) to 1 step -1
		if i = vardim1(tempPolyCoords) then
			if abs(contourPoints[nPolygonPoint][1] - tempPolyCoords[i][1]) > EPS | abs(contourPoints[nPolygonPoint][2] - tempPolyCoords[i][2]) > EPS then
				nPolygonPoint = nPolygonPoint + 1
				contourPoints[nPolygonPoint][1] = tempPolyCoords[i][1]
				contourPoints[nPolygonPoint][2] = tempPolyCoords[i][2]
			endif
		else
			nPolygonPoint = nPolygonPoint + 1
			contourPoints[nPolygonPoint][1] = tempPolyCoords[i][1]
			contourPoints[nPolygonPoint][2] = tempPolyCoords[i][2]
		endif
	next i

	nWallSect	= max(vardim1(ac_angles), 1)
	if nWallSect > 1 then nWallSide	= vardim1(ac_side_poly)
	
	! Close polygon
	if abs(contourPoints[1][1] - contourPoints[nPolygonPoint][1]) > EPS | abs(contourPoints[1][2] - contourPoints[nPolygonPoint][2]) > EPS then
		nPolygonPoint = nPolygonPoint + 1
		contourPoints[nPolygonPoint][1] = contourPoints[1][1]
		contourPoints[nPolygonPoint][2] = contourPoints[1][2]
	endif
		
	
	! ------------------------------------------------------------------------------
	! min, max Coords (Bounding box definition)
	! ------------------------------------------------------------------------------
	dim boundingRef[1][4]
	boundingRef[1][1]	= contourPoints[1][1]
	boundingRef[1][2]	= contourPoints[1][2]
	boundingRef[1][3]	= contourPoints[1][1]
	boundingRef[1][4]	= contourPoints[1][2]
	
	minXpointNumber		= 1
	maxXpointNumber		= 1
	
	for i = 2 to nPolygonPoint
		if contourPoints[i][2] < boundingRef[1][2]  then boundingRef[1][2] = contourPoints[i][2]
		if contourPoints[i][2] > boundingRef[1][4]  then boundingRef[1][4] = contourPoints[i][2]
	
		if contourPoints[i][1] >= boundingRef[1][3]  then
			boundingRef[1][3] = contourPoints[i][1]
			maxXpointNumber = i
		endif
	
		if contourPoints[i][1] < boundingRef[1][1]  then
			boundingRef[1][1] = contourPoints[i][1]
			minXpointNumber = i
		endif
	next i
	
	! ------------------------------------------------------------------------------
	! Borders
	! ------------------------------------------------------------------------------
	dim iBorderModes[]
	dim contourAngles[]
	
	for i = nPolygonPoint-1 to 1 step -1
		vx =  contourPoints[i+1][1] - contourPoints[i][1]
		vy =  contourPoints[i+1][2] - contourPoints[i][2]
		gosub "directionAngle"
		contourAngles[i] = angle
	
		if abs(vx) < EPS then					! Függöleges
			if vy > EPS then
				iBorderModes[i] = BORDER_VERT_UP
			else
				iBorderModes[i] = BORDER_VERT_DOWN
			endif
		else
			if ABS(vy) < EPS then				! Vízszintes
				if vx > EPS then				! Alsó
					iBorderModes[i] = BORDER_BOT_HOR
				else
					iBorderModes[i] = BORDER_TOP_HOR
				endif
			else								! Ferde
				if vx > EPS then				! Alsó
					iBorderModes[i] = BORDER_BOT_SLANT
				else
					iBorderModes[i] = BORDER_TOP_SLANT
				endif
			endif
		endif
	next i


	! ------------------------------------------------------------------------------
	! Surface Direction
	! ------------------------------------------------------------------------------
	if not(ac_refside) then
		surfaceDir = -1
	else
		surfaceDir = 1
	endif
	
	if abs((boundingRef[1][3]-boundingRef[1][1]) - ac_wall_length) > EPS then
		print stAddOnErrorLength
	endif

	
	! ------------------------------------------------------------------------------
	! Connections
	! ------------------------------------------------------------------------------
	csorbaX1			= brickThk
	csorbaX2			= brickThk
	bCsorba1			= 0
	bCsorba2			= 0
	offsetPlusL			= 0
	offsetPlusR			= 0
	bOverrideJoint1 	= 0
	bOverrideJoint2 	= 0
	connWallStartThk	= brickThk
	connWallStartAngle	= 2*ac_angles[1][1]
	connWallStartIangle	= ANGLE_UNKNOWN
	connWallEndThk		= brickThk
	connWallEndAngle	= 2*(90-(ac_angles[vardim1(ac_angles)][vardim2(ac_angles)]-90))
	connWallEndIangle	= ANGLE_UNKNOWN
	cutAngle01			= 90-connWallStartAngle/2
	cutAngle02			= 90-connWallEndAngle/2
	brickStartAngleDiff	= 0
	brickEndAngleDiff	= 0

	! ------------ Left -----------------------
	if iJointType1 = JOINT_SIDE_AUTO then
		bOverrideJoint1		= 1
		bJointAngle1 		= 0
		bCustomCsorba1 		= 0
		if abs(connWallStartAngle) < EPS | abs(connWallStartAngle - 180) < EPS | abs(connWallStartAngle - 360) < EPS then
			iCalcJointType1 = JOINT_SIDE_END
		else
			iCalcJointType1 = JOINT_SIDE_CORNER_1
		endif
	else
		iCalcJointType1		= iJointType1
	endif

	if	iCalcJointType1 = JOINT_SIDE_CORNER_1	|\
		iCalcJointType1 = JOINT_SIDE_CORNER_2	|\
		iCalcJointType1 = JOINT_SIDE_CORNER_T_1	|\
		iCalcJointType1 = JOINT_SIDE_CORNER_T_2	\
	then
		bCsorba1 = 1
	endif

	if iCalcJointType1 <> JOINT_SIDE_NONE & not(bCsorba1) then
		bJointAngle1 		= 1
		bOverrideJoint1		= 1
		jointAngle1			= 90
	endif
	if iCalcJointType1 = JOINT_SIDE_CORNER_T_1 | iCalcJointType1 = JOINT_SIDE_CORNER_T_2 then
		bJointAngle1 		= 1
		bOverrideJoint1		= 1
		jointAngle1			= 90
	endif
	if iCalcJointType1 = JOINT_SIDE_PROFILE | iCalcJointType1 = JOINT_SIDE_END then
		bJointAngle1 		= 1
		bOverrideJoint1		= 1
		jointAngle1			= 180
	endif
	if bJointAngle1 then
		connWallStartAngle	= jointAngle1
		cutAngle01			= 90-connWallStartAngle/2	!45 - (90-jointAngle1)/2
	endif

	if	abs(abs(connWallStartAngle))		< EPS |\
		abs(abs(connWallStartAngle) - 360)	< EPS |\
		abs(abs(connWallStartAngle) - 180)	< EPS \
	then
		connWallStartIangle = ANGLE_LINE
	else
		if	abs(abs(connWallStartAngle) - 90)	< EPS |\
			abs(abs(connWallStartAngle) - 270)	< EPS \
		then
			connWallStartIangle = ANGLE_PERPENDICULAR
		else
			if abs(connWallStartAngle) < 90-EPS | abs(connWallStartAngle) > 270+EPS then
				connWallStartIangle = ANGLE_ACUTE
			else
				if abs(connWallStartAngle) > 90+EPS & abs(connWallStartAngle) < 270-EPS then
					connWallStartIangle = ANGLE_OBTUSE
				endif
			endif
		endif
	endif

	brickStartAngleDiff	= brickThk*tan(cutAngle01)

	if	iCalcJointType1 = JOINT_SIDE_CORNER_1	|\
		iCalcJointType1 = JOINT_SIDE_CORNER_2	|\
		iCalcJointType1 = JOINT_SIDE_CORNER_T_1	|\
		iCalcJointType1 = JOINT_SIDE_CORNER_T_2	\
	then
		bCsorba1 = 1
		if bCustomCsorba1 then
			connWallStartThk	= csorbaW1
			csorbaX1			= csorbaW1
		endif

		if connWallStartIangle = ANGLE_UNKNOWN then
			if abs(abs(connWallStartAngle) - 45) < EPS | abs(abs(connWallStartAngle) - 270) < EPS then
				csorbaX1	= connWallStartThk + groutVertical
			else
				angle		= connWallStartAngle - 90
				csorbaX1	= (connWallStartThk + groutVertical) / cos(angle)
			endif
		endif
		if connWallStartIangle = ANGLE_PERPENDICULAR then
			csorbaX1	= connWallStartThk + groutVertical
		endif
		if connWallStartIangle = ANGLE_LINE then
			csorbaX1	= (brickWidth + groutVertical)/2
		endif
		if connWallStartIangle = ANGLE_ACUTE then
			angle		= connWallStartAngle - 90
			csorbaX1 	= (connWallStartThk + groutVertical) / cos(angle)
			if abs(connWallStartAngle) > 270+EPS then
				offsetPlusL	= brickThk * tan(angle) * (1-2*(connWallStartAngle > 180))
				if csorbaX1 < -EPS then
					csorbaX1  			= -csorbaX1
					brickStartAngleDiff	= 0
				endif
			endif
		endif
		if connWallStartIangle = ANGLE_OBTUSE then
			angle		= connWallStartAngle - 90
			csorbaX1 	= (connWallStartThk + groutVertical) / cos(angle)
			offsetPlusL	= brickThk * tan(angle) * (1-2*(connWallStartAngle > 180))
			if csorbaX1 < -EPS then
				csorbaX1  			= -csorbaX1
				brickStartAngleDiff	= 0
			endif
		endif
	endif
!print "start", connWallStartIangle, ac_angles[1][1], cutAngle01, connWallStartAngle, csorbaX1, offsetPlusL



	! --------------- Right ---------------------
	if iJointType2 = JOINT_SIDE_AUTO then
		bOverrideJoint2		= 1
		bJointAngle2 		= 0
		bCustomCsorba2 		= 0
		if abs(connWallEndAngle) < EPS | abs(connWallEndAngle - 180) < EPS | abs(connWallEndAngle - 360) < EPS then
			iCalcJointType2 = JOINT_SIDE_END
		else
			iCalcJointType2 = JOINT_SIDE_CORNER_1
		endif
	else
		iCalcJointType2		= iJointType2
	endif

	if	iCalcJointType2 = JOINT_SIDE_CORNER_1	|\
		iCalcJointType2 = JOINT_SIDE_CORNER_2	|\
		iCalcJointType2 = JOINT_SIDE_CORNER_T_1	|\
		iCalcJointType2 = JOINT_SIDE_CORNER_T_2	\
	then
		bCsorba2 = 1
	endif
	
	if	iCalcJointType2 <> JOINT_SIDE_NONE & not(bCsorba2) then
		bJointAngle2 		= 1
		bOverrideJoint2		= 1
		jointAngle2			= 90
	endif
	if iCalcJointType2 = JOINT_SIDE_CORNER_T_1 | iCalcJointType2 = JOINT_SIDE_CORNER_T_2 then
		bJointAngle2 		= 1
		bOverrideJoint2		= 1
		jointAngle2			= 90
	endif
	if iCalcJointType2 = JOINT_SIDE_PROFILE | iCalcJointType2 = JOINT_SIDE_END then
		bJointAngle2 		= 1
		bOverrideJoint2		= 1
		jointAngle2			= 180
	endif
	if bJointAngle2 then
		connWallEndAngle	= jointAngle2
		cutAngle02			= 90-connWallEndAngle/2	!-45 - (90-jointAngle2)/2
	endif

	if	abs(abs(connWallEndAngle))			< EPS |\
		abs(abs(connWallEndAngle) - 360)	< EPS |\
		abs(abs(connWallEndAngle) - 180)	< EPS \
	then
		connWallEndIangle = ANGLE_LINE
	else
		if	abs(abs(connWallEndAngle) - 90)		< EPS |\
			abs(abs(connWallEndAngle) - 270)	< EPS \
		then
			connWallEndIangle = ANGLE_PERPENDICULAR
		else
			if abs(connWallEndAngle) < 90-EPS | abs(connWallEndAngle) > 270+EPS then
				connWallEndIangle = ANGLE_ACUTE
			else
				if abs(connWallEndAngle) > 90+EPS & abs(connWallEndAngle) < 270-EPS then
					connWallEndIangle = ANGLE_OBTUSE
				endif
			endif
		endif
	endif

	brickEndAngleDiff	= brickThk*tan(cutAngle02)

	if	iCalcJointType2 = JOINT_SIDE_CORNER_1	|\
		iCalcJointType2 = JOINT_SIDE_CORNER_2	|\
		iCalcJointType2 = JOINT_SIDE_CORNER_T_1	|\
		iCalcJointType2 = JOINT_SIDE_CORNER_T_2	\
	then
		bCsorba2 = 1
		if bCustomCsorba2 then
			connWallEndThk	= csorbaW2
			csorbaX2		= csorbaW2
		endif

		if connWallEndIangle = ANGLE_UNKNOWN then
			if abs(abs(connWallEndAngle) - 90) < EPS | abs(abs(connWallEndAngle) - 270) < EPS then
				csorbaX2	= connWallEndThk + groutVertical
			else
				angle		= connWallEndAngle - 90
				csorbaX2	= (connWallEndThk + groutVertical) / cos(angle)
			endif
		endif
		if connWallEndIangle = ANGLE_PERPENDICULAR then
			csorbaX2 	= connWallEndThk + groutVertical
		endif
		if connWallEndIangle = ANGLE_LINE then
			csorbaX2 	= (brickWidth + groutVertical)/2
		endif
		if connWallEndIangle = ANGLE_ACUTE then
			angle		= connWallEndAngle - 90
			csorbaX2	= (connWallEndThk + groutVertical) / cos(angle)
			if abs(connWallEndAngle) > 270+EPS then
				offsetPlusR = brickThk * tan(angle) * (1-2*(connWallEndAngle > 180))
				if csorbaX2 < -EPS then
					brickEndAngleDiff	= 0
					csorbaX2 			= -csorbaX2
				endif
			endif
		endif
		if connWallEndIangle = ANGLE_OBTUSE then
			angle		= connWallEndAngle - 90
			csorbaX2	= (connWallEndThk + groutVertical) / cos(angle)
			offsetPlusR = brickThk * tan(angle) * (1-2*(connWallEndAngle > 180))
			if csorbaX2 < -EPS then
				brickEndAngleDiff	= 0
				csorbaX2 			= -csorbaX2
			endif
		endif
	endif
!print "end", connWallEndIangle, ac_angles[vardim1(ac_angles)][vardim2(ac_angles)], cutAngle02, connWallEndAngle, csorbaX2, offsetPlusR


	! ------------------------------------------------------------------------------
	! Bounding Box
	! ------------------------------------------------------------------------------	
	dim boundingOther[1][4]
	boundingOther[1][1] = boundingRef[1][1] - brickStartAngleDiff - offsetPlusL
	boundingOther[1][2] = boundingRef[1][2]
	boundingOther[1][3] = boundingRef[1][3] + brickEndAngleDiff + offsetPlusR
	boundingOther[1][4] = boundingRef[1][4]

	surfaceXmin	= min(boundingRef[1][1], boundingOther[1][1])
	surfaceXmax	= max(boundingRef[1][3], boundingOther[1][3])
	surfaceYmin	= min(boundingRef[1][2], boundingOther[1][2])
	surfaceYmax	= max(boundingRef[1][4], boundingOther[1][4])
	surfaceX	= surfaceXmax - surfaceXmin
	surfaceY	= surfaceYmax - surfaceYmin


	! ------------------------------------------------------------------------------
	! Other Side Points
	! ------------------------------------------------------------------------------
	dim contourOutPoints[][2]
	dim baseCubePoints[][2]
	
	for i = nPolygonPoint-1 to 1 step -1
	
		! -------Külso Contour koordináták--------------------
		contourOutPoints[i][2]	= contourPoints[i][2]
		contourOutPoints[i][1]	= contourPoints[i][1]
	
		! -------min max koordináták--------------------
		baseCubePoints[i][1]	= contourPoints[i][1]
		baseCubePoints[i][2]	= contourPoints[i][2]
	
		! -------Modosított külso koordináták--------------------
		if abs(contourPoints[i][1]-boundingRef[1][1]) < EPS  then
			if i >1 then
				tAng1 = contourAngles[i-1]
			else
				tAng1 = contourAngles[nPolygonPoint-1]
			endif
			if i = nPolygonPoint-1 then
				tAng2 = contourAngles[1]
			else
				tAng2 = contourAngles[i]
			endif

			if abs(abs(sin(tAng1))-1) > EPS then
				tAng = tAng1
			else
				tAng = tAng2
			endif

			if i = nPolygonPoint-1 then
				_tang = contourAngles[i-1]
			else
				_tang = contourAngles[i]
			endif

			contourOutPoints[i][1]		= contourPoints[i][1] + (boundingOther[1][1]-boundingRef[1][1])
			baseCubePoints[i][1]		= min(boundingRef[1][1], boundingOther[1][1])
			if abs(abs(sin(tAng))-1) > EPS  then
				contourOutPoints[i][2]	= contourPoints[i][2] + tan(tAng) * (boundingOther[1][1]-boundingRef[1][1])
				if boundingOther[1][1] < boundingRef[1][1] then
					baseCubePoints[i][2]	= contourPoints[i][2] - tan(tAng) * (boundingRef[1][1]-boundingOther[1][1])
				endif
			endif
		else
			if abs(contourPoints[i][1]-boundingRef[1][3]) < EPS  then
				if i >1 then
					tAng1 = contourAngles[i-1]
				else
					tAng1 = contourAngles[nPolygonPoint-1]
				endif
				if i = nPolygonPoint-1 then
					tAng2 = contourAngles[1]
				else
					tAng2 = contourAngles[i]
				endif

				if abs(abs(sin(tAng1))-1) > EPS then
					tAng = tAng1
				else
					tAng = tAng2
				endif

				contourOutPoints[i][1]		= contourPoints[i][1] + (boundingOther[1][3]-boundingRef[1][3])
				baseCubePoints[i][1]		= max(boundingRef[1][3], boundingOther[1][3])
				if abs(abs(sin(tAng))-1) > EPS then
					contourOutPoints[i][2]	= contourPoints[i][2] + tan(tAng) * (boundingOther[1][3]-boundingRef[1][3])
					if boundingOther[1][3] > boundingRef[1][3] then
						baseCubePoints[i][2]	= contourPoints[i][2] + tan(tAng) * (boundingOther[1][3]-boundingRef[1][3])
					endif
				endif		
			endif
		endif
	next i
	
	contourOutPoints[nPolygonPoint][2]	= contourOutPoints[1][2]
	contourOutPoints[nPolygonPoint][1]	= contourOutPoints[1][1]
	
	! -------min max koordináták--------------------
	baseCubePoints[nPolygonPoint][1]	= baseCubePoints[1][1]
	baseCubePoints[nPolygonPoint][2]	= baseCubePoints[1][2]
	
	
	! ------------------------------------------------------------------------------
	! Unified Contour
	! ------------------------------------------------------------------------------
	dim tAngles[]
	for i = nPolygonPoint-1 to 1 step -1
		vx =  baseCubePoints[i+1][1] - baseCubePoints[i][1]
		vy =  baseCubePoints[i+1][2] - baseCubePoints[i][2]
		gosub "directionAngle"
		tAngles[i] = angle
	next i
	
	n	= 0
	dim _tPoint[][2]
	for i = 1 to nPolygonPoint-1
		if i = 1 then
			!!if abs(tAngles[i] - tAngles[i+1]) > EPS | abs(tAngles[i] - tAngles[nPolygonPoint-1]) > EPS then
			if abs(tAngles[i] - tAngles[nPolygonPoint-1]) > EPS then
				n				= n + 1
				_tPoint[n][1]	= baseCubePoints[i][1]
				_tPoint[n][2]	= baseCubePoints[i][2]
			endif
		else
			if abs(tAngles[i-1] - tAngles[i]) > EPS then
				n				= n + 1
				_tPoint[n][1]	= baseCubePoints[i][1]
				_tPoint[n][2]	= baseCubePoints[i][2]
			endif
		endif
	next i
	
	if abs(_tPoint[1][1] - _tPoint[n][1]) > EPS | abs(_tPoint[1][2] - _tPoint[n][2]) > EPS then
		n				= n + 1
		_tPoint[n][1]	= _tPoint[1][1]
		_tPoint[n][2]	= _tPoint[1][2]
	endif
	
	nUniContourPoint = n
	dim uniContourPoint[][2]
	uniContourPoint = _tPoint


	! ------------------------------------------------------------------------------
	! Unified Contour Borders
	! ------------------------------------------------------------------------------
	dim iBorderUni[]
	dim uniAngles[]
	for i = nUniContourPoint-1 to 1 step -1
		vx =  uniContourPoint[i+1][1] - uniContourPoint[i][1]
		vy =  uniContourPoint[i+1][2] - uniContourPoint[i][2]
		gosub "directionAngle"
		uniAngles[i] = angle
	
		if abs(vx) < EPS then					! Függöleges
			if vy > EPS then
				iBorderUni[i] = BORDER_VERT_UP
			else
				iBorderUni[i] = BORDER_VERT_DOWN
			endif
		else
			if ABS(vy) < EPS then				! Vízszintes
				if vx > EPS then				! Alsó
					iBorderUni[i] = BORDER_BOT_HOR
				else
					iBorderUni[i] = BORDER_TOP_HOR
				endif
			else								! Ferde
				if vx > EPS then				! Alsó
					iBorderUni[i] = BORDER_BOT_SLANT
				else
					iBorderUni[i] = BORDER_TOP_SLANT
				endif
			endif
		endif
	next i
	
	!!if nUniContourPoint > nPolygonPoint then
	!!	print `Unification Error (More Points)`, nUniContourPoint, nPolygonPoint, numPoly
	!!endif
	
	
	!!! ------------------------------------------------------------------------------
	!!! Side Debug
	!!! ------------------------------------------------------------------------------
	!!for i = 1 to nPolygonPoint
	!!	put contourOutPoints[i][1], contourOutPoints[i][2], 1
	!!next i
	!!poly2_b{2} nsp/3, 1+2+4+8, 2, 0, 0, 0, 0, get(nsp)
	!!
	!!for i = 1 to nPolygonPoint
	!!	put contourPoints[i][1], contourPoints[i][2], 1
	!!next i
	!!poly2_b{2} nsp/3, 1+2+4+8, 2, 0, 0, 0, 0, get(nsp)
	!!
	!!for i = 1 to nUniContourPoint
	!!	put  uniContourPoint[i][1], uniContourPoint[i][2], 1
	!!next i
	!!poly2_b{2} nsp/3, 1+2+4+8, 2, 0, 0, 0, 0, get(nsp)
	
	
	
	! ==============================================================================
	!
	! Holes
	!
	! ==============================================================================
	
	numWD				= 0					! API által megadott nyilasok darabszama
	nOpeningPolygons	= 0					! kivagando poligonok szama
	bHasCornerWindow	= 0
	
	!----- Eredeti kontúr
	dim origOpeningPoligons[][3]			! kivagando nyilasok nyers merete - utolso cella +/-1 statusz
	dim tempOrigOpeningPoligons[][3]		! optimalizalas nelkul
	dim origOpeningStartEnd[][2]			! az egyes kivagando poligonok elso es utolso sarokpontjainak szama
	dim tempOrigOpeningStartEnd[][2]		! optimalizalas nelkul
	dim origOpeningBoundingBox[][4]			! kiindulo nyilasok befoglalo dobozanak koordinatai
											! [1] - nyilas bal oldala
											! [2] - nyilas alja
											! [3] - nyilas jobb oldala
											! [4] - nyilas teteje
	dim origOpeningHoles[][]				! origOpeningBoundingBox rendezve x-re
	dim openingOrigSize[][2]				! kiindulo nyilasok befoglalo dobozanak méretei
											! [1] - nyilasok szelessege
											! [2] - nyilasok magassaga
	dim origOpeningForms[]
	dim origOpeningDirections[]

	!Hülye param script miatt
	origOpeningPoligons[1][1]		= 0
	origOpeningPoligons[1][2]		= 0
	origOpeningPoligons[1][3]		= 0
	origOpeningStartEnd[1][1]		= 0
	origOpeningStartEnd[1][2]		= 0
	origOpeningBoundingBox[1][1]	= 0
	origOpeningBoundingBox[1][2]	= 0
	origOpeningBoundingBox[1][3]	= 0
	origOpeningBoundingBox[1][4]	= 0
	origOpeningHoles[1][1]			= 0
	origOpeningHoles[1][2]			= 0
	openingOrigSize[1][1]			= 0
	openingOrigSize[1][2]			= 0
	origOpeningForms[1]				= 0
	origOpeningDirections[1]		= 0
	
	if vardim2(ac_wd_poly)>2 then
		numWD = vardim1(ac_wd_poly)
	
		ch = INITADDONSCOPE ("PolyOperations", "", "")
	
		nDestContainer = 1
		prevSourceContainer	= "mySourceContainer"
		lastDestContainer	= "myDestinationContainer" + STR(nDestContainer,1,0)
	
		PREPAREFUNCTION ch, "CreateContainer", prevSourceContainer, ""
		PREPAREFUNCTION ch, "CreateContainer", lastDestContainer, ""
	
		PREPAREFUNCTION ch, "SetSourceContainer",		prevSourceContainer, ""
		PREPAREFUNCTION ch, "SetDestinationContainer",	lastDestContainer, ""

	
	! ------------------------------------------------------------------------------
	! Contour polygon
	! ------------------------------------------------------------------------------
		dim vertArr[][]
		dim contArr[]
	
		nVertices	= 4
		contArr[1]	= 5
		nContour	= 1
	
		vertArr[1][1] = surfaceXmin-cutOffset
		vertArr[1][2] = surfaceYmin-cutOffset
		vertArr[1][3] = 0.0
		vertArr[2][1] = surfaceXmax+cutOffset
		vertArr[2][2] = surfaceYmin-cutOffset
		vertArr[2][3] = 0.0
		vertArr[3][1] = surfaceXmax+cutOffset
		vertArr[3][2] = surfaceYmax+cutOffset
		vertArr[3][3] = 0.0
		vertArr[4][1] = surfaceXmin-cutOffset
		vertArr[4][2] = surfaceYmax+cutOffset
		vertArr[4][3] = 0.0
	
		PREPAREFUNCTION ch, "Store", "contourAll", nVertices, nContour, vertArr, contArr
	
		dim holeNames[]
		for i = 1 to numWD
			nHoleContourPoints = INT((ac_wd_poly[i][1]+1/32")/1")
			if nHoleContourPoints > 2 then
				dim actVertArr[][3]
				nActContour = 1		
		
				k = 1
				for j = 2 to nHoleContourPoints * 2 step 2
					if abs(ac_wd_poly[i][j]-boundingRef[1][1]) < EPS & abs(cutAngle01) > EPS then		!!Sarokablak ball
						actVertArr[k][1]	= surfaceXmin - BIGEPS
						bHasCornerWindow	= 1
					else
						if abs(ac_wd_poly[i][j]-boundingRef[1][3]) < EPS & abs(cutAngle02) > EPS then	!!Sarokablak jobb
							actVertArr[k][1]	= surfaceXmax + BIGEPS
							bHasCornerWindow	= 1
						else
							actVertArr[k][1] = ac_wd_poly[i][j]
						endif
					endif
					actVertArr[k][2] = ac_wd_poly[i][j+1]
					actVertArr[k][3] = 0
					k = k + 1
				next j
		
				dim actContArr[]
					actContArr[1] = nHoleContourPoints + 1
				nActVertices = nHoleContourPoints
		
				holeNames[i] = "hole" + STR(i,1,0)
		
				dim contourNames[]
				numContour = CALLFUNCTION (ch, "GetSourcePolygons", "", contourNames)
		
				PREPAREFUNCTION ch, "Store", holeNames[i], nActVertices, nActContour, actVertArr, actContArr
		
				dim tempResPolyIDArr[]
				for nC = 1 to numContour
					tempNumPoly = CALLFUNCTION(ch, contourNames[nC] + " - " + holeNames[i], "", tempResPolyIDArr)
				next nC
		
				if prevSourceContainer <> "" then
					PREPAREFUNCTION ch, "DeleteContainer",		prevSourceContainer, ""
				endif
				PREPAREFUNCTION ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				nDestContainer = nDestContainer + 1
				lastDestContainer = "myDestinationContainer" + STR(nDestContainer,1,0)
				PREPAREFUNCTION ch, "CreateContainer",			lastDestContainer, ""
				PREPAREFUNCTION ch, "SetDestinationContainer",	lastDestContainer, ""
			endif
		next i
	
		
		! ------------------------------------------------------------------------------
		! Cutted Contours
		! ------------------------------------------------------------------------------
	
		! ezek a megvagdosott poligonok, azt kellene kivonni az eredeti konturbol, hogy a vagotestek konturjai alakuljanak ki
		dim contourNames[]
		numContour = CALLFUNCTION (ch, "GetSourcePolygons", "", contourNames)
	
		!beledobjuk az eredeti konturpoligont is, hogymajd kivonjuk belole a megvagdosott poligont
		PREPAREFUNCTION ch, "Store", "contourAll", nVertices, nContour, vertArr, contArr
	
		dim tempResPolyIDArr[]
		for nC = 1 to numContour
			tempNumPoly = CALLFUNCTION(ch, "contourAll - " + contourNames[nC], "", tempResPolyIDArr)
	
			dim resPolyIDArr[]
			numPoly = CALLFUNCTION(ch, "GetDestinationPolygons", "", resPolyIDArr)
		
			for iii = 1 to numPoly
				polygonID	= resPolyIDArr[iii]
				mask		= 15
				bEdgeInfo	= 0
				gosub "getGDLpolygonFromAPI"
	
				nOpeningPolygons = nOpeningPolygons + 1
	
				origOpeningStart = vardim1(tempOrigOpeningPoligons)
				ijk = 1 
				tempOrigOpeningStartEnd[iii][1] = origOpeningStart + ijk
				for i = 1 to NSP step 3
					tempOrigOpeningPoligons[origOpeningStart + ijk][1] = get(1)
					tempOrigOpeningPoligons[origOpeningStart + ijk][2] = get(1)
					tempOrigOpeningPoligons[origOpeningStart + ijk][3] = get(1)
					tempOrigOpeningStartEnd[iii][2] = origOpeningStart + ijk
					ijk = ijk +1
				next i
			next iii
		next nC		
		
		! -- delete used containers --
		PREPAREFUNCTION ch, "DeleteContainer",		prevSourceContainer, ""
		PREPAREFUNCTION ch, "DeleteContainer",		lastDestContainer, ""
	
		CLOSEADDONSCOPE ch
	endif
	
	
	! ------------------------------------------------------------------------------
	! nyilasok konturpoligon optimalizalas - vizszintes egyenesek koztes pontjainak torlese
	! ------------------------------------------------------------------------------
	if nOpeningPolygons > 0 then
		lineIdx = 1
		for i = 1 to nOpeningPolygons
			bFirstToStore = 1
			for j = tempOrigOpeningStartEnd[i][1] to tempOrigOpeningStartEnd[i][2] - 1
				bInline = 0
				if j = tempOrigOpeningStartEnd[i][1] then		! elso poligonpont
					if abs(tempOrigOpeningPoligons[j][2] - tempOrigOpeningPoligons[j+1][2]) < EPS & \
						abs(tempOrigOpeningPoligons[j][2] - tempOrigOpeningPoligons[tempOrigOpeningStartEnd[i][2]-1][2]) < EPS then bInline = 1
				else
					if abs(tempOrigOpeningPoligons[j][2] - tempOrigOpeningPoligons[j+1][2]) < EPS & \
						abs(tempOrigOpeningPoligons[j][2] - tempOrigOpeningPoligons[j-1][2]) < EPS then bInline = 1
				endif
	
				if not(bInline) then
					put tempOrigOpeningPoligons[j][1], tempOrigOpeningPoligons[j][2], tempOrigOpeningPoligons[j][3]
					if bFirstToStore then
						firstX = tempOrigOpeningPoligons[j][1]
						firstY = tempOrigOpeningPoligons[j][2]
						bFirstToStore = 0
					endif
				endif
			next j
			put firstX, firstY, -1
	
			origOpeningStartEnd[i][1] = lineIdx
			for j = 1 to NSP step 3
				origOpeningPoligons[lineIdx][1] = get(1)
				origOpeningPoligons[lineIdx][2] = get(1)
				origOpeningPoligons[lineIdx][3] = get(1)
	
				lineIdx = lineIdx + 1
			next j
			origOpeningStartEnd[i][2] = lineIdx - 1
		next i
	
	
		! ------------------------------------------------------------------------------
		! orig poligon bounding box
		! ------------------------------------------------------------------------------
	
		for i = nOpeningPolygons to 1 step -1
			for j = origOpeningStartEnd[i][1] to origOpeningStartEnd[i][2]
				put origOpeningPoligons[j][1]
			next j
	
			origOpeningBoundingBox[i][1] = min(use(NSP))
			origOpeningBoundingBox[i][3] = max(get(NSP))
	
			for j = origOpeningStartEnd[i][1] to origOpeningStartEnd[i][2]
				put origOpeningPoligons[j][2]
			next j
	
			origOpeningBoundingBox[i][2] = min(use(NSP))
			origOpeningBoundingBox[i][4] = max(get(NSP))
	
			openingOrigSize[i][1]	= origOpeningBoundingBox[i][3] - origOpeningBoundingBox[i][1]
			openingOrigSize[i][2]	= origOpeningBoundingBox[i][4] - origOpeningBoundingBox[i][2]
		next i
	
	
		! ----------------------------------------
		! Organize the holes into cumulative order
		! ----------------------------------------
		dim tempOrig[][]
	
		tempOrig		= origOpeningBoundingBox
	
		for z=1 to nOpeningPolygons
			i=1
			p=1
			repeat
				if tempOrig[i][1] <= tempOrig[p][1] then
					p=p+1
				else
					p=i
					i=i+1
				endif
			until p>nOpeningPolygons
	
			origOpeningHoles[z]			= tempOrig[i]
	
			tempOrig[i][1]=ac_wall_length
			tempOrig[i][2]=0
			tempOrig[i][3]=0
			tempOrig[i][4]=0
		next z
	endif


	! ------------------------------------------------------------------------------
	! Window Borders
	! ------------------------------------------------------------------------------
	dim doorAngleBorder[]
	dim iDoorBorder[]

	!Hülye parameter script miatt
	doorAngleBorder[1]	= 0
	iDoorBorder[1]		= 0

	for i = 1 to nOpeningPolygons
		for j = origOpeningStartEnd[i][1] to origOpeningStartEnd[i][2]-1
	
			vx =  origOpeningPoligons[j+1][1] - origOpeningPoligons[j][1]
			vy =  origOpeningPoligons[j+1][2] - origOpeningPoligons[j][2]
			gosub "directionAngle"
			doorAngleBorder[j] = angle
		
			if abs(vx) < EPS then					! Függöleges
				iDoorBorder[j] = BORDERDOOR_VERT
			else
				if ABS(vy) < EPS then				! Vízszintes
					iDoorBorder[j] = BORDERDOOR_HOR
				else								! Ferde
					iDoorBorder[j] = BORDERDOOR_SLANT
				endif
			endif
		next j

		gosub "checkOpeningForm"
	next i
endif


! ==============================================================================
!
! Beams Types
!
! ==============================================================================
nBeams = vardim1(iBeamFamilys)
!---- Enlarge Arrays -------------
for i = nBeams + 1 to nOpeningPolygons
	iBeamFamilys[i]			= BEAM_FAMILY_AUTO
	beamAngles[i]			= 0.0
	customBeamOverlaps[i]	= defBeamOverlap
	customBeamHeights[i]	= defBeamHeight
	parameters	iBeamFamilys[i]			= iBeamFamilys[i],
				beamAngles[i]			= beamAngles[i],
				customBeamOverlaps[i]	= customBeamOverlaps[i],
				customBeamHeights[i]	= customBeamHeights[i]
next i

if	not(bFoundBeamFam)					|\
	iPrevBeamFamily <> iBeamFamily 		|\
	GLOB_MODPAR_NAME = "iLang" 			|\
	GLOB_MODPAR_NAME = "iFamily" 		|\
	GLOB_MODPAR_NAME = "iProductType" 	|\
	GLOB_MODPAR_NAME = "iThickness"		\
then
	if not(bFoundBeamFam) then
		if nBeamParameters then
			idxBeamFamily	= beamParametersArrayIdxs[1]
			iBeamFamily		= beamParametersArray[1]
			parameters iBeamFamily = iBeamFamily
		else
			idxBeamFamily	= 0
			iBeamFamily		= 0
		endif
	endif
	for i = 1 to nOpeningPolygons
		if	iBeamFamilys[i] <> BEAM_FAMILY_AUTO		&\
			iBeamFamilys[i] <> BEAM_FAMILY_NONE		&\
			iBeamFamilys[i] <> BEAM_FAMILY_CUSTOM	\
		then
			iBeamFamilys[i] = iBeamFamily
		endif
	next i
	parameters iBeamFamilys = iBeamFamilys
endif


!Kézzel választható típusok
dim iBManual[]
for i = 2 + vardim1(beamParametersArray) to 3 step -1
	iBManual[i] = beamParametersArray[i-2]
next i
iBManual[2] = BEAM_FAMILY_CUSTOM
iBManual[1] = BEAM_FAMILY_AUTO
nBtype		= vardim1(iBManual)
aBAnle		= 360 / nBtype
if GLOB_MODPAR_NAME = "beamAngles" then
	for i = 1 to nOpeningPolygons
		iBeamFamilys[i]	= BEAM_FAMILY_AUTO
		anglePrev		= 0
		lastAngle		= 0
		for j = 2 to nBtype
			curAngle = anglePrev + aBAnle
			if beamAngles[i] > anglePrev + aBAnle/2 then
				iBeamFamilys[i]	= iBManual[j]
				lastAngle		= curAngle
			endif
			anglePrev = curAngle
		next j
		if beamAngles[i] > anglePrev + aBAnle/2 then
			lastAngle		= 0
			iBeamFamilys[i]	= BEAM_FAMILY_AUTO
		endif
		beamAngles[i]				= lastAngle
		parameters beamAngles[i]	= beamAngles[i]
	next i

	parameters iBeamFamilys = iBeamFamilys
else
	for i = 1 to nOpeningPolygons
		idx = 0
		for j = 2 to nBtype
			if iBeamFamilys[i] = iBManual[j] then
				idx = j
				j = nBtype
			endif
		next j
		if not(idx) then
			idx				= 1
			iBeamFamilys[i]	= BEAM_FAMILY_AUTO
		endif

		beamAngles[i] = (idx-1) * aBAnle
	next i
	parameters beamAngles = beamAngles
endif

!-------- Beam Family Indexes ---------------
dim iBeamFamilysIdxs[]
for i = nOpeningPolygons to 1 step -1
	inputBeamFam = iBeamFamilys[i]
	gosub "findBeamFamilyIdx"
	iBeamFamilysIdxs[i] = resIdx
next i


!-------- BeamStrings ---------------
dim beamStrings[]
beamStrings[1] = ""
gosub "getLocString"
for i = nOpeningPolygons to 1 step -1
	if iBeamFamilysIdxs[i] > 0 then
		beamStrings[i] = datProdBeamName[iBeamFamilysIdxs[i]] 
	else
		beamStrings[i] = ""
		if iBeamFamilys[i] = BEAM_FAMILY_AUTO then
			beamStrings[i] = beamLocAuto
		endif
		if iBeamFamilys[i] = BEAM_FAMILY_NONE then
			beamStrings[i] = beamLocNone
		endif
		if iBeamFamilys[i] = BEAM_FAMILY_CUSTOM then
			beamStrings[i] = beamLocCustom
		endif
	endif
next i
parameters beamStrings = beamStrings

!-------- Beam ---------------
beamSideGroutThk	= 0.001		! TODO
if idxBeamFamily > 0 then
	beamGroutThk	= datProdBeamGroutBottom[idxBeamFamily]
	beamTopGroutThk	= datProdBeamGroutTop[idxBeamFamily]
else
	beamGroutThk	= groutHorizontal / 2
	beamTopGroutThk	= groutHorizontal / 2
endif



! ==============================================================================
!
! T wall connections
!
! ==============================================================================
tDefDir		= brickThk
tDefPosOut	= -0.7
tDefPos		= 0.4
tDefThk		= brickThk
tDefMinH	= surfaceYmin
tDefMaxH	= surfaceYmax
tDefAngle	= 90

firstFreePosT	= 0
dim tValidConnIdxS[]
dim tConnAngles[][3]	!(1) main (2) Left, (3)Right
dim tConnBox[][4]		!
dim tConnDir[]
if tConnections then
	idx = 0
	for i = 1 to nConnTParam
		if tConnWallPos[i] > surfaceXmin & tConnWallPos[i] < surfaceXmax & tConnWallThk[i] > EPS then
			idx					= idx + 1
			tValidConnIdxS[idx]	= i
		else
			if firstFreePosT = 0 then
				firstFreePosT = i
			endif
	
			tConnWallDir[i]		= tDefDir
			tConnWallPos[i]		= tDefPosOut
			tConnWallThk[i]		= tDefThk
			tConnWallHmin[i]	= tDefMinH
			tConnWallHmax[i]	= tDefMaxH
			tConnWallAngle[i]	= tDefAngle
	
			parameters	tConnWallDir[i]		= tConnWallDir[i],
						tConnWallPos[i]		= tConnWallPos[i],
						tConnWallThk[i]		= tConnWallThk[i],
						tConnWallHmin[i]	= tConnWallHmin[i],
						tConnWallHmax[i]	= tConnWallHmax[i],
						tConnWallAngle[i]	= tConnWallAngle[i]
		endif
	next i
	gosub "sortTConn"
	
	if firstFreePosT = 0 then
		firstFreePosT = nConnTParam+1
	
		tConnWallDir[nConnTParam+1]		= tDefDir
		tConnWallPos[nConnTParam+1]		= tDefPosOut
		tConnWallThk[nConnTParam+1]		= tDefThk
		tConnWallHmin[nConnTParam+1]	= tDefMinH
		tConnWallHmax[nConnTParam+1]	= tDefMaxH
		tConnWallAngle[nConnTParam+1]	= tDefAngle
	
		parameters	tConnWallDir	= tConnWallDir,
					tConnWallPos	= tConnWallPos,
					tConnWallThk	= tConnWallThk,
					tConnWallHmin	= tConnWallHmin,
					tConnWallHmax	= tConnWallHmax,
					tConnWallAngle	= tConnWallAngle
	endif

	!Fill final array
	nTwallConn = vardim1(tValidConnIdxS)
	for i = nTwallConn to 1 step -1
		idx = tValidConnIdxS[i]
		!!if ac_refside then
			tConnDir[i]	= CONN_OTHER_SIDE
			if tConnWallDir[idx] > EPS then
				tConnDir[i]	= CONN_REF_SIDE
			endif
		!!else
		!!	tConnDir[i]	= CONN_REF_SIDE
		!!	if tConnWallDir[idx] > EPS then
		!!		tConnDir[i]	= CONN_OTHER_SIDE
		!!	endif
		!!endif
		tConnAngles[i][1]	= tConnWallAngle[idx]
		tConnAngles[i][2]	= 90 - tConnWallAngle[idx]/2
		tConnAngles[i][3]	= -tConnWallAngle[idx]/2
		w = tConnWallThk[idx] / sin(tConnWallAngle[idx])
		tConnBox[i][1]		= tConnWallPos[idx] - w/2
		tConnBox[i][3]		= tConnWallPos[idx] + w/2
		tConnBox[i][2]		= tConnWallHmin[idx]
		tConnBox[i][4]		= tConnWallHmax[idx]
	next i
else
	nTwallConn		= vardim1(tValidConnIdxS)
	if firstFreePosT = 0 then firstFreePosT = 1
endif



! ==============================================================================
!
! Colum element
!
! ==============================================================================
cDefPosOut	= -1.0
cDefPos		= 0.1

firstFreePosC	= 0
dim cValidConnIdxS[]
if bColPos & elemColumn > 0 then
	idx = 0
	for i = 1 to nColumnParam
		if colPosX[i] > surfaceXmin & colPosX[i] < surfaceXmax then
			idx					= idx + 1
			cValidConnIdxS[idx]	= i
		else
			if firstFreePosC = 0 then
				firstFreePosC = i
			endif
	
			colPosX[i] = cDefPosOut
	
			parameters	colPosX[i] = colPosX[i]
		endif
	next i
	gosub "sortCConn"
	
	if firstFreePosC = 0 then
		firstFreePosC			= nColumnParam+1
		colPosX[nColumnParam+1]	= tDefPosOut
	
		parameters	colPosX	= colPosX
	endif
else
	if firstFreePosC = 0 then firstFreePosC = 1
endif
nColConn = vardim1(cValidConnIdxS)


! ==============================================================================
!
! Bricks
!
! ==============================================================================
dim avaStartRowHeight[4]
	avaStartRowHeight[1] = 0.000
	avaStartRowHeight[2] = 0.100
	avaStartRowHeight[3] = 0.125
	avaStartRowHeight[4] = 0.250

gosub "CheckContourIsRectange"
disableStartBrickHeight  = 0!	bRefContourIsRectangle 
if brickHeight > 0.250 then disableStartBrickHeight  = 1

if bResetBrick then
	! ==============================================================================
	!
	! Number of Rows
	!
	! ==============================================================================
	dim rowHeights[][2]	!(1) height, (2)bottom
	dim rowTypes[]		!ROWTYPE_UNKNOWN, ROWTYPE_NORMAL, ROWTYPE_HALF, ROWTYPE_CUTTED

	numRow	= int((surfaceY-groutBase-topSpace) / rowHeight)
	rest	= surfaceY - groutBase - numRow * rowHeight
	calculatedStartBrickHeight = 0.0

	if brickHeight <= 0.25 then
		if rest > 0.1 then
			if rest-BIGEPSEPS > 0.100 then calculatedStartBrickHeight = 0.100
			if rest-BIGEPSEPS > 0.125 then calculatedStartBrickHeight = 0.125
			if rest-BIGEPSEPS > 0.250 then calculatedStartBrickHeight = 0.250
		endif
	endif

	if disableStartBrickHeight | bAutoStartBrick then
		bottomH = calculatedStartBrickHeight
		iStartBrickHeight = 0
		nAva = vardim1(avaStartRowHeight)
		for i = 1 to nAva
			if abs(bottomH - avaStartRowHeight[i]) < EPS then
				iStartBrickHeight	= i - 1
				i					= nAva
			endif
		next i
		parameters iStartBrickHeight = iStartBrickHeight
	else
		bottomH = avaStartRowHeight[iStartBrickHeight+1]
	endif

    topH = rest - bottomH
    if topH < 0.02 then topH = 0.0

	offset	= groutBase
	n		= 0
	if bottomH > EPS then
		n					= n + 1
		rowHeights[n][1]	= bottomH
		rowHeights[n][2]	= offset
		rowTypes[n]			= ROWTYPE_NORMAL
		if rowHeights[n][1] - baseMortarThk < brickHeight - EPS then
			!TODO megnézni hogy félelem kell e
			rowTypes[n]		= ROWTYPE_CUTTED
		endif
		offset = offset + rowHeights[n][1]
	endif
	
	nn = 0
	while nn < numRow do
		n					= n + 1
		rowHeights[n][1]	= rowHeight
		rowHeights[n][2]	= offset
		rowTypes[n]			= ROWTYPE_NORMAL
		offset				= offset + rowHeights[n][1]
		nn					= nn + 1
	endwhile
	
	if topH > EPS then
		n					= n + 1
		rowHeights[n][1]	= topH
		rowHeights[n][2]	= offset
		rowTypes[n]			= ROWTYPE_NORMAL
		if rowHeights[n][1] - groutHorizontal < brickHeight - EPS then
			! TODO megnézni hogy félelem kell e
			rowTypes[n]	= ROWTYPE_CUTTED
		endif
		offset = offset + rowHeights[n][1]
	endif

	nMagPoint = vardim1(rowHeights)

	
	
	! ==============================================================================
	!
	! Áthidalók Számolása
	!
	! ==============================================================================
	nLinder					= 0
	dim linderCoords[][6]	!(1)centerPos, (2)y, (3)length, (4)height, (5)opening size, (6)overhang
	dim linderTypes[][9]	!(1)iBeamFamily, (2)iBeamFamilyIdx, (3)iBeamID, (4)iBeamIdx,  (5)iBeamTyp, (6)multiIdx, (7)overLapped, (8)overSized, (9)posError

	!Hülye param script miatt
	linderCoords[1][1]	= 0
	linderCoords[1][2]	= 0
	linderCoords[1][3]	= 0
	linderCoords[1][4]	= 0
	linderCoords[1][5]	= 0
	linderCoords[1][6]	= 0
	linderTypes[1][1]	= 0
	linderTypes[1][2]	= 0
	linderTypes[1][3]	= 0
	linderTypes[1][4]	= 0
	linderTypes[1][5]	= 0
	linderTypes[1][6]	= 0
	linderTypes[1][7]	= 0
	linderTypes[1][8]	= 0
	linderTypes[1][9]	= 0

	! ------------------------------------------------------------------------------
	! Áthidalok számolása
	! ------------------------------------------------------------------------------
!print "iBeamFamilys", iBeamFamilys
	for i = 1 to nOpeningPolygons
		if origOpeningBoundingBox[i][4] < surfaceYmax - BIGEPSCM then	!Nem mehet bele a felső részbe
			if openingOrigSize[i][1] > beamMinHoleWidth then
				dim bCoords[6]	!(1)centerPos, (2)y, (3)length, (4)height, (5)opening size, (6)overhang
				dim bTypes[9]	!(1)iBeamFamily, (2)iBeamFamilyIdx, (3)iBeamID, (4)iBeamIdx,  (5)iBeamTyp, (6)multiIdx, (7)overLapped, (8)overSized, (9)posError

				if iBeamFamilys[i] = BEAM_FAMILY_AUTO & iBeamFamily > BEAM_FAMILY_NONE then
!print i, "auto", idxBeamFamily
					_beamPreferFamily		= iBeamFamily
					_beamPreferFamilyIdx	= idxBeamFamily
					if idxBeamFamily > 0 then
						_beamPreferType			= datProdBeamType[idxBeamFamily]
						iBeamTyp				= datProdBeamType[idxBeamFamily]
					else
						_beamPreferType		= BEAM_TYP_NONE
						iBeamTyp			= BEAM_TYP_NONE
!print "fam", (defaultBeamFam  = BEAM_FAMILY_CUSTOM)
						if defaultBeamFam  = BEAM_FAMILY_CUSTOM then
							_beamPreferType		= BEAM_TYP_CUSTOM
							iBeamTyp			= BEAM_TYP_CUSTOM
						endif
					endif
				else
					_beamPreferFamily		= iBeamFamilys[i]
					_beamPreferFamilyIdx	= iBeamFamilysIdxs[i]
					if iBeamFamilysIdxs[i] > 0 then
						_beamPreferType		= datProdBeamType[iBeamFamilysIdxs[i]] 
						iBeamTyp			= datProdBeamType[iBeamFamilysIdxs[i]] 
!print i, "idx > 0", iBeamFamilys[i], iBeamTyp
					else
!print "ide", iBeamFamilys[i], iBeamFamilysIdxs[i]
						if 	iBeamFamilys[i] = BEAM_FAMILY_NONE	|\
							iBeamFamilys[i] = BEAM_FAMILY_AUTO	\
						then
!print "none"
							_beamPreferType		= BEAM_TYP_NONE
							iBeamTyp			= BEAM_TYP_NONE
						endif
						if iBeamFamilys[i] = BEAM_FAMILY_CUSTOM then
!print "custom"
							_beamPreferType		= BEAM_TYP_CUSTOM
							iBeamTyp			= BEAM_TYP_CUSTOM
						endif
					endif
				endif

				openIdx			= i
				bCenterPosX		= origOpeningBoundingBox[i][1] + openingOrigSize[i][1]/2
				bCenterPosY		= origOpeningBoundingBox[i][4]
				bOpeningSizeX	= openingOrigSize[i][1]
				bOverhang		= customBeamOverlaps[i]
				bHeight			= customBeamHeights[i]

!print i, "preferek", "_beamPreferFamily", _beamPreferFamily, "_beamPreferFamilyIdx", _beamPreferFamilyIdx, "_beamPreferType", _beamPreferType, "iBeamTyp", iBeamTyp
				gosub "BeamSelector"

!print i, "found", bFoundBeam, bTypes
				if bFoundBeam then
!print i, "be"
					nLinder						= nLinder + 1
					linderTypes[nLinder][1]		= bTypes[1]
					linderTypes[nLinder][2]		= bTypes[2]
					linderTypes[nLinder][3]		= bTypes[3]
					linderTypes[nLinder][4]		= bTypes[4]
					linderTypes[nLinder][5]		= bTypes[5]
					linderTypes[nLinder][6]		= bTypes[6]
					linderTypes[nLinder][7]		= bTypes[7]
					linderTypes[nLinder][8]		= bTypes[8]
					linderTypes[nLinder][9]		= bTypes[9]
					linderCoords[nLinder][1]	= bCoords[1]
					linderCoords[nLinder][2]	= bCoords[2]
					linderCoords[nLinder][3]	= bCoords[3]
					linderCoords[nLinder][4]	= bCoords[4]
					linderCoords[nLinder][5]	= bCoords[5]
					linderCoords[nLinder][6]	= bCoords[6]
				endif
			endif
		endif
	next i


	! ------------------------------------------------------------------------------
	! Áthidalok magasságának igazitása a sorokhoz
	! ------------------------------------------------------------------------------
	for n = 1 to nMagPoint
		currentMag = surfaceYmin + rowHeights[n][2]
		for i = 1 to nLinder
			if abs(linderCoords[i][LINDER_CENTER_Y] - currentMag) < 4*BIGEPSCM & linderCoords[i][LINDER_CENTER_Y] < currentMag+BIGEPSCM then
				!!Igazitjuk a sorhoz
				linderCoords[i][LINDER_CENTER_Y] 	= currentMag !+ beamGroutThk
			else
				if abs(linderCoords[i][LINDER_CENTER_Y] + linderCoords[i][LINDER_HEIGHT] - currentMag) < 2*BIGEPSCM then
					linderCoords[i][LINDER_CENTER_Y] 	= currentMag - linderCoords[i][LINDER_HEIGHT] - groutHorizontal
				else
					if elemHalf > 0 then
						if abs(linderCoords[i][LINDER_CENTER_Y] - (currentMag+halfElemHeight+beamGroutThk)) < BIGEPSCM then
							!!Igazitjuk a félsorhoz
							linderCoords[i][LINDER_CENTER_Y] 	= currentMag+halfElemHeight+beamGroutThk
						endif
					endif
				endif
			endif
		next i
	next n


	! ------------------------------------------------------------------------------
	! Áthidalok összevonásának vizsgálata
	! ------------------------------------------------------------------------------
	nLinderUnified			= 0
	dim unifiedLinderTypes[][9], unifiedLinderCoords[][6]	!tengely X, y, length, height, opening size, overhang
	dim unifiedLinderNums[]		!Hány gerenda van benne
	dim unifiedLinderIdxs[][]	!Összevont gerendák indexei

	!Hülye param script miatt
	unifiedLinderTypes[1][1]		= 0
	unifiedLinderTypes[1][2]		= 0
	unifiedLinderTypes[1][3]		= 0
	unifiedLinderTypes[1][4]		= 0
	unifiedLinderTypes[1][5]		= 0
	unifiedLinderTypes[1][6]		= 0
	unifiedLinderTypes[1][7]		= 0
	unifiedLinderTypes[1][8]		= 0
	unifiedLinderTypes[1][9]		= 0
	unifiedLinderCoords[1][1]		= 0
	unifiedLinderCoords[1][2]		= 0
	unifiedLinderCoords[1][3]		= 0
	unifiedLinderCoords[1][4]		= 0
	unifiedLinderCoords[1][5]		= 0
	unifiedLinderCoords[1][6]		= 0
	unifiedLinderNums[1]			= 0
	unifiedLinderIdxs[1][1]			= 0
	unifiedLinderIdxs[1][2]			= 0
!print "uniCalc", nLinder, nLinderUnified, "ide", linderTypes
	if nLinder > 1 then
		!Gerendatípusok rendezése azonos tipusokra
		dim nTypeBeams[]		!Hány elem van a tömbben
		dim typeBeams[][]		!a tömb elemeinek indexe
		for i = BEAM_FAMILY_MAX to 1 step -1	!Alap tömb létrehozása
			nTypeBeams[i]	= 0
			typeBeams[i][1] = 0
			typeBeams[i][2] = 0
		next i
		for i = 1 to nLinder
			idx	= linderTypes[i][LINDER_FAMILY_IDX]
			if idx > 0 then
				nTypeBeams[idx]					= nTypeBeams[idx] + 1
				typeBeams[idx][nTypeBeams[idx]] 	= i
			else
!print "linder", i
				nLinderUnified							= nLinderUnified + 1
				unifiedLinderTypes[nLinderUnified]		= linderTypes[i]
				unifiedLinderCoords[nLinderUnified]		= linderCoords[i]
				unifiedLinderNums[nLinderUnified] 		= 1
				unifiedLinderIdxs[nLinderUnified][1]	= i
			endif
		next i

		!Most sortoljuk Y-re az egy magasságon lévő gerendákat
		n =  0 
		for k = 1 to BEAM_FAMILY_MAX
			if nTypeBeams[k] > 0 then
				!BeamHeight sort
				dim unsortedCoords2[][2], yHeightSort[][], nHeightSort[]
				for i = nTypeBeams[k] to 1 step -1 
					idx						= typeBeams[k][i]
					unsortedCoords2[i][1]	= linderCoords[idx][LINDER_HEIGHT]
					unsortedCoords2[i][2]	= idx
				next i
				gosub "insertionSort2"
				nH					= 1
				nHeightSort[1]		= 1
				yHeightSort[1][1]	= unsortedCoords2[1][2]
				for yh = 2 to nTypeBeams[k]
					idx		= unsortedCoords2[yh][2]
					idxPre	= unsortedCoords2[yh-1][2]
					if abs(linderCoords[idxPre][LINDER_HEIGHT] - linderCoords[idx][LINDER_HEIGHT]) > EPS then
						nH					= nH + 1
						nHeightSort[nH]		= 1
						yHeightSort[nH][1]	= idx
					else
						nHeightSort[nH]						= nHeightSort[nH] + 1
						yHeightSort[nH][nHeightSort[nH]] 	= idx
					endif
				next yh


				!Azonos magasságú gerendák y-ra rendezése
				for yH = 1 to nH
					dim unsortedCoords2[][2]
					for i = nHeightSort[yH] to 1 step -1
						idx						= yHeightSort[yH][i]
						unsortedCoords2[i][1]	= linderCoords[i][LINDER_CENTER_Y]
						unsortedCoords2[i][2]	= idx
					next i
					gosub "insertionSort2"
				
					!A kapott indexeket berakjuk a tömmbe
					for i = nHeightSort[yH] to 1 step -1
						yHeightSort[yH][i] = unsortedCoords2[i][2]
					next i
				next yH

				!Sortolás a magasságra
				for yH = 1 to nH
					dim tBeamsIdx[]
					idxB			= yHeightSort[yH][1]
					n				= 1
					tBeamsIdx[n]	= idxB

					for i = 2 to nHeightSort[yH]
						idxC	= yHeightSort[yH][i]
						idxPre	= yHeightSort[yH][i-1]
						if abs(linderCoords[idxPre][LINDER_CENTER_Y] - linderCoords[idxC][LINDER_CENTER_Y]) > EPS then
							!Na most sortoljuk az eddigi adatokat
							gosub "beamOsszevono"
			
							!Reseteljuk a tömböt
							dim tBeamsIdx[]
							n				= 1
							tBeamsIdx[n]	= idxC
						else
							n				= n + 1
							tBeamsIdx[n]	= idxC
						endif
					next i
			
					!Ide a végére kell egy záróakkord
					gosub "beamOsszevono"
				next yH
			endif
		next k
	else
!print "be", nLinder
		unifiedLinderCoords	= linderCoords
		unifiedLinderTypes	= linderTypes
		nLinderUnified		= nLinder
		if nLinder = 1 then
			unifiedLinderNums[1] 	= 1
			unifiedLinderIdxs[1][1]	= 1
		endif
	endif


	! ------------------------------------------------------------------------------
	! Áthidalok összevonása
	! ------------------------------------------------------------------------------
	nLinderUsed			= 0
	dim usedLinderTypes[][9], usedLinderCoords[][6]	!tengely X, y, length, height, opening size, overhang
	dim usedLinderNums[]	!Hány gerenda van benne
	dim usedLinderIdxs[][]	!Összevont gerendák indexei
	dim usedLinderPosOrig[]	!Az eredeti poziciok helye

	!Most egyszerűsitunk
	nLinderUsed			= nLinderUnified
	usedLinderTypes		= unifiedLinderTypes
	usedLinderCoords	= unifiedLinderCoords
	usedLinderNums		= unifiedLinderNums
	usedLinderIdxs		= unifiedLinderIdxs


	gosub "beamWallCheck"
	gosub "beamWindowCheck"
	bOverlapReset = 0
	gosub "beamOverLappingCheck"	!False
	gosub "beamOverLappingMove"
	bOverlapReset = 1
	gosub "beamOverLappingCheck"	!True
	gosub "beamOverSizeCheck"
	gosub "beamErrorsCheck"

	! ------------------------------------------------------------------------------
	! Áthidalok összevonása (csak a geometriai részek) a gerendát nem vonja össze
	! ------------------------------------------------------------------------------
	nLinderGeomUnified		= 0
	dim unifiedGeomLinderCoords[][6]	!tengely X, y, length, height, opening size

	!Hülye param script miatt
	unifiedGeomLinderCoords[1][1]	= 0
	unifiedGeomLinderCoords[1][2]	= 0
	unifiedGeomLinderCoords[1][3]	= 0
	unifiedGeomLinderCoords[1][4]	= 0
	unifiedGeomLinderCoords[1][5]	= 0
	unifiedGeomLinderCoords[1][6]	= 0

	if nLinderUsed then
		if nLinderUsed > 1 then
			!BeamHeight sort
			dim unsortedCoords2[][2], yHeightSort[][], nHeightSort[]
			for i = nLinderUsed to 1 step -1
				unsortedCoords2[i][1] = usedLinderCoords[i][LINDER_HEIGHT]
				unsortedCoords2[i][2] = i
			next i
			gosub "insertionSort2"
			nH					= 1
			nHeightSort[1]		= 1
			yHeightSort[1][1]	= unsortedCoords2[1][2]
			for yH = 2 to nLinderUsed
				idx		= unsortedCoords2[yh][2]
				idxPre	= unsortedCoords2[yh-1][2]
				if abs(usedLinderCoords[idxPre][LINDER_HEIGHT] - usedLinderCoords[idx][LINDER_HEIGHT]) > EPS then
					nH					= nH + 1
					nHeightSort[nH]		= 1
					yHeightSort[nH][1]	= idx
				else
					nHeightSort[nH]						= nHeightSort[nH] + 1
					yHeightSort[nH][nHeightSort[nH]] 	= idx
				endif
			next yh

			!Azonos magasságú gerendák y-ra rendezése
			for yH = 1 to nH
				dim unsortedCoords2[][2]
				for i = nHeightSort[yH] to 1 step-1
					idx						= yHeightSort[yH][i]
					unsortedCoords2[i][1]	= usedLinderCoords[i][LINDER_CENTER_Y]
					unsortedCoords2[i][2]	= idx
				next i
				gosub "insertionSort2"
			
				!A kapott indexeket berakjuk a tömmbe
				for i = nHeightSort[yH] to 1 step -1
					yHeightSort[yH][i] = unsortedCoords2[i][2]
				next i
			next yH

			!Sortolás a magasságra
			for yH = 1 to nH
				dim unsortedCoords2[][2]
				n = 0
				idx	= yHeightSort[yH][1]
				n = n + 1
				unsortedCoords2[n][1]	= usedLinderCoords[idx][LINDER_CENTER_X] - usedLinderCoords[idx][LINDER_LENGTH] / 2 - BEAM_UNIEPS
				unsortedCoords2[n][2]	= idx
				n = n + 1
				unsortedCoords2[n][1]	= usedLinderCoords[idx][LINDER_CENTER_X] + usedLinderCoords[idx][LINDER_LENGTH] / 2 + BEAM_UNIEPS
				unsortedCoords2[n][2]	= idx

				for i = 2 to nHeightSort[yH]
					idx		= yHeightSort[yH][i]
					idxPre	= yHeightSort[yH][i-1]
					if abs(usedLinderCoords[idxPre][LINDER_CENTER_Y] - usedLinderCoords[idx][LINDER_CENTER_Y]) > EPS then
						!Na most sortoljuk az eddigi adatokat
						gosub "insertionSort2"
						gosub "beamHoleOsszevono"
		
						!Reseteljuk a tömböt
						dim unsortedCoords2[][2]
						n	= 1
						unsortedCoords2[n][1]	= usedLinderCoords[idx][LINDER_CENTER_X] - usedLinderCoords[idx][LINDER_LENGTH] / 2 - BEAM_UNIEPS
						unsortedCoords2[n][2]	= idx
						n	= n + 1
						unsortedCoords2[n][1]	= usedLinderCoords[idx][LINDER_CENTER_X] + usedLinderCoords[idx][LINDER_LENGTH] / 2 + BEAM_UNIEPS
						unsortedCoords2[n][2]	= idx
					else
						n	= n + 1
						unsortedCoords2[n][1]	= usedLinderCoords[idx][LINDER_CENTER_X] - usedLinderCoords[idx][LINDER_LENGTH] / 2 - BEAM_UNIEPS
						unsortedCoords2[n][2]	= idx
						n	= n + 1
						unsortedCoords2[n][1]	= usedLinderCoords[idx][LINDER_CENTER_X] + usedLinderCoords[idx][LINDER_LENGTH] / 2 + BEAM_UNIEPS
						unsortedCoords2[n][2]	= idx
					endif
				next i
		
				!Ide a végére kell egy záróakkord
				gosub "insertionSort2"
				gosub "beamHoleOsszevono"
			next yH
		else
			unifiedGeomLinderCoords	= usedLinderCoords
			nLinderGeomUnified		= nLinderUsed
		endif
	endif


	! ------------------------------------------------------------------------------
	! Vertical Glue Calculation
	! ------------------------------------------------------------------------------
	nVerticalGlue = 0
	dim verticalGlue[][4]	!(1)posX, (2)posY, (3)width, (4)height

	verticalGlue[1][1]	= 0.0
	verticalGlue[1][2]	= 0.0
	verticalGlue[1][3]	= 0.0
	verticalGlue[1][4]	= 0.0

	for i = nLinderUsed to 1 step -1
		lIdx	= usedLinderTypes[i][LINDER_FAMILY_IDX]
		if lIdx > 0 then
			beamTop = usedLinderCoords[i][LINDER_CENTER_Y] + usedLinderCoords[i][LINDER_HEIGHT]
			for j = 1 to nMagPoint
				currentMag = surfaceYmin + rowHeights[j][2]
				if currentMag - BIGEPSCM < beamTop & beamTop < currentMag + rowHeights[j][1] + BIGEPS then
					if datProdBeamVerticalGlue[lIdx] = BEAM_GLUE_VERTICAL_ONE_METER then
						hDiff       = currentMag + rowHeight - beamTop
						hDiffMax    = surfaceYmax - beamTop
						if hDiff > EPS and hDiffMax > BIGEPSCM then
							nRow        					= int(ceil((1.0 - hDiff) / rowHeight))
							nVerticalGlue					= nVerticalGlue + 1
							verticalGlue[nVerticalGlue][1]	= usedLinderCoords[i][LINDER_CENTER_X]
							verticalGlue[nVerticalGlue][2]	= beamTop
							verticalGlue[nVerticalGlue][3]	= usedLinderCoords[i][LINDER_LENGTH]
							verticalGlue[nVerticalGlue][4]	= min(hDiff + nRow * rowHeight, hDiffMax)
						endif
					endif
	
					if datProdBeamVerticalGlue[lIdx] = BEAM_GLUE_VERTICAL_CUTTED_ROW then
						hDiff = currentMag + rowHeight - beamTop
						if hDiff > BIGEPSCM then
							nVerticalGlue					= nVerticalGlue + 1
							verticalGlue[nVerticalGlue][1]	= usedLinderCoords[i][LINDER_CENTER_X]
							verticalGlue[nVerticalGlue][2]	= beamTop
							verticalGlue[nVerticalGlue][3]	= usedLinderCoords[i][LINDER_LENGTH]
							verticalGlue[nVerticalGlue][4]	= hDiff
						endif
					endif
	
					j = nMagPoint
				endif
			next j
		endif
	next i


	! ==============================================================================
	!
	! Get Colums
	!
	! ==============================================================================
	iColumnStart	= COLUMN_NONE
	iColumnEnd		= COLUMN_NONE
	nMidColums		= 0
	dim iMidColumns[]

	if elemColumn > 0 then
		cornerDistance = datBrickSize[elemColumnIdx][BRICKSIZE_WIDTH]

		for i = 1 to nColumnParam
			if colPosX[i] > surfaceXmin & colPosX[i] < surfaceXmax then
				if abs(surfaceXmin - colPosX[i]) < cornerDistance/2 then
					if connWallStartIangle = ANGLE_UNKNOWN then
						iColumnStart = COLUMN_CONCRETE
					else
						if connWallStartIangle = ANGLE_PERPENDICULAR | connWallStartIangle = ANGLE_LINE then
							if abs(connWallStartThk - brickThk) < BIGEPS then
								iColumnStart = COLUMN_CONCRETE
							else
								if connWallStartThk > EPS then
									iColumnStart = COLUMN_CONCRETE_OFFSET
								else
									iColumnStart = COLUMN_CONCRETE
								endif
							endif
						endif
					endif
				else
					if abs(surfaceXmax - colPosX[i]) < cornerDistance/2 then
						if connWallEndIangle = ANGLE_UNKNOWN then
							iColumnEnd = COLUMN_CONCRETE
						else
							if connWallEndIangle = ANGLE_PERPENDICULAR | connWallEndIangle = ANGLE_LINE then
								if abs(connWallEndThk - brickThk) < BIGEPS then
									iColumnEnd = COLUMN_CONCRETE
								else
									if connWallEndThk > EPS then
										iColumnEnd = COLUMN_CONCRETE_OFFSET
									else
										iColumnEnd = COLUMN_CONCRETE
									endif
								endif
							endif
						endif
					else
						nMidColums				= nMidColums + 1
						iMidColumns[nMidColums]	= colPosX[i]
					endif
				endif
			endif
		next i
	endif


	! ==============================================================================
	!
	! Brick Sections
	!
	! ==============================================================================
	dim nRowConFill[], rowConFillMin[][], rowConFillMax[][]
	dim nRowWinFill[], rowWinFill[][], rowWinIdx[][], winRowNames[]

	ch = INITADDONSCOPE ("PolyOperations", "", "")

	nDestContainer = 1
	prevSourceContainer	= "mySourceContainer"
	lastDestContainer	= "myDestinationContainer" + STR(nDestContainer,1,0)

	PREPAREFUNCTION ch, "CreateContainer", prevSourceContainer, ""
	PREPAREFUNCTION ch, "CreateContainer", lastDestContainer, ""

	PREPAREFUNCTION ch, "SetSourceContainer",		prevSourceContainer, ""
	PREPAREFUNCTION ch, "SetDestinationContainer",	lastDestContainer, ""

	dim vertArr[][]
	dim contArr[]
	for i = nUniContourPoint-1 to 1 step -1
		vertArr[i][1] = uniContourPoint[i][1]
		vertArr[i][2] = uniContourPoint[i][2]
		vertArr[i][3] = 0
	next i
	contArr[1] = nUniContourPoint
	PREPAREFUNCTION ch, "Store", "uniContour", nUniContourPoint-1, 1, vertArr, contArr

	dim rowNames[]
	dim vertArr[][], contArr[]
	contArr[1]	= 5
	for i = nMagPoint to 1 step -1
		currentMag1		= surfaceYmin + rowHeights[i][2]
		currentMag2		= currentMag1 + rowHeights[i][1]
		rowNames[i] 	= "rows_"+str(i,1,0)
		winRowNames[i]	= "winRows_"+str(i,1,0)

		vertArr[1][1] = surfaceXmin-1
		vertArr[1][2] = currentMag1
		vertArr[1][3] = 0.0
		vertArr[2][1] = surfaceXmax+1
		vertArr[2][2] = currentMag1
		vertArr[2][3] = 0.0
		vertArr[3][1] = surfaceXmax+1
		vertArr[3][2] = currentMag2
		vertArr[3][3] = 0.0
		vertArr[4][1] = surfaceXmin-1
		vertArr[4][2] = currentMag2
		vertArr[4][3] = 0.0

		PREPAREFUNCTION ch, "Store", rowNames[i], 4, 1, vertArr, contArr

		vertArr[1][2] = currentMag1 + BIGEPSCM
		vertArr[2][2] = currentMag1 + BIGEPSCM
		vertArr[3][2] = currentMag2 - BIGEPSCM
		vertArr[4][2] = currentMag2 - BIGEPSCM
		PREPAREFUNCTION ch, "Store", winRowNames[i], 4, 1, vertArr, contArr
	next i

	!!Get Rows Sections
	for n = 1 to nMagPoint
		dim resPolyIDArr[]
		zz		= 0
		numPoly	= CALLFUNCTION(ch, "uniContour / " + rowNames[n], "", resPolyIDArr)
	
		for iii = 1 to numPoly
			polygonID	= resPolyIDArr[iii]
			gosub "getGDLpolygonMinMaxX"
			zz						= zz + 1
			rowConFillMin[n][zz]	= min(use(nsp))
			rowConFillMax[n][zz]	= max(get(nsp))
		next iii
		nRowConFill[n]	= zz
		nRowWinFill[n]	= 0
	next n
	PREPAREFUNCTION ch, "DeleteContainer", lastDestContainer, ""
	PREPAREFUNCTION ch, "CreateContainer", lastDestContainer, ""

	!! Get Windows Sections
	for i = 1 to nOpeningPolygons
		if origOpeningForms[i] = POLY_FORM_POLYGON_SLANT then
			dim vertArr[][], contArr[]
			winName		= "windows_" + str(i,1,0)
			nVert		= origOpeningStartEnd[i][2] - origOpeningStartEnd[i][1]
			contArr[1]	= nVert + 1
			zz			= 0
			for j = origOpeningStartEnd[i][2]-1 to origOpeningStartEnd[i][1] step -1
				zz				= zz + 1
				vertArr[zz][1]	= origOpeningPoligons[j][1]
				vertArr[zz][2]	= origOpeningPoligons[j][2]
				vertArr[zz][3]	= 0	
			next j
			PREPAREFUNCTION ch, "Store", winName, nVert, 1, vertArr, contArr
	
			for n = 1 to nMagPoint
				dim resPolyIDArr[]
				numPoly	= CALLFUNCTION(ch, winRowNames[n] + " - " + winName, "", resPolyIDArr)
			
				if numPoly > 1 then
					for iii = 1 to numPoly
						polygonID	= resPolyIDArr[iii]
						gosub "getGDLpolygonMinMaxX"
						minX	= min(use(nsp))
						maxX	= max(get(nsp))
						if surfaceXmin-EPS < minX &  minX < surfaceXmax+EPS then
							nRowWinFill[n]					= nRowWinFill[n] + 1
							rowWinFill[n][nRowWinFill[n]] 	= minX
							rowWinIdx[n][nRowWinFill[n]] 	= i
						endif
						if surfaceXmin-EPS < maxX &  maxX < surfaceXmax+EPS then
							nRowWinFill[n]					= nRowWinFill[n] + 1
							rowWinFill[n][nRowWinFill[n]] 	= maxX
							rowWinIdx[n][nRowWinFill[n]] 	= i
						endif
					next iii
				endif
			next n
			PREPAREFUNCTION ch, "DeleteContainer", lastDestContainer, ""
			PREPAREFUNCTION ch, "CreateContainer", lastDestContainer, ""
		endif
	next i

	PREPAREFUNCTION ch, "DeleteContainer",		prevSourceContainer, ""
	PREPAREFUNCTION ch, "DeleteContainer",		lastDestContainer, ""

	CLOSEADDONSCOPE ch


	! ==============================================================================
	!
	! Tégla Sorok Számolása
	!
	! ==============================================================================
	dim edgeSection[][]
	dim	nEdgePoint[]
	dim nEdgePoint2[]	!Csak az első pointjainak a számát tartalmazza (ha több sor van egy sorban ott fontos)
	dim edgeStatus[][]
	for i = nMagPoint to 1 step -1
		nEdgePoint[i]		= 0
		nEdgePoint2[i]		= 0
		edgeStatus[i][1]	= 0		!TODO jobb prefetch
		edgeSection[i][1]	= 0
	next i
	
	
	! ------------------------------------------------------------------------------
	! Lines Section
	! ------------------------------------------------------------------------------
	for n = 1 to nMagPoint
		currentMag = surfaceYmin + rowHeights[n][2]
	
		! ------------------------------------------------------------------------------
		! Unified Contour Section
		! ------------------------------------------------------------------------------
		for i = 1 to nRowConFill[n]
			sx		= rowConFillMin[n][i]
			sy		= currentMag
			stat	= STATUS_NONE
			if abs(sx-surfaceXmin) < EPS then
				if iCalcJointType1 = JOINT_SIDE_END			then stat = STATUS_VEG
				if iCalcJointType1 = JOINT_SIDE_PROFILE		then stat = STATUS_PROFIL
				if iCalcJointType1 = JOINT_SIDE_CORNER_1	then stat = STATUS_CSORBA_1
				if iCalcJointType1 = JOINT_SIDE_CORNER_2	then stat = STATUS_CSORBA_2
				if iCalcJointType1 = JOINT_SIDE_CORNER_T_1	then stat = STATUS_CSORBA_1
				if iCalcJointType1 = JOINT_SIDE_CORNER_T_2	then stat = STATUS_CSORBA_2
			endif

			edgeSection[n][nEdgePoint[n]*2+1]	= sx
			edgeSection[n][nEdgePoint[n]*2+2]	= sy
			edgeStatus[n][nEdgePoint[n]+1]		= stat
			nEdgePoint[n]						= nEdgePoint[n] + 1
			
			sx		= rowConFillMax[n][i]
			stat	= STATUS_NONE
			if abs(sx-surfaceXmax) < EPS then
				if iCalcJointType2 = JOINT_SIDE_END			then stat = STATUS_VEG
				if iCalcJointType2 = JOINT_SIDE_PROFILE		then stat = STATUS_PROFIL
				if iCalcJointType2 = JOINT_SIDE_CORNER_1	then stat = STATUS_CSORBA_1
				if iCalcJointType2 = JOINT_SIDE_CORNER_2	then stat = STATUS_CSORBA_2	
				if iCalcJointType2 = JOINT_SIDE_CORNER_T_1	then stat = STATUS_CSORBA_1
				if iCalcJointType2 = JOINT_SIDE_CORNER_T_2	then stat = STATUS_CSORBA_2		
			endif
			
			edgeSection[n][nEdgePoint[n]*2+1]	= sx
			edgeSection[n][nEdgePoint[n]*2+2]	= sy
			edgeStatus[n][nEdgePoint[n]+1]		= stat
			nEdgePoint[n]						= nEdgePoint[n] + 1
		next i

!!		for i = 1 to nUniContourPoint-1
!!			if iBorderUni[i] <> BORDER_TOP_HOR & iBorderUni[i] <> BORDER_BOT_HOR then
!!				yy1 = uniContourPoint[i][2]
!!				xx1	= uniContourPoint[i][1]
!!				yy2 = uniContourPoint[i+1][2]
!!				aa	= uniAngles[i]
!!	
!!				if yy1 > yy2 then
!!					xx1	= uniContourPoint[i+1][1]
!!					yy1 = uniContourPoint[i+1][2]
!!					yy2 = uniContourPoint[i][2]
!!					aa	= uniAngles[i]+180
!!				endif 
!!	
!!				!Jó magasságban van
!!				if yy1 <= currentMag & yy2 >= currentMag then
!!					! Koordináták
!!					hDiff	= currentMag - yy1
!!					sy		= currentMag
!!					if iBorderUni[i] = BORDER_VERT_UP | iBorderUni[i] = BORDER_VERT_DOWN then
!!						sx	= xx1
!!					else
!!						bFounNeedH2 = 0
!!						hD2			= 0
!!
!!						if iBorderUni[i] = BORDER_BOT_SLANT | iBorderUni[i] = BORDER_TOP_SLANT then
!!							!Szükséges az felső él vizsgálata is
!!							if n < nMagPoint then
!!								cm	= surfaceYmin + rowHeights[n+1][2] - groutHorizontal
!!								if yy1 <= cm & yy2 >= cm then
!!									hD2	= cm - yy1
!!!!									angle = aa
!!!!									gosub "angleNormalizer"
!!!!									aa = angle
!!!!print	aa, hD2
!!!!Itt point inside polygonnal vagy valamivel el kéne dönteni az irányt és azzal számolni
!!									!!bFounNeedH2 = 1
!!								else
!!									!Nincs azon az élen hanem a következőn van
!!									!TODO
!!								endif
!!							endif
!!						endif
!!
!!						if not(bFounNeedH2) then
!!							sx	= xx1 + hDiff / tan(aa)
!!						else
!!							sx	= xx1 + hD2 / tan(aa)
!!						endif
!!					endif
!!	
!!					!!Statuskodok
!!					stat = STATUS_NONE
!!					!Végélek státuszai
!!					if abs(sx-surfaceXmin) < EPS then
!!						if iCalcJointType1 = JOINT_SIDE_END			then stat = STATUS_VEG
!!						if iCalcJointType1 = JOINT_SIDE_PROFILE		then stat = STATUS_PROFIL
!!						if iCalcJointType1 = JOINT_SIDE_CORNER_1	then stat = STATUS_CSORBA_1
!!						if iCalcJointType1 = JOINT_SIDE_CORNER_2	then stat = STATUS_CSORBA_2
!!						if iCalcJointType1 = JOINT_SIDE_CORNER_T_1	then stat = STATUS_CSORBA_1
!!						if iCalcJointType1 = JOINT_SIDE_CORNER_T_2	then stat = STATUS_CSORBA_2
!!					else
!!						if abs(sx-surfaceXmax) < EPS then
!!							if iCalcJointType2 = JOINT_SIDE_END			then stat = STATUS_VEG
!!							if iCalcJointType2 = JOINT_SIDE_PROFILE		then stat = STATUS_PROFIL
!!							if iCalcJointType2 = JOINT_SIDE_CORNER_1	then stat = STATUS_CSORBA_1
!!							if iCalcJointType2 = JOINT_SIDE_CORNER_2	then stat = STATUS_CSORBA_2	
!!							if iCalcJointType2 = JOINT_SIDE_CORNER_T_1	then stat = STATUS_CSORBA_1
!!							if iCalcJointType2 = JOINT_SIDE_CORNER_T_2	then stat = STATUS_CSORBA_2		
!!						endif
!!					endif
!!					
!!					!! Metszéspont hozzáadása
!!					edgeSection[n][nEdgePoint[n]*2+1]	= sx
!!					edgeSection[n][nEdgePoint[n]*2+2]	= sy
!!					edgeStatus[n][nEdgePoint[n]+1]		= stat
!!					nEdgePoint[n]						= nEdgePoint[n] + 1
!!				endif
!!			endif
!!		next i


		! ------------------------------------------------------------------------------
		! Linder Section
		! ------------------------------------------------------------------------------
		for i = 1 to nLinderGeomUnified
			yy1 = unifiedGeomLinderCoords[i][LINDER_CENTER_Y]
			yy2 = unifiedGeomLinderCoords[i][LINDER_CENTER_Y]+unifiedGeomLinderCoords[i][LINDER_HEIGHT]
			xx1	= unifiedGeomLinderCoords[i][LINDER_CENTER_X]-unifiedGeomLinderCoords[i][LINDER_LENGTH]/2
			xx2	= unifiedGeomLinderCoords[i][LINDER_CENTER_X]+unifiedGeomLinderCoords[i][LINDER_LENGTH]/2
			if xx1 < surfaceXmin + BIGEPS then xx1 = surfaceXmin + BIGEPS
			if xx2 > surfaceXmax - BIGEPS then xx2 = surfaceXmax - BIGEPS
	
			!Jó magasságban van
			if (yy1-EPS < currentMag & yy2+EPS > currentMag) | (abs(currentmag-yy1) < BIGEPSCM) then		!Abban az esetben jó ha két sort átmetsz, vagy az alja centin belül van
				!! Metszéspont hozzáadása
				edgeSection[n][nEdgePoint[n]*2+1]	= xx1+eps
				edgeSection[n][nEdgePoint[n]*2+2]	= currentMag
				edgeStatus[n][nEdgePoint[n]+1]		= STATUS_LINDER
				nEdgePoint[n]						= nEdgePoint[n] + 1
	
				edgeSection[n][nEdgePoint[n]*2+1]	= xx2-eps
				edgeSection[n][nEdgePoint[n]*2+2]	= currentMag
				edgeStatus[n][nEdgePoint[n]+1]		= STATUS_LINDER
				nEdgePoint[n]						= nEdgePoint[n] + 1

				!-----------Csekkoljuk hogy vágunk e a felette levőbe-------------------------
				if currentMag + brickHeight - (yy2+BIGEPS) > BIGEPSCM then
					edgeSection[n][nEdgePoint[n]*2+1]	= xx1+athSpace
					edgeSection[n][nEdgePoint[n]*2+2]	= yy2 + groutHorizontal
					edgeStatus[n][nEdgePoint[n]+1]		= STATUS_ABOVE_LINDER
					nEdgePoint[n]						= nEdgePoint[n] + 1
				
					edgeSection[n][nEdgePoint[n]*2+1]	= xx2-athSpace
					edgeSection[n][nEdgePoint[n]*2+2]	= yy2 + groutHorizontal
					edgeStatus[n][nEdgePoint[n]+1]		= STATUS_ABOVE_LINDER
					nEdgePoint[n]						= nEdgePoint[n] + 1
				endif
	
				!-----------Csekkoljuk hogy vágunk e a alatta levőbe-------------------------
				if yy1 < currentMag-BIGEPS & currentMag - brickHeight < yy1 then
					if n > 1 then
						bEleje 		= 1
						bHatulja	= 1
		
						if bEleje then
							edgeSection[n-1][nEdgePoint[n-1]*2+1]	= xx1-eps
							edgeSection[n-1][nEdgePoint[n-1]*2+2]	= currentMag-rowHeight
							edgeStatus[n-1][nEdgePoint[n-1]+1]		= STATUS_UNDER_LINDER
							nEdgePoint[n-1]							= nEdgePoint[n-1] + 1
			
							edgeSection[n-1][nEdgePoint[n-1]*2+1]	= xx1+eps
							edgeSection[n-1][nEdgePoint[n-1]*2+2]	= currentMag-rowHeight
							edgeStatus[n-1][nEdgePoint[n-1]+1]		= STATUS_UNDER_LINDER
							nEdgePoint[n-1]							= nEdgePoint[n-1] + 1
						endif
		
						if bHatulja then
							edgeSection[n-1][nEdgePoint[n-1]*2+1]	= xx2+eps
							edgeSection[n-1][nEdgePoint[n-1]*2+2]	= currentMag-rowHeight
							edgeStatus[n-1][nEdgePoint[n-1]+1]		= STATUS_UNDER_LINDER
							nEdgePoint[n-1]							= nEdgePoint[n-1] + 1
			
							edgeSection[n-1][nEdgePoint[n-1]*2+1]	= xx2-eps
							edgeSection[n-1][nEdgePoint[n-1]*2+2]	= currentMag-rowHeight
							edgeStatus[n-1][nEdgePoint[n-1]+1]		= STATUS_UNDER_LINDER
							nEdgePoint[n-1]							= nEdgePoint[n-1] + 1
						endif
					endif
				endif
			else
				if yy1 > currentMag + BIGEPS & yy2 < currentMag+brickHeight+BIGEPS then   !Tegla között van az áthidaló
					bEleje 		= 1
					bHatulja	= 1
	
					if bEleje then
						edgeSection[n][nEdgePoint[n]*2+1]		= xx1-eps
						edgeSection[n][nEdgePoint[n]*2+2]		= currentMag
						edgeStatus[n][nEdgePoint[n]+1]			= STATUS_UNDER_LINDER
						nEdgePoint[n]							= nEdgePoint[n] + 1
		
						edgeSection[n][nEdgePoint[n]*2+1]		= xx1+eps
						edgeSection[n][nEdgePoint[n]*2+2]		= currentMag
						edgeStatus[n][nEdgePoint[n]+1]			= STATUS_UNDER_LINDER
						nEdgePoint[n]							= nEdgePoint[n] + 1

						if yy2 < currentMag + brickHeight-BIGEPS then
							!edgeSection[n][nEdgePoint[n]*2+1]		= xx1-eps
							!edgeSection[n][nEdgePoint[n]*2+2]		= yy2
							!edgeStatus[n][nEdgePoint[n]+1]			= STATUS_ABOVE_LINDER
							!nEdgePoint[n]							= nEdgePoint[n] + 1
			
							edgeSection[n][nEdgePoint[n]*2+1]		= xx1+eps
							edgeSection[n][nEdgePoint[n]*2+2]		= yy2
							edgeStatus[n][nEdgePoint[n]+1]			= STATUS_ABOVE_LINDER
							nEdgePoint[n]							= nEdgePoint[n] + 1
						endif
					endif

					if bHatulja then
						edgeSection[n][nEdgePoint[n]*2+1]		= xx2-eps
						edgeSection[n][nEdgePoint[n]*2+2]		= currentMag
						edgeStatus[n][nEdgePoint[n]+1]			= STATUS_UNDER_LINDER
						nEdgePoint[n]							= nEdgePoint[n] + 1
		
						edgeSection[n][nEdgePoint[n]*2+1]		= xx2+eps
						edgeSection[n][nEdgePoint[n]*2+2]		= currentMag
						edgeStatus[n][nEdgePoint[n]+1]			= STATUS_UNDER_LINDER
						nEdgePoint[n]							= nEdgePoint[n] + 1

						if yy2 < currentMag + brickHeight-BIGEPS then
							edgeSection[n][nEdgePoint[n]*2+1]		= xx2-eps
							edgeSection[n][nEdgePoint[n]*2+2]		= yy2
							edgeStatus[n][nEdgePoint[n]+1]			= STATUS_ABOVE_LINDER
							nEdgePoint[n]							= nEdgePoint[n] + 1
			
							!edgeSection[n][nEdgePoint[n]*2+1]		= xx2+eps
							!edgeSection[n][nEdgePoint[n]*2+2]		= yy2
							!edgeStatus[n][nEdgePoint[n]+1]			= STATUS_ABOVE_LINDER
							!nEdgePoint[n]							= nEdgePoint[n] + 1
						endif
					endif
				endif
			endif
		next i

		! ------------------------------------------------------------------------------
		! Window Section New
		! ------------------------------------------------------------------------------
		for i = 1 to nRowWinFill[n]
			sx		= rowWinFill[n][i]
			sy		= currentMag
			winIdx	= rowWinIdx[n][i]
			stat	= STATUS_NONE

			if origOpeningForms[winIdx] <> POLY_FORM_POLYGON_SLANT then
				for j = origOpeningStartEnd[winIdx][1] to origOpeningStartEnd[winIdx][2]-1
					if iDoorBorder[j] = BORDERDOOR_VERT then
						if abs(sx - origOpeningPoligons[j][1]) < BIGEPS then
							stat	= STATUS_DOOR
							j		= origOpeningStartEnd[winIdx][2]
						endif
					endif
				next j
			endif

			edgeSection[n][nEdgePoint[n]*2+1]	= sx
			edgeSection[n][nEdgePoint[n]*2+2]	= sy
			edgeStatus[n][nEdgePoint[n]+1]		= stat
			nEdgePoint[n]						= nEdgePoint[n] + 1
			gosub "checkSectionInPoly"
		next i

		! ------------------------------------------------------------------------------
		! Window Section Old
		! ------------------------------------------------------------------------------
		for i = 1 to nOpeningPolygons
			for j = origOpeningStartEnd[i][1] to origOpeningStartEnd[i][2]-1
				if iDoorBorder[j] <> BORDERDOOR_HOR then
					yy1 = origOpeningPoligons[j][2]
					xx1	= origOpeningPoligons[j][1]
					yy2 = origOpeningPoligons[j+1][2]
		
					aa	= doorAngleBorder[j]
					if yy1 > yy2 then
						xx1	= origOpeningPoligons[j+1][1]
						yy1 = origOpeningPoligons[j+1][2]
						yy2 = origOpeningPoligons[j][2]
						aa	= doorAngleBorder[j]+180
					endif
		
					!Jó magasságban van
					if (yy1 <= currentMag+BIGEPSCM & yy2 >= currentMag+BIGEPSCM) then	!Ablak között van
						if origOpeningForms[i] = POLY_FORM_POLYGON_SLANT then
							!Csak az ablak alján lévőket nézzűk
							if abs(currentMag - origOpeningBoundingBox[i][2]) < brickHeight then
								if (yy1 <= currentMag+BIGEPSCM & yy1 >= currentMag-BIGEPSCM) then
									if iDoorBorder[j] = BORDERDOOR_VERT then
										if origOpeningForms[i] <> POLY_FORM_POLYGON_SLANT then
											stat = STATUS_DOOR
										else
											stat = STATUS_NONE
										endif
		
										edgeSection[n][nEdgePoint[n]*2+1]	= xx1
										edgeSection[n][nEdgePoint[n]*2+2]	= currentMag
										edgeStatus[n][nEdgePoint[n]+1]		= stat
										nEdgePoint[n]						= nEdgePoint[n] + 1
										gosub "checkSectionInPoly"
									endif
								endif
							endif
	
							!Csak az ablak tetején lévőket nézzük
							if abs(currentMag - origOpeningBoundingBox[i][4]) < brickHeight then
								if currentMag < yy2 & yy2 < currentMag + brickHeight + BIGEPS then
									if iDoorBorder[j] = BORDERDOOR_VERT then
										if origOpeningForms[i] <> POLY_FORM_POLYGON_SLANT then
											stat = STATUS_DOOR
										else
											stat = STATUS_NONE
										endif
	
										edgeSection[n][nEdgePoint[n]*2+1]	= xx1
										edgeSection[n][nEdgePoint[n]*2+2]	= currentMag
										edgeStatus[n][nEdgePoint[n]+1]		= stat
										nEdgePoint[n]						= nEdgePoint[n] + 1
										gosub "checkSectionInPoly"
									endif
								endif
							endif
						else
							! Koordináták
							hDiff	= currentMag - yy1
							sy		= currentMag
							if iDoorBorder[j] = BORDERDOOR_VERT then
								sx		= xx1
								stat	= STATUS_DOOR
							else
								sx		= xx1 + hDiff / tan(aa)
								stat	= STATUS_NONE
							endif
							
							!! Metszéspont hozzáadása
							edgeSection[n][nEdgePoint[n]*2+1]	= sx
							edgeSection[n][nEdgePoint[n]*2+2]	= sy
							edgeStatus[n][nEdgePoint[n]+1]		= stat
							nEdgePoint[n]						= nEdgePoint[n] + 1
							gosub "checkSectionInPoly"
						endif
					else
						if (yy1 > currentMag + BIGEPS & yy1 < currentMag + brickHeight - BIGEPS ) & (iDoorBorder[j] = BORDERDOOR_VERT) then	! Az ablak metszené az alatta lévő téglasort (nem szép)
							if groutVertical > EPS then
								edgeSection[n][nEdgePoint[n]*2+1]	= xx1
							else
								edgeSection[n][nEdgePoint[n]*2+1]	= xx1-EPS
							endif

							if origOpeningForms[i] <> POLY_FORM_POLYGON_SLANT then
								stat = STATUS_DOOR
							else
								stat = STATUS_WINBOTTOM
							endif

							if groutVertical > EPS then
								isLeft = (abs(xx1 - origOpeningBoundingBox[i][1]) < EPS)

								if isLeft then
									edgeSection[n][nEdgePoint[n]*2+1]	= xx1
									edgeSection[n][nEdgePoint[n]*2+2]	= currentMag
									edgeStatus[n][nEdgePoint[n]+1]		= stat
									nEdgePoint[n]						= nEdgePoint[n] + 1
									gosub "checkSectionInPoly"

									edgeSection[n][nEdgePoint[n]*2+1]	= xx1+groutVertical
									edgeSection[n][nEdgePoint[n]*2+2]	= currentMag
									edgeStatus[n][nEdgePoint[n]+1]		= STATUS_WINBOTTOM
									nEdgePoint[n]						= nEdgePoint[n] + 1
									gosub "checkSectionInPoly"
								else
									edgeSection[n][nEdgePoint[n]*2+1]	= xx1-groutVertical
									edgeSection[n][nEdgePoint[n]*2+2]	= currentMag
									edgeStatus[n][nEdgePoint[n]+1]		= STATUS_WINBOTTOM
									nEdgePoint[n]						= nEdgePoint[n] + 1
									gosub "checkSectionInPoly"

									edgeSection[n][nEdgePoint[n]*2+1]	= xx1
									edgeSection[n][nEdgePoint[n]*2+2]	= currentMag
									edgeStatus[n][nEdgePoint[n]+1]		= stat
									nEdgePoint[n]						= nEdgePoint[n] + 1
									gosub "checkSectionInPoly"
								endif
							else
								edgeSection[n][nEdgePoint[n]*2+1]	= xx1-EPS
								edgeSection[n][nEdgePoint[n]*2+2]	= currentMag
								edgeStatus[n][nEdgePoint[n]+1]		= stat
								nEdgePoint[n]						= nEdgePoint[n] + 1
								gosub "checkSectionInPoly"

								edgeSection[n][nEdgePoint[n]*2+1]	= xx1+EPS
								edgeSection[n][nEdgePoint[n]*2+2]	= currentMag
								edgeStatus[n][nEdgePoint[n]+1]		= stat
								nEdgePoint[n]						= nEdgePoint[n] + 1
								gosub "checkSectionInPoly"
							endif
						endif
					endif
				endif
			next j
		next i
	

		! ------------------------------------------------------------------------------
		! Wall Connection Sections
		! ------------------------------------------------------------------------------
		if tConnections then
			for i = 1 to nTwallConn
				!Jó magasságban van
				yy1 = tConnBox[i][2]
				yy2 = tConnBox[i][4]
				if (yy1 <= currentMag & yy2 >= currentMag+BIGEPSCM) then
					if n % 2 then
						if startRow then
							eltoltSor = 1
						else
							eltoltSor = 0
						endif
					else
						if startRow then
							eltoltSor = 0
						else
							eltoltSor = 1
						endif
					endif
	
					if eltoltSor then
						edgeSection[n][nEdgePoint[n]*2+1]	= tConnBox[i][1] - groutVertical
						edgeSection[n][nEdgePoint[n]*2+2]	= currentMag
						edgeStatus[n][nEdgePoint[n]+1]		= STATUS_TWALL
						nEdgePoint[n]						= nEdgePoint[n] + 1
						gosub "checkSectionInPoly"
	
						edgeSection[n][nEdgePoint[n]*2+1]	= tConnBox[i][3] + groutVertical
						edgeSection[n][nEdgePoint[n]*2+2]	= currentMag
						edgeStatus[n][nEdgePoint[n]+1]		= STATUS_TWALL
						nEdgePoint[n]						= nEdgePoint[n] + 1
						gosub "checkSectionInPoly"
					endif
	
				endif
			next i
		endif

	next n
	
	
	! ------------------------------------------------------------------------------
	! Maximális pontszám
	! ------------------------------------------------------------------------------
	nMax = 0
	for n = nMagPoint to 1 step -1
		if nEdgePoint[n] > nMax then nMax = nEdgePoint[n]
	next n
	
	
	! ------------------------------------------------------------------------------
	! Sorting Sections
	! ------------------------------------------------------------------------------
	dim newEdgeSection[][], newEdgeStatus[][], nNewEdgePoint[]
	for n = nMagPoint to 1 step -1
		nNewEdgePoint[n] = 0
		indexNum = nEdgePoint[n]
	
		if indexNum > 1 then
			!Sortolás az y pozicióra
			dim unsortedCoords2[][2]
			for i = indexNum to 1 step -1
				unsortedCoords2[i][1] = edgeSection[n][(i-1)*2+2]
				unsortedCoords2[i][2] = i
			next i
			gosub "insertionSort2"
			dim ySortedIdxs[][], nCurrentX[]
			nCurrentY	 		 = 1
			nCurrentX[nCurrentY] = 1
			ySortedIdxs[nCurrentY][nCurrentX[nCurrentY]] = unsortedCoords2[1][2]
			for i = 2 to indexNum
				if abs(unsortedCoords2[i-1][1] - unsortedCoords2[i][1]) > EPS then
					nCurrentY										= nCurrentY + 1
					nCurrentX[nCurrentY]							= 1
					ySortedIdxs[nCurrentY][nCurrentX[nCurrentY]] 	= unsortedCoords2[i][2]
				else
					nCurrentX[nCurrentY]							= nCurrentX[nCurrentY] + 1
					ySortedIdxs[nCurrentY][nCurrentX[nCurrentY]] 	= unsortedCoords2[i][2]
				endif
			next i

			for i = 1 to nCurrentY
				dim unsortedCoords2[][2]
				for j = nCurrentX[i] to 1 step -1
					idx						= ySortedIdxs[i][j]
					unsortedCoords2[j][1]	= edgeSection[n][(idx-1)*2+1]
					unsortedCoords2[j][2]	= idx 
				next j
				gosub "insertionSort2"

				
				!--------Fill Array-----------
				idx								= unsortedCoords2[1][2]
				nNewEdgePoint[n]				= nNewEdgePoint[n] + 1
				if i = 1 then
					nEdgePoint2[n] = 1
				endif
				newEdgeStatus[n][nNewEdgePoint[n]] 			= edgeStatus[n][idx]
				newEdgeSection[n][(nNewEdgePoint[n]-1)*2+1]	= edgeSection[n][(idx-1)*2+1]
				newEdgeSection[n][(nNewEdgePoint[n]-1)*2+2]	= edgeSection[n][(idx-1)*2+2]

				for z = 2 to nCurrentX[i]
					pIdx = unsortedCoords2[z-1][2]
					cIdx = unsortedCoords2[z][2]
					if abs(edgeSection[n][(pIdx-1)*2+1]-edgeSection[n][(cIdx-1)*2+1])<EPS then		!Azonos pont
						!-----Ha az elözo pont EPS belül van akkor ugyanaz a pont akkor vonjuk össze		TODO mi legyen a státuszokkal
						nEdgePoint[n] = nEdgePoint[n] - 1
					else
						nNewEdgePoint[n]				= nNewEdgePoint[n] + 1
						if i = 1 then
							nEdgePoint2[n]				= nEdgePoint2[n] + 1
						endif
						newEdgeStatus[n][nNewEdgePoint[n]] 			= edgeStatus[n][cIdx]
						newEdgeSection[n][(nNewEdgePoint[n]-1)*2+1]	= edgeSection[n][(cIdx-1)*2+1]
						newEdgeSection[n][(nNewEdgePoint[n]-1)*2+2]	= edgeSection[n][(cIdx-1)*2+2]
					endif
				next z
			next i
		endif
		if nNewEdgePoint[n] > nMax then nMax = nNewEdgePoint[n]
	next n

	
	! ------------------------------------------------------------------------------
	! Contour polygon
	! ------------------------------------------------------------------------------
	!A felesleges részek kitöltése (csak hogy ne sikitson)
	for n = nMagPoint to 1 step -1
		for i = nMax to nNewEdgePoint[n]+1 step -1
			newEdgeStatus[n][i] = 0
		next i
	
		for i = nMax*2 to nNewEdgePoint[n]*2+1 step -1
			newEdgeSection[n][i] = 0
		next i
	next n

	edgeStatus	= newEdgeStatus
	edgeSection	= newEdgeSection
	
	
	!!! ------------------------------------------------------------------------------
	!!! Debug
	!!! ------------------------------------------------------------------------------
	!!parameters edgeSection = edgeSection, nEdgePoint = nEdgePoint
	!!
	!!for n = nMagPoint to 1 step -1
	!!	for i = 1 to nEdgePoint[n]
	!!		hotspot2 edgeSection[n][(i-1)*2+1], edgeSection[n][(i-1)*2+2]
	!!	next i
	!!
	!!	if fra(nEdgePoint[n]/2) > eps then print "Baj van, nem jó a pontszám: ", n ,nEdgePoint[n]
	!!	nSegment = int(nEdgePoint[n]/2)
	!!	for i = 1 to nSegment
	!!		line2 edgeSection[n][(i-1)*4+1], edgeSection[n][(i-1)*4+2], edgeSection[n][(i-1)*4+3], edgeSection[n][(i-1)*4+4]
	!!	next i
	!!next n

	
	! ==============================================================================
	!
	! Sectionok sorba rendezése (prekalkulácio hogy milyen sorok fognak játszani)
	!
	! ==============================================================================
	nColData		= 12	!(1)eltoltSor, (2)iRowLength, (3)status1, (4)status2, (5)csorba1, (6)csorba2, (7)startPointX, (8)endPointX, (9)y, (10)brickDir, (11)startBigCsorba, (12)nSpecElem
	nSpecialData	= 9		!(1)iLengthType, (2)TYPE_NORMAL, (3)mirrored, (4)fixPointX, (5)length, (6)minLength, (7)maxLength, (8)minPosX, (9)maxPosX
	dim nColumnDatas[]	!Hány oszlop van egy sorban
	dim columnDatas[][], columnSpecials[][], numSpecials[]
	dim nRowCutters[], rowCutters[][4]	!Hány vágoelem van a téglasorban
	for i = nMagPoint to 1 step -1
		nColumnDatas[i] 	= 0
		nRowCutters[i]		= 0
		rowCutters[i][1]	= 0
		rowCutters[i][2]	= 0
		rowCutters[i][3]	= 0
		rowCutters[i][4]	= 0		
	next i
	saccoltOszlopSzam = int(nMax/2)+1
	columnDatas[nMagPoint][saccoltOszlopSzam*nColData]	= 0
	nEstimatedBrick	= 0
	nColumnMax		= saccoltOszlopSzam
	nSpecialMax		= 0
	
	if bKiosztasFelulrol then
		forCiklusStart	= nMagPoint
		forCiklusEnd	= 1
		forCiklusStep	= -1
		if nMagPoint > 0 then
			currentMag	= surfaceYmin + rowHeights[nMagPoint][2]
		endif
	else
		forCiklusStart	= 1
		forCiklusEnd	= nMagPoint
		forCiklusStep	= 1
		if nMagPoint > 0 then
			currentMag	= surfaceYmin + rowHeights[1][2]
		endif
	endif
	
	for nSor = forCiklusStart to forCiklusEnd step forCiklusStep
		magCurrent = surfaceYmin + rowHeights[nSor][2]

		!!Mi történjen a sorokban
		if nSor % 2 then
			if startRow then
				eltoltSor = 1
			else
				eltoltSor = 0
			endif
		else
			if startRow then
				eltoltSor = 0
			else
				eltoltSor = 1
			endif
		endif
	
		!!if fra(nEdgePoint[nSor]/2) > eps then print "Baj van, nem jó a pontszám"
	
		!Sorkalkulálás
		nSegment			= int(nEdgePoint[nSor]/2)
		nSegment2			= int(nEdgePoint2[nSor]/2)
		for nCol = 1 to nSegment
			col1	= nCol
			col2	= nCol
			row1	= nSor
			row2	= nSor
			yPos	= edgeSection[row1][(col1-1)*4+2]
	
			if nCol > nSegment2 then
				if nCol = 1 then
					if nSor < nMagPoint then
						if edgeSection[nSor+1][1] < edgeSection[nSor][1] then
							col1	= nCol
							row1	= nSor+1
						endif
					endif
				endif
		
				if nCol = int(nEdgePoint2[nSor]/2) then
					if nSor < nMagPoint then
						if edgeSection[nSor+1][(int(nEdgePoint2[nSor+1]/2)-1)*4+3] > edgeSection[nSor][(nSegment2-1)*4+3] then
							col2	= int(nEdgePoint2[nSor+1]/2)
							row2	= nSor+1
						endif
					endif
				endif
			endif
	
			distance = edgeSection[row2][(col2-1)*4+3] - edgeSection[row1][(col2-1)*4+1]		!TODO itt miért col2 van kétszer
	
			if distance > 3*athSpace then			! Ha kicsi a távolság akkor nem számolunk
				xx1			= edgeSection[row1][(col1-1)*4+1]
				xx2			= edgeSection[row2][(col2-1)*4+3]
				s1			= edgeStatus[row1][(col1-1)*2+1]
				s2			= edgeStatus[row2][(col2-1)*2+2]
				bcs1		= 0
				bcs2		= 0
				iRowLength	= ROWLENGTH_LARGE
				columnStart	= COLUMN_NONE
				columnEnd	= COLUMN_NONE
				dim midColumns[]

				if distance < rowLengthLimit[3] + BIGEPS then iRowLength = ROWLENGTH_NORMAL
				if distance < rowLengthLimit[2] + BIGEPS then iRowLength = ROWLENGTH_MEDIUM
				if distance < rowLengthLimit[1] + BIGEPS then iRowLength = ROWLENGTH_SMALL

				if s1 = STATUS_CSORBA_1 | s1 = STATUS_CSORBA_2 then
					columnStart = iColumnStart
					if s1 = STATUS_CSORBA_1 then
						if eltoltSor then
							xx1		= xx1 + csorbaX1
							cutIdx	= BR_CUT_CORNER_LEFT_2
							gosub "checkCutterInArray"
						else
							bcs1	= 1
							cutIdx	= BR_CUT_CORNER_LEFT_1
							gosub "checkCutterInArray"
						endif
					endif
					if s1 = STATUS_CSORBA_2 then
						if not(eltoltSor) then
							xx1		= xx1 + csorbaX1
							cutIdx	= BR_CUT_CORNER_LEFT_2
							gosub "checkCutterInArray"
						else
							bcs1	= 1
							cutIdx	= BR_CUT_CORNER_LEFT_1
							gosub "checkCutterInArray"
						endif
					endif
				endif
			
				if s2 = STATUS_CSORBA_1 | s2 = STATUS_CSORBA_2 then
					columnEnd = iColumnEnd
					if s2 = STATUS_CSORBA_1 then
						if not(eltoltSor) then
							xx2		= xx2 - csorbaX2
							cutIdx	= BR_CUT_CORNER_RIGHT_2
							gosub "checkCutterInArray"
						else
							bcs2	= 1
							cutIdx	= BR_CUT_CORNER_RIGHT_1
							gosub "checkCutterInArray"
						endif
					endif
					if s2 = STATUS_CSORBA_2 then
						if eltoltSor then
							xx2		= xx2 - csorbaX2
							cutIdx	= BR_CUT_CORNER_RIGHT_2
							gosub "checkCutterInArray"
						else
							bcs2	= 1
							cutIdx	= BR_CUT_CORNER_RIGHT_1
							gosub "checkCutterInArray"
						endif
					endif
				endif
	
				distance		= xx2 - xx1
				nEstimatedBrick = nEstimatedBrick + int(distance / (brickWidth*0.75)) + 1


				! Columns
				!if columnStart <> iColumnStart then
					if abs(xx1 - surfaceXmin) < BIGEPS then
						columnStart = iColumnStart
						if iColumnStart = COLUMN_CONCRETE_OFFSET then
							columnStart = COLUMN_CONCRETE
						endif
					endif
				!endif
				
				!if columnEnd <> iColumnEnd then
					if abs(xx2 - surfaceXmax) < BIGEPS then
						columnEnd = iColumnEnd
						if iColumnEnd = COLUMN_CONCRETE_OFFSET then
							columnEnd = COLUMN_CONCRETE
						endif
					endif
				!endif
				
				n = 0
				for j = 1 to nMidColums
					if xx1 < iMidColumns[j] & iMidColumns[j] < xx2 then
						n = n + 1
						midColumns[n] = iMidColumns[j]
					endif
				next j
				
				!---------Ha van csorba akkor megprobálunk csalni a kiosztással
				gosub "CalcColumnData"
			endif
		next nCol

		if nColumnDatas[nSor] > nColumnMax then nColumnMax = nColumnDatas[nSor]
		s = 0
		for i = 1 to nColumnDatas[nSor]
			nSpec = columnDatas[nSor][(i-1)*nColData+12]	!nSpecials
			for j = 1 to nSpec 
				for z = 1 to nSpecialData
					s = s + 1 : columnSpecials[nSor][s] = get(1)
				next z
			next j
		next i

		numSpecials[nSor] = s / nSpecialData
		if numSpecials[nSor] > nSpecialMax then nSpecialMax = numSpecials[nSor]
	next nSor

	!A felesleges részek kitöltése (csak hogy ne sikitson)
	for nSor = nMagPoint to 1 step -1
		for i = nColumnMax*nColData to nColumnDatas[nSor]*nColData+1 step -1
			columnDatas[nSor][i] = 0
		next i

		for i = nSpecialMax * nSpecialData to numSpecials[nSor]*nSpecialData+1 step -1
			columnSpecials[nSor][i] = 0
		next i
	next nSor


	! ------------------------------------------------------------------------------
	! Brick Cutters
	! ------------------------------------------------------------------------------
	nBrickCutter = 0
	dim brickCutters[][], brickCuttersType[]

	brickCutters[1][1]	= 0
	brickCutters[1][2]	= 0
	brickCuttersType[1]	= 0

	BR_CUT_NONE				= 0
	BR_CUT_CORNER_LEFT_1	= 1
	BR_CUT_CORNER_LEFT_2	= 2
	BR_CUT_CORNER_RIGHT_1	= 3
	BR_CUT_CORNER_RIGHT_2	= 4

	! ------------ Left -----------------------
	if	iCalcJointType1 = JOINT_SIDE_CORNER_1	|\
		iCalcJointType1 = JOINT_SIDE_CORNER_2	|\
		iCalcJointType1 = JOINT_SIDE_CORNER_T_1	|\
		iCalcJointType1 = JOINT_SIDE_CORNER_T_2	\
	then
		if connWallStartIangle = ANGLE_ACUTE | connWallStartIangle = ANGLE_OBTUSE then
			!bNegativeAngle	= (connWallStartAngle < -EPS)
			bNegativeAngle	= (connWallStartAngle > 180)
			if connWallStartIangle = ANGLE_ACUTE then
				offset1	= surfaceXmin - (brickThk/tan(180-connWallStartAngle)) * not(bNegativeAngle)
				offset2	= offset1 + csorbaX1
				if not(bNegativeAngle) then
					p1x = cutOverSize/tan(connWallStartAngle)
					p2x	= -(brickThk+cutOverSize)/tan(connWallStartAngle)

					nBrickCutter					= nBrickCutter + 1
					brickCuttersType[nBrickCutter]	= BR_CUT_CORNER_LEFT_1
					brickCutters[nBrickCutter][1]	= offset1 + p1x
					brickCutters[nBrickCutter][2]	= -cutOverSize
					brickCutters[nBrickCutter][3]	= offset1 + p2x-cutOverSize
					brickCutters[nBrickCutter][4]	= -cutOverSize
					brickCutters[nBrickCutter][5]	= offset1 + p2x-cutOverSize
					brickCutters[nBrickCutter][6]	= brickThk+cutOverSize
					brickCutters[nBrickCutter][7]	= offset1 + p2x
					brickCutters[nBrickCutter][8]	= brickThk+cutOverSize

					nBrickCutter					= nBrickCutter + 1
					brickCuttersType[nBrickCutter]	= BR_CUT_CORNER_LEFT_2
					brickCutters[nBrickCutter][1]	= offset2 + p1x
					brickCutters[nBrickCutter][2]	= -cutOverSize
					brickCutters[nBrickCutter][3]	= offset2 + p2x-cutOverSize
					brickCutters[nBrickCutter][4]	= -cutOverSize
					brickCutters[nBrickCutter][5]	= offset2 + p2x-cutOverSize
					brickCutters[nBrickCutter][6]	= brickThk+cutOverSize
					brickCutters[nBrickCutter][7]	= offset2 + p2x
					brickCutters[nBrickCutter][8]	= brickThk+cutOverSize
				else
					p1x = -cutOverSize/tan(360-connWallStartAngle)
					p2x	= (brickThk+cutOverSize)/tan(360-connWallStartAngle)

					nBrickCutter					= nBrickCutter + 1
					brickCuttersType[nBrickCutter]	= BR_CUT_CORNER_LEFT_1
					brickCutters[nBrickCutter][1]	= offset1 + p1x
					brickCutters[nBrickCutter][2]	= -cutOverSize
					brickCutters[nBrickCutter][3]	= offset1 + p1x-cutOverSize
					brickCutters[nBrickCutter][4]	= -cutOverSize
					brickCutters[nBrickCutter][5]	= offset1 + p1x-cutOverSize
					brickCutters[nBrickCutter][6]	= brickThk+cutOverSize
					brickCutters[nBrickCutter][7]	= offset1 + p2x
					brickCutters[nBrickCutter][8]	= brickThk+cutOverSize

					nBrickCutter					= nBrickCutter + 1
					brickCuttersType[nBrickCutter]	= BR_CUT_CORNER_LEFT_2
					brickCutters[nBrickCutter][1]	= offset2 + p1x
					brickCutters[nBrickCutter][2]	= -cutOverSize
					brickCutters[nBrickCutter][3]	= offset2 + p1x-cutOverSize
					brickCutters[nBrickCutter][4]	= -cutOverSize
					brickCutters[nBrickCutter][5]	= offset2 + p1x-cutOverSize
					brickCutters[nBrickCutter][6]	= brickThk+cutOverSize
					brickCutters[nBrickCutter][7]	= offset2 + p2x
					brickCutters[nBrickCutter][8]	= brickThk+cutOverSize
				endif
			else
				offset1	= surfaceXmin + (brickThk/tan(connWallStartAngle)) * bNegativeAngle
				offset2	= offset1 + csorbaX1
				if not(bNegativeAngle) then
					p1x = -cutOverSize/tan(180-connWallStartAngle)
					p2x	= (brickThk+cutOverSize)/tan(180-connWallStartAngle)

					nBrickCutter					= nBrickCutter + 1
					brickCuttersType[nBrickCutter]	= BR_CUT_CORNER_LEFT_1
					brickCutters[nBrickCutter][1]	= offset1 + p1x
					brickCutters[nBrickCutter][2]	= -cutOverSize
					brickCutters[nBrickCutter][3]	= offset1 + p1x-cutOverSize
					brickCutters[nBrickCutter][4]	= -cutOverSize
					brickCutters[nBrickCutter][5]	= offset1 + p1x-cutOverSize
					brickCutters[nBrickCutter][6]	= brickThk+cutOverSize
					brickCutters[nBrickCutter][7]	= offset1 + p2x
					brickCutters[nBrickCutter][8]	= brickThk+cutOverSize

					nBrickCutter					= nBrickCutter + 1
					brickCuttersType[nBrickCutter]	= BR_CUT_CORNER_LEFT_2
					brickCutters[nBrickCutter][1]	= offset2 + p1x
					brickCutters[nBrickCutter][2]	= -cutOverSize
					brickCutters[nBrickCutter][3]	= offset2 + p1x-cutOverSize
					brickCutters[nBrickCutter][4]	= -cutOverSize
					brickCutters[nBrickCutter][5]	= offset2 + p1x-cutOverSize
					brickCutters[nBrickCutter][6]	= brickThk+cutOverSize
					brickCutters[nBrickCutter][7]	= offset2 + p2x
					brickCutters[nBrickCutter][8]	= brickThk+cutOverSize
				else
					p1x = cutOverSize/tan(connWallStartAngle)
					p2x	= -(brickThk+cutOverSize)/tan(connWallStartAngle)

					nBrickCutter					= nBrickCutter + 1
					brickCuttersType[nBrickCutter]	= BR_CUT_CORNER_LEFT_1
					brickCutters[nBrickCutter][1]	= offset1 + p1x
					brickCutters[nBrickCutter][2]	= -cutOverSize
					brickCutters[nBrickCutter][3]	= offset1 + p2x-cutOverSize
					brickCutters[nBrickCutter][4]	= -cutOverSize
					brickCutters[nBrickCutter][5]	= offset1 + p2x-cutOverSize
					brickCutters[nBrickCutter][6]	= brickThk+cutOverSize
					brickCutters[nBrickCutter][7]	= offset1 + p2x
					brickCutters[nBrickCutter][8]	= brickThk+cutOverSize

					nBrickCutter					= nBrickCutter + 1
					brickCuttersType[nBrickCutter]	= BR_CUT_CORNER_LEFT_2
					brickCutters[nBrickCutter][1]	= offset2 + p1x
					brickCutters[nBrickCutter][2]	= -cutOverSize
					brickCutters[nBrickCutter][3]	= offset2 + p2x-cutOverSize
					brickCutters[nBrickCutter][4]	= -cutOverSize
					brickCutters[nBrickCutter][5]	= offset2 + p2x-cutOverSize
					brickCutters[nBrickCutter][6]	= brickThk+cutOverSize
					brickCutters[nBrickCutter][7]	= offset2 + p2x
					brickCutters[nBrickCutter][8]	= brickThk+cutOverSize
				endif
			endif
		endif
	endif

	! ------------ Right -----------------------
	if	iCalcJointType2 = JOINT_SIDE_CORNER_1	|\
		iCalcJointType2 = JOINT_SIDE_CORNER_2	|\
		iCalcJointType2 = JOINT_SIDE_CORNER_T_1	|\
		iCalcJointType2 = JOINT_SIDE_CORNER_T_2	\
	then
		if connWallEndIangle = ANGLE_ACUTE | connWallEndIangle = ANGLE_OBTUSE then
			!bNegativeAngle	= (connWallEndAngle < -EPS)
			bNegativeAngle	= (connWallEndAngle > 180)
			if connWallEndIangle = ANGLE_ACUTE then
				offset1	= surfaceXmax + (brickThk/tan(180-connWallEndAngle)) * not(bNegativeAngle)
				offset2	= offset1 - csorbaX2
				if not(bNegativeAngle) then
					p1x = -cutOverSize/tan(connWallEndAngle)
					p2x	= (brickThk+cutOverSize)/tan(connWallEndAngle)

					nBrickCutter					= nBrickCutter + 1
					brickCuttersType[nBrickCutter]	= BR_CUT_CORNER_RIGHT_1
					brickCutters[nBrickCutter][1]	= offset1 + p1x
					brickCutters[nBrickCutter][2]	= -cutOverSize
					brickCutters[nBrickCutter][3]	= offset1 + p2x+cutOverSize
					brickCutters[nBrickCutter][4]	= -cutOverSize
					brickCutters[nBrickCutter][5]	= offset1 + p2x+cutOverSize
					brickCutters[nBrickCutter][6]	= brickThk+cutOverSize
					brickCutters[nBrickCutter][7]	= offset1 + p2x
					brickCutters[nBrickCutter][8]	= brickThk+cutOverSize

					nBrickCutter					= nBrickCutter + 1
					brickCuttersType[nBrickCutter]	= BR_CUT_CORNER_RIGHT_2
					brickCutters[nBrickCutter][1]	= offset2 + p1x
					brickCutters[nBrickCutter][2]	= -cutOverSize
					brickCutters[nBrickCutter][3]	= offset2 + p2x+cutOverSize
					brickCutters[nBrickCutter][4]	= -cutOverSize
					brickCutters[nBrickCutter][5]	= offset2 + p2x+cutOverSize
					brickCutters[nBrickCutter][6]	= brickThk+cutOverSize
					brickCutters[nBrickCutter][7]	= offset2 + p2x
					brickCutters[nBrickCutter][8]	= brickThk+cutOverSize
				else
					p1x = cutOverSize/tan(360-connWallEndAngle)
					p2x	= -(brickThk+cutOverSize)/tan(360-connWallEndAngle)

					nBrickCutter					= nBrickCutter + 1
					brickCuttersType[nBrickCutter]	= BR_CUT_CORNER_RIGHT_1
					brickCutters[nBrickCutter][1]	= offset1 + p1x
					brickCutters[nBrickCutter][2]	= -cutOverSize
					brickCutters[nBrickCutter][3]	= offset1 + p1x+cutOverSize
					brickCutters[nBrickCutter][4]	= -cutOverSize
					brickCutters[nBrickCutter][5]	= offset1 + p1x+cutOverSize
					brickCutters[nBrickCutter][6]	= brickThk+cutOverSize
					brickCutters[nBrickCutter][7]	= offset1 + p2x
					brickCutters[nBrickCutter][8]	= brickThk+cutOverSize

					nBrickCutter					= nBrickCutter + 1
					brickCuttersType[nBrickCutter]	= BR_CUT_CORNER_RIGHT_2
					brickCutters[nBrickCutter][1]	= offset2 + p1x
					brickCutters[nBrickCutter][2]	= -cutOverSize
					brickCutters[nBrickCutter][3]	= offset2 + p1x+cutOverSize
					brickCutters[nBrickCutter][4]	= -cutOverSize
					brickCutters[nBrickCutter][5]	= offset2 + p1x+cutOverSize
					brickCutters[nBrickCutter][6]	= brickThk+cutOverSize
					brickCutters[nBrickCutter][7]	= offset2 + p2x
					brickCutters[nBrickCutter][8]	= brickThk+cutOverSize
				endif
			else
				offset1	= surfaceXmax - (brickThk/tan(connWallEndAngle)) * bNegativeAngle
				offset2	= offset1 - csorbaX2
				if not(bNegativeAngle) then
					p1x = cutOverSize/tan(180-connWallEndAngle)
					p2x	= -(brickThk+cutOverSize)/tan(180-connWallEndAngle)

					nBrickCutter					= nBrickCutter + 1
					brickCuttersType[nBrickCutter]	= BR_CUT_CORNER_RIGHT_1
					brickCutters[nBrickCutter][1]	= offset1 + p1x
					brickCutters[nBrickCutter][2]	= -cutOverSize
					brickCutters[nBrickCutter][3]	= offset1 + p1x+cutOverSize
					brickCutters[nBrickCutter][4]	= -cutOverSize
					brickCutters[nBrickCutter][5]	= offset1 + p1x+cutOverSize
					brickCutters[nBrickCutter][6]	= brickThk+cutOverSize
					brickCutters[nBrickCutter][7]	= offset1 + p2x
					brickCutters[nBrickCutter][8]	= brickThk+cutOverSize

					nBrickCutter					= nBrickCutter + 1
					brickCuttersType[nBrickCutter]	= BR_CUT_CORNER_RIGHT_2
					brickCutters[nBrickCutter][1]	= offset2 + p1x
					brickCutters[nBrickCutter][2]	= -cutOverSize
					brickCutters[nBrickCutter][3]	= offset2 + p1x+cutOverSize
					brickCutters[nBrickCutter][4]	= -cutOverSize
					brickCutters[nBrickCutter][5]	= offset2 + p1x+cutOverSize
					brickCutters[nBrickCutter][6]	= brickThk+cutOverSize
					brickCutters[nBrickCutter][7]	= offset2 + p2x
					brickCutters[nBrickCutter][8]	= brickThk+cutOverSize
				else
					p1x = -cutOverSize/tan(connWallEndAngle)
					p2x	= (brickThk+cutOverSize)/tan(connWallEndAngle)

					nBrickCutter					= nBrickCutter + 1
					brickCuttersType[nBrickCutter]	= BR_CUT_CORNER_RIGHT_1
					brickCutters[nBrickCutter][1]	= offset1 + p1x
					brickCutters[nBrickCutter][2]	= -cutOverSize
					brickCutters[nBrickCutter][3]	= offset1 + p2x+cutOverSize
					brickCutters[nBrickCutter][4]	= -cutOverSize
					brickCutters[nBrickCutter][5]	= offset1 + p2x+cutOverSize
					brickCutters[nBrickCutter][6]	= brickThk+cutOverSize
					brickCutters[nBrickCutter][7]	= offset1 + p2x
					brickCutters[nBrickCutter][8]	= brickThk+cutOverSize

					nBrickCutter					= nBrickCutter + 1
					brickCuttersType[nBrickCutter]	= BR_CUT_CORNER_RIGHT_2
					brickCutters[nBrickCutter][1]	= offset2 + p1x
					brickCutters[nBrickCutter][2]	= -cutOverSize
					brickCutters[nBrickCutter][3]	= offset2 + p2x+cutOverSize
					brickCutters[nBrickCutter][4]	= -cutOverSize
					brickCutters[nBrickCutter][5]	= offset2 + p2x+cutOverSize
					brickCutters[nBrickCutter][6]	= brickThk+cutOverSize
					brickCutters[nBrickCutter][7]	= offset2 + p2x
					brickCutters[nBrickCutter][8]	= brickThk+cutOverSize
				endif
			endif
		endif
	endif

	
	! ==============================================================================
	!
	! Sorok kiosztása (új modszer)
	!
	! ==============================================================================
	dim brickCoord[][5]		!x, y, size, lastX, h
	dim brickDef[][6]		!iBrickSubtype, mirrored, iProductType, iProductIdx, addGrout, custom
	dim brickCut[][3]		!startCut, endCut, topCut
	dim rowIndex[][2]		!A sorban hányas tégla kezdődik és fejeződik be
	dim prevGroutPoint[]
	dim currentGroutPoint[]
	nCurrentGroutPoint	= 0
	nPrevGroutPoint		= 0
	nBrick				= 0
	bFirstBrick			= 0
	bLastBrick			= 0

	brickCoord[1][1]	= 0
	brickCoord[1][2]	= 0
	brickCoord[1][3]	= 0
	brickCoord[1][4]	= 0
	brickCoord[1][5]	= 0
	brickDef[1][1]		= 0
	brickDef[1][2]		= 0
	brickDef[1][3]		= 0
	brickDef[1][4]		= 0
	brickDef[1][5]		= 0
	brickDef[1][6]		= 0
	brickCut[1][1]		= 0
	brickCut[1][2]		= 0
	brickCut[1][3]		= 0
	rowIndex[1][1]		= 0
	rowIndex[1][2]		= 0
	
!	! ------------------------------------------------------------------------------
!	! Prefetch
!	! ------------------------------------------------------------------------------
!	brickCoord[nEstimatedBrick][1]			= 0
!	brickDef[nEstimatedBrick][1]			= 0
!	brickCut[nEstimatedBrick][1]			= 0
!	!prevGroutPoint[nEstimatedBrick]		= 0
!	!currentGroutPoint[nEstimatedBrick]		= 0
!	rowIndex[nMagPoint][1]					= 0

	! ------------------------------------------------------------------------------
	! Kiosztás tégla
	! ------------------------------------------------------------------------------
	for nSor = forCiklusStart to forCiklusEnd step forCiklusStep

		!--------------------- Következő sor metszéspontjai ------------------------------
		dim nextSectionPoints[]
		if bKiosztasFelulrol then
			nextSectionRow = nSor-1
		else
			nextSectionRow = nSor+1
		endif
		nSectPoint = 0

		!------------------- Legalsó sor alatti tesztkiosztás (trükk hogy jó legyen az első sor)---------------------------
		if bAlsoSorAlattiOsztas	then
			if not(bKiosztasFelulrol) & nSor = 1 then
				tSor = 1
				for nCol = 1 to nColumnDatas[tSor]
					n			= (nCol-1)*nColData
					s1			= round_int(columnDatas[tSor][n+3])
					s2			= round_int(columnDatas[tSor][n+4])
					xx1			= columnDatas[tSor][n+7]
					xx2			= columnDatas[tSor][n+8]
					if abs(currentMag+rowHeights[nextSectionRow][1]-columnDatas[tSor][n+9]) < BIGEPS then
						if s1 <> STATUS_DOOR then put xx1
						if s2 <> STATUS_DOOR then put xx2
					endif
				next nCol
				
				nSectPoint = nsp
				if nSectPoint then
					nextSectionPoints[nSectPoint] = 0
					for i = 1 to nSectPoint
						nextSectionPoints[i] = get(1)
					next i
				endif
		
				nCurrentGroutPoint	= 0
				tSor	= nextSectionRow
				nS		= 0
				for nCol = 1 to nColumnDatas[tSor]
					colStartIdx		= nBrick + 1
					n				= (nCol-1)*nColData
					eltoltSor		= round_int(columnDatas[tSor][n+1])
					iRowLength		= round_int(columnDatas[tSor][n+2])
					s1				= round_int(columnDatas[tSor][n+3])
					s2				= round_int(columnDatas[tSor][n+4])
					bcs1			= round_int(columnDatas[tSor][n+5])
					bcs2			= round_int(columnDatas[tSor][n+6])
					xx1				= columnDatas[tSor][n+7]
					xx2				= columnDatas[tSor][n+8]
					yPos			= currentMag
					if abs(currentMag-columnDatas[tSor][n+9]) > BIGEPS then
						yPos = columnDatas[tSor][n+9]
					endif
					esBrickDir		= round_int(columnDatas[tSor][n+10])
					startBigCsorba	= round_int(columnDatas[tSor][n+11])
					nSpecElem		= round_int(columnDatas[tSor][n+12])
					distance		= xx2 - xx1
					currentSpec		= 1

					dim specElemInts[][3]	!(1)iLengthType, (2)TYPE_NORMAL, (3)mirrored
					dim specElemFloats[][6]	!(1)fixPointX, (2)length, (3)minLength, (4)maxLength, (5)minPosX, (6)maxPosX

					for s = nSpecElem to 1 step -1
						nZ									= nS + (s-1) * nSpecialData
						specElemInts[s][SPEC_LENGTHTYPE]	= round_int(columnSpecials[tSor][nZ+1])
						specElemInts[s][SPEC_TYPE]			= round_int(columnSpecials[tSor][nZ+2])
						specElemInts[s][SPEC_MIRROR]		= round_int(columnSpecials[tSor][nZ+3])

						specElemFloats[s][SPEC_FIXPOINT]	= columnSpecials[tSor][nS+4]
						specElemFloats[s][SPEC_LENGTH]		= columnSpecials[tSor][nS+5]
						specElemFloats[s][SPEC_MINLENGTH]	= columnSpecials[tSor][nS+6]
						specElemFloats[s][SPEC_MAXLENGTH]	= columnSpecials[tSor][nS+7]
						specElemFloats[s][SPEC_MINPOS]		= columnSpecials[tSor][nS+8]
						specElemFloats[s][SPEC_MAXPOS]		= columnSpecials[tSor][nS+9]
					next s

					if bHalfStone then
						gosub "brickRasterHalfprefer"
					else
						gosub "brickRaster"
					endif

					nS = nS + nSpecElem * nSpecialData
				next nCol
		
				gosub "prevSorter"
		
				nBrick = 0
			endif
		endif
	
	
		!--------------------- Következő sor metszéspontjai ------------------------------
		if nextSectionRow > 0 & nextSectionRow < nMagPoint+1 then
			for nCol = 1 to nColumnDatas[nextSectionRow]
				n			= (nCol-1)*nColData
				s1			= round_int(columnDatas[nextSectionRow][n+3])
				s2			= round_int(columnDatas[nextSectionRow][n+4])
				xx1			= columnDatas[nextSectionRow][n+7]
				xx2			= columnDatas[nextSectionRow][n+8]
				if abs(currentMag+rowHeights[nextSectionRow][1]-columnDatas[nextSectionRow][n+9]) < BIGEPS then
					if s1 <> STATUS_DOOR then put xx1
					if s2 <> STATUS_DOOR then put xx2
				endif
			next nCol
			
			nSectPoint = nsp
			if nSectPoint then
				nextSectionPoints[nSectPoint] = 0
				for i = 1 to nSectPoint
					nextSectionPoints[i] = get(1)
				next i
			endif
	
			if bFugaSectionDebug then
				for i = 1 to vardim1(nextSectionPoints)-1 step 2
					if (i % 4) = 1 then
						_pen = 4
					else
						_pen = 5
					endif
					pen _pen
					line2 nextSectionPoints[i], currentMag + brickHeight + sideViewPos[1][2] + 1.05, nextSectionPoints[i+1], currentMag + brickHeight + sideViewPos[1][2] + 1.05
					!!line2 nextSectionPoints[i], yPos + brickHeight + sideViewPos[1][2] + 1.05, nextSectionPoints[i+1], yPos + brickHeight + sideViewPos[1][2] + 1.05
				next i
			endif
		endif
	
	
		!------------------- Aktuális sor oszlopai ---------------------------
		if bFugaSectionDebug then
			for i = 1 to nPrevGroutPoint
				hotspot2 prevGroutPoint[i], currentMag - brickHeight/2 + sideViewPos[1][2] + 1.05
			next i
		endif
		rowIndex[nSor][1]	= nBrick+1
		nCurrentGroutPoint	= 0
		nS					= 0
		for nCol = 1 to nColumnDatas[nSor]
			colStartIdx		= nBrick + 1
			n				= (nCol-1)*nColData
			eltoltSor		= round_int(columnDatas[nSor][n+1])
			iRowLength		= round_int(columnDatas[nSor][n+2])
			s1				= round_int(columnDatas[nSor][n+3])
			s2				= round_int(columnDatas[nSor][n+4])
			bcs1			= round_int(columnDatas[nSor][n+5])
			bcs2			= round_int(columnDatas[nSor][n+6])
			xx1				= columnDatas[nSor][n+7]
			xx2				= columnDatas[nSor][n+8]
			yPos			= currentMag
			if abs(currentMag-columnDatas[nSor][n+9]) > BIGEPS then
				yPos = columnDatas[nSor][n+9]
			endif
			esBrickDir		= round_int(columnDatas[nSor][n+10])
			startBigCsorba	= round_int(columnDatas[nSor][n+11])
			nSpecElem		= round_int(columnDatas[nSor][n+12])
			distance		= xx2 - xx1
			currentSpec		= 1
	
			!!print nSor, ss, xx1, xx2, nextSectionRow, "next", nextSectionPoints, "back", prevGroutPoint
			!!print nSor, nCol, "data", colStartIdx, n, "status", s1, s2, bcs1, bcs2,  esBrickDir, "dist", iRowLength, distance, xx1, xx2
	
			dim specElemInts[][3]	!(1)iLengthType, (2)TYPE_NORMAL, (3)mirrored
			dim specElemFloats[][6]	!(1)fixPointX, (2)length, (3)minLength, (4)maxLength, (5)minPosX, (6)maxPosX

			for s = nSpecElem to 1 step -1
				nZ									= nS + (s-1) * nSpecialData
				specElemInts[s][SPEC_LENGTHTYPE]	= round_int(columnSpecials[nSor][nZ+1])
				specElemInts[s][SPEC_TYPE]			= round_int(columnSpecials[nSor][nZ+2])
				specElemInts[s][SPEC_MIRROR]		= round_int(columnSpecials[nSor][nZ+3])

				specElemFloats[s][SPEC_FIXPOINT]	= columnSpecials[nSor][nZ+4]
				specElemFloats[s][SPEC_LENGTH]		= columnSpecials[nSor][nZ+5]
				specElemFloats[s][SPEC_MINLENGTH]	= columnSpecials[nSor][nZ+6]
				specElemFloats[s][SPEC_MAXLENGTH]	= columnSpecials[nSor][nZ+7]
				specElemFloats[s][SPEC_MINPOS]		= columnSpecials[nSor][nZ+8]
				specElemFloats[s][SPEC_MAXPOS]		= columnSpecials[nSor][nZ+9]
			next s

			if not(bHalfStone) then
				gosub "brickRaster"
			else
				gosub "brickRasterHalfprefer"
			endif

			nS = nS + nSpecElem * nSpecialData
		next nCol
	
		rowIndex[nSor][2]	= nBrick
		gosub "prevSorter"
		newIdx = nSor + 1*(1 - 2 * bKiosztasFelulrol)
		if 0 < newIdx & newIdx < nMagPoint + 1 then
			currentMag	= surfaceYmin + rowHeights[newIdx][2]
		endif
	next nSor

endif


! =============================================================================
! UI
! =============================================================================
uiStartX		= 10
uiStartY		= 80
uiEndX			= 435
uiEndY_T		= 207
uiEndY_C		= 230
uiLineHeight	= 24
nUiRows_T		= int ((uiEndY_T-uiStartY)/uiLineHeight)
nUiRows_C		= int ((uiEndY_C-uiStartY)/uiLineHeight)


! =============================================================================
! Warnings
! =============================================================================
bHasWarning			= 0
bOpeningFormWarning = 0
for i = 1 to min(nOpeningPolygons, vardim1(origOpeningForms))
	if origOpeningForms[i] = POLY_FORM_POLYGON_SLANT then
		bOpeningFormWarning = 1
	endif
next i
if nOverlappedLinders + nOversizedLinder + nLinderPosError + bOpeningFormWarning + bHasCornerWindow + bCurvedWall > 0 then
	bHasWarning = 1
endif




! ==============================================================================
!
! End of Master Script
!
! ==============================================================================

GOTO "endMasterSript"


! ==============================================================================
!
! Subrutines
!
! ==============================================================================
! ------------------------------------------------------------------------------
"checkOpeningForm":
! ------------------------------------------------------------------------------
	for j = origOpeningStartEnd[i][1] to origOpeningStartEnd[i][2]
		put origOpeningPoligons[j][1], origOpeningPoligons[j][2], 1
	next j
	gosub "calculatePolygonArea"
	openingArea = area
	boundArea	= openingOrigSize[i][1] * openingOrigSize[i][2]
	bRectPoly	= (abs(openingArea - boundArea) < EPS)

	if area < -EPS then
		origOpeningDirections[i] = -1
	else
		origOpeningDirections[i] = 1
	endif
	
	origOpeningForms[i] = POLY_FORM_UNKNOWN
	if bRectPoly then
		origOpeningForms[i] = POLY_FORM_RECT
	else
		origOpeningForms[i] = POLY_FORM_POLYGON_RECT
		for j = origOpeningStartEnd[i][1] to origOpeningStartEnd[i][2]-1
			if iDoorBorder[j] = BORDERDOOR_SLANT then
				origOpeningForms[i] = POLY_FORM_POLYGON_SLANT
				j					= origOpeningStartEnd[i][2]
			endif
		next j
	endif
return

! ------------------------------------------------------------------------------
"sortTConn":
! ------------------------------------------------------------------------------
	!Sortolás a tConnWallPos-re
	dim unsortedCoords2[][2]
	for i = vardim1(tValidConnIdxS) to 1 step -1
		unsortedCoords2[i][1] = tConnWallPos[tValidConnIdxS[i]] 
		unsortedCoords2[i][2] = tValidConnIdxS[i]
	next i
	gosub "insertionSort2"

	dim tValidConnIdxS[]
	for i = vardim1(unsortedCoords2) to 1 step -1
		tValidConnIdxS[i] = unsortedCoords2[i][2]
	next i
return

! ------------------------------------------------------------------------------
"sortCConn":
! ------------------------------------------------------------------------------
	!Sortolás a colPosX-re
	dim unsortedCoords2[][2]
	for i = vardim1(cValidConnIdxS) to 1 step -1
		unsortedCoords2[i][1] = colPosX[cValidConnIdxS[i]] 
		unsortedCoords2[i][2] = cValidConnIdxS[i]
	next i
	gosub "insertionSort2"

	dim cValidConnIdxS[]
	for i = vardim1(unsortedCoords2) to 1 step -1
		cValidConnIdxS[i] = unsortedCoords2[i][2]
	next i
return


! ==============================================================================
! Sort
! ------------------------------------------------------------------------------
! Input variables:
!	unsortedCoords1[]:		Coord Array (az tömb első oszlopa a sort tag)
!
! Returned variable:
!	sortedCoords1[]:		Sorted Array
! ==============================================================================
"insertionSort1":
	nn = vardim1(unsortedCoords1)
	for zz = 1 to nn
		pz	= zz
		while pz > 1 do
			if unsortedCoords1[pz - 1] > unsortedCoords1[pz] then
				tt						= unsortedCoords1[pz - 1]
				unsortedCoords1[pz - 1]	= unsortedCoords1[pz]
				unsortedCoords1[pz]		= tt
				pz						= pz - 1
			else
				pz = 0
			endif
		endwhile
	next zz
return

"insertionSort2":
	nn = vardim1(unsortedCoords2)
	for zz = 1 to nn
		pz	= zz
		while pz > 1 do
			if unsortedCoords2[pz - 1][1] > unsortedCoords2[pz][1] then
				tt1							= unsortedCoords2[pz - 1][1]
				tt2							= unsortedCoords2[pz - 1][2]
				unsortedCoords2[pz - 1][1]	= unsortedCoords2[pz][1]
				unsortedCoords2[pz - 1][2]	= unsortedCoords2[pz][2]
				unsortedCoords2[pz][1]		= tt1
				unsortedCoords2[pz][2]		= tt2
				pz							= pz - 1
			else
				pz = 0
			endif
		endwhile
	next zz
return

!!"oldSort1":
!!	nn = vardim1(unsortedCoords1)
!!	dim sortedCoords1[]
!!	for zz = 1 to nn
!!		iz = 1
!!		pz = 1
!!		repeat
!!			if unsortedCoords1[iz] <= unsortedCoords1[pz] then
!!				pz = pz+1
!!			else
!!				pz = iz
!!				iz = iz+1
!!			endif
!!		until pz> nn
!!
!!		sortedCoords1[zz]	= unsortedCoords1[iz]
!!
!!		unsortedCoords1[iz]	= 1000000	!!Move out (very large length)
!!	next zz
!!return
!!
!!"oldSort2":
!!	nn = vardim1(unsortedCoords2)
!!	dim sortedCoords2[][2]
!!	for zz = 1 to nn
!!		iz = 1
!!		pz = 1
!!		repeat
!!			if unsortedCoords2[iz][1] <= unsortedCoords2[pz][1] then
!!				pz = pz+1
!!			else
!!				pz = iz
!!				iz = iz+1
!!			endif
!!		until pz> nn
!!
!!		sortedCoords2[zz]		= unsortedCoords2[iz]
!!
!!		unsortedCoords2[iz][1]	= 1000000	!!Move out (very large length)
!!		unsortedCoords2[iz][2]	= 0
!!	next zz
!!return

"prevSorter":
	dim unsortedCoords2[][2]
	for z = nCurrentGroutPoint to 1 step -1
		unsortedCoords2[z][1] = currentGroutPoint[z]
		unsortedCoords2[z][2] = 0
	next z
	gosub "insertionSort2"
	dim prevGroutPoint[]
	for z = nCurrentGroutPoint to 1 step -1
		prevGroutPoint[z] = unsortedCoords2[z][1]
	next z
	nPrevGroutPoint = nCurrentGroutPoint
return


!!! ==============================================================================
!!! Array Sorter
!!! ------------------------------------------------------------------------------
!!! Input variables:
!!!	unsortedCoords:		Coord Array
!!!
!!! Returned variable:
!!!	sortedCoords:		Sorted Array
!!! ==============================================================================
!!dim unsortedCoords[]
!!
!!"arraySorter":
!!	dim sortedCoords[]
!!	actInd = 1
!!	
!!	indexNum = vardim1(unsortedCoords)
!!	
!!	repeat
!!		removed = 0
!!		sortedCoords[actInd] = unsortedCoords[1]
!!
!!		for arInd = 1 to vardim1(unsortedCoords)
!!			if unsortedCoords[arInd] <= sortedCoords[actInd] then
!!				sortedCoords[actInd] = unsortedCoords[arInd]
!!				removed = arInd
!!			endif
!!		next arInd
!!
!!		if removed > 0 then
!!			dim tt[]
!!			curIndx = 0
!!			for arInd = 1 to vardim1(unsortedCoords)
!!				if arInd <> removed then
!!					curIndx = curIndx + 1
!!					tt[curIndx] = unsortedCoords[arInd]
!!				endif
!!			next arInd
!!
!!			dim unsortedCoords[]
!!			for arInd = vardim1(tt) to 1 step -1
!!				unsortedCoords[arInd] = tt[arInd]
!!			next arInd
!!		endif
!!	
!!		actInd = actInd + 1
!!	until actInd > indexNum
!!return


! ------------------------------------------------------------------------------
"beamOsszevono":
! ------------------------------------------------------------------------------
	!Megnézzük hogy az indexek között megvan mind a kettő addig vonunk össze

	!Az összevonandó gerendák közti távolság meghatározása
	idxN	= tBeamsIdx[1]
	uniMax	= datBeamOverhang[ linderTypes[idxN][LINDER_IDX] ] * 2 - 2*BIGEPS
	if linderTypes[idxN][LINDER_TYPE] = BEAM_TYP_BLOCK then
		uniMax = datBeamSize[ linderTypes[idxN][LINDER_IDX] ][BRICKSIZE_WIDTH] * 2
	endif
	if linderTypes[idxN][LINDER_TYPE] = BEAM_TYP_RANGE then
		uniMax = 0.5		!TODO
	endif

	!Azoknak az áthidaloknak a tömbje amelyek össze kell vonni
	dim splittedBeams[][], nSplitBeams[]
	for zz = n to 1 step -1
		nSplitBeams[zz] = 0
	next zz
	splittedBeams[1][1]	= tBeamsIdx[1]
	nSplitBeams[1]		= 1
	lastX				= linderCoords[ tBeamsIdx[1] ][1] + linderCoords[ tBeamsIdx[1] ][LINDER_OPENING_SIZE]/2
	nB					= 1

	for zz = 2 to n
		preX = linderCoords[ tBeamsIdx[zz] ][1] - linderCoords[ tBeamsIdx[zz] ][LINDER_OPENING_SIZE]/2
		diff = preX - lastX
		if diff < uniMax + BIGEPS or (linderTypes[idxN][LINDER_TYPE] = BEAM_TYP_BLOCK | linderTypes[idxN][LINDER_TYPE] = BEAM_TYP_RANGE) then
			nSplitBeams[nB]						= nSplitBeams[nB] + 1
			splittedBeams[nB][nSplitBeams[nB]] 	= tBeamsIdx[zz]
		else
			nB									= nB + 1
			nSplitBeams[nB]						= nSplitBeams[nB] + 1
			splittedBeams[nB][nSplitBeams[nB]] 	= tBeamsIdx[zz]
		endif
		lastX = linderCoords[ tBeamsIdx[1] ][1] + linderCoords[ tBeamsIdx[zz] ][LINDER_OPENING_SIZE]/2
	next zz


	!Az összevonás
	for ii = 1 to nB
		dim tBeams[], unsortedCoords2[][2]
		nLargestIdx = 0
		gg			= 0
		for zz = nSplitBeams[ii] to 1 step -1
			tBeams[zz]				= splittedBeams[ii][zz]
			gg						= gg + 1
			unsortedCoords2[gg][1]	= linderCoords[ tBeams[zz] ][LINDER_CENTER_X] - linderCoords[ tBeams[zz] ][LINDER_LENGTH] / 2 + BEAM_UNIEPS
			unsortedCoords2[gg][2]	= tBeams[zz]
			gg						= gg + 1
			unsortedCoords2[gg][1]	= linderCoords[ tBeams[zz] ][LINDER_CENTER_X] + linderCoords[ tBeams[zz] ][LINDER_LENGTH] / 2 - BEAM_UNIEPS
			unsortedCoords2[gg][2]	= tBeams[zz]
			if nLargestIdx < tBeams[zz] then nLargestIdx = tBeams[zz]
		next zz
		gosub "insertionSort2"
		dim tempIdx[]
		nS = vardim1(unsortedCoords2)
		for zz = nS to 1 step -1
			tempIdx[zz] = unsortedCoords2[zz][2]
		next zz
	
		dim usedIdx[]
		for zz = nLargestIdx to 1 step -1
			usedIdx[zz] = 0
		next zz
	
		startIdx = tempIdx[1]
		for zi = 1 to nS
			idt = tempIdx[zi]
			if usedIdx[idt] > 0 then
				!Check megnézni hogy minden kettes e kivéve ezt
				bLast = 1
				for hh = 1 to nLargestIdx
					if hh <> idt then
						if usedIdx[hh] < 2 & usedIdx[hh] > 0 then
							bLast	= 0
							hh		= nLargestIdx
						endif
					endif
				next hh

				if bLast then
					!Na itt van vége az elemnek

					openSPoint	= linderCoords[startIdx][LINDER_CENTER_X] - linderCoords[startIdx][LINDER_OPENING_SIZE] / 2
					openEPoint	= linderCoords[idt][LINDER_CENTER_X] + linderCoords[idt][LINDER_OPENING_SIZE] / 2
					uniOpenSize	= openEPoint - openSPoint
					checkIdx	= startIdx

					openIdx					= checkIdx
					iBeamTyp				= linderTypes[checkIdx][LINDER_TYPE]
					_beamPreferFamily		= linderTypes[checkIdx][LINDER_FAMILY_NAME]
					_beamPreferFamilyIdx	= linderTypes[checkIdx][LINDER_FAMILY_IDX]
					_beamPreferType			= linderTypes[checkIdx][LINDER_TYPE]
					bCenterPosX				= openSPoint + (openEPoint - openSPoint)/2
					bCenterPosY				= linderCoords[checkIdx][LINDER_CENTER_Y]
					bOpeningSizeX			= uniOpenSize
					bOverhang				= linderCoords[checkIdx][LINDER_OVERHANG]
					bHeight					= linderCoords[checkIdx][LINDER_HEIGHT]

					gosub "BeamSelector"
	
					nLinderUnified							= nLinderUnified + 1
					unifiedLinderTypes[nLinderUnified][1]	= bTypes[1]
					unifiedLinderTypes[nLinderUnified][2]	= bTypes[2]
					unifiedLinderTypes[nLinderUnified][3]	= bTypes[3]
					unifiedLinderTypes[nLinderUnified][4]	= bTypes[4]
					unifiedLinderTypes[nLinderUnified][5]	= bTypes[5]
					unifiedLinderTypes[nLinderUnified][6]	= bTypes[6]
					unifiedLinderTypes[nLinderUnified][7]	= bTypes[7]
					unifiedLinderTypes[nLinderUnified][8]	= bTypes[8]
					unifiedLinderTypes[nLinderUnified][9]	= bTypes[9]
					unifiedLinderCoords[nLinderUnified][1]	= bCoords[1]
					unifiedLinderCoords[nLinderUnified][2]	= bCoords[2]
					unifiedLinderCoords[nLinderUnified][3]	= bCoords[3]
					unifiedLinderCoords[nLinderUnified][4]	= bCoords[4]
					unifiedLinderCoords[nLinderUnified][5]	= bCoords[5]
					unifiedLinderCoords[nLinderUnified][6]	= bCoords[6]

					gosub "beamUniCounter"

					if zi < nS then
						startIdx = tempIdx[zi+1]
					endif
	
					for jj = nLargestIdx to 1 step -1
						usedIdx[jj] = 0
					next jj
				else
					usedIdx[idt] = usedIdx[idt] + 1
				endif
			else
				usedIdx[idt] = usedIdx[idt] + 1
			endif
		next zi
	next ii
return

! ------------------------------------------------------------------------------
"beamUniCounter":
! ------------------------------------------------------------------------------
	nCounter = 0
	for hh = 1 to nLargestIdx
		if usedIdx[hh] = 2 then
			nCounter = nCounter + 1
			unifiedLinderIdxs[nLinderUnified][nCounter]	= hh
		endif
	next hh
	unifiedLinderNums[nLinderUnified] 		= nCounter 
return


! ------------------------------------------------------------------------------
"beamHoleOsszevono":
! ------------------------------------------------------------------------------
	!Megnézzük hogy az indexek között megvan mind a kettő addig vonunk össze

	dim tempIdx[]
	nLargestIdx = 0
	nn = vardim1(unsortedCoords2)
	for zz = nn to 1 step -1
		tempIdx[zz]	= round_int(unsortedCoords2[zz][2])
		if nLargestIdx < tempIdx[zz] then nLargestIdx = tempIdx[zz]
	next zz

	dim usedIdx[]
	for zz = nLargestIdx to 1 step -1
		usedIdx[zz] = 0
	next zz

	startIdx = tempIdx[1]
	for zz = 1 to nn
		idt = tempIdx[zz]
		if usedIdx[idt] > 0 then
			!Check megnézni hogy minden kettes e kivéve ezt
			bLast = 1
			for hh = 1 to nLargestIdx
				if hh <> idt then
					if usedIdx[hh] < 2 & usedIdx[hh] > 0 then
						bLast	= 0
						hh		= nLargestIdx
					endif
				endif
			next hh

			if bLast then
				!Na itt van vége az elemnek

				beamSPoint = usedLinderCoords[startIdx][LINDER_CENTER_X] - usedLinderCoords[startIdx][LINDER_LENGTH] / 2
				openSPoint = usedLinderCoords[startIdx][LINDER_CENTER_X] - usedLinderCoords[startIdx][LINDER_OPENING_SIZE] / 2
				beamEPoint = usedLinderCoords[idt][LINDER_CENTER_X] + usedLinderCoords[idt][LINDER_LENGTH] / 2
				openEPoint = usedLinderCoords[idt][LINDER_CENTER_X] + usedLinderCoords[idt][LINDER_OPENING_SIZE] / 2

				nLinderGeomUnified													= nLinderGeomUnified + 1
				unifiedGeomLinderCoords[nLinderGeomUnified][LINDER_CENTER_X]		= beamSPoint + (beamEPoint - beamSPoint)/2
				unifiedGeomLinderCoords[nLinderGeomUnified][LINDER_CENTER_Y]		= usedLinderCoords[idt][LINDER_CENTER_Y]
				unifiedGeomLinderCoords[nLinderGeomUnified][LINDER_LENGTH]			= beamEPoint - beamSPoint
				unifiedGeomLinderCoords[nLinderGeomUnified][LINDER_HEIGHT]			= usedLinderCoords[idt][LINDER_HEIGHT]
				unifiedGeomLinderCoords[nLinderGeomUnified][LINDER_OPENING_SIZE]	= openEPoint - openSPoint
				unifiedGeomLinderCoords[nLinderGeomUnified][LINDER_OVERHANG]		= usedLinderCoords[startIdx][LINDER_OVERHANG]

				if zz < nn then
					startIdx = tempIdx[zz+1]
				endif

				for jj = nLargestIdx to 1 step -1
					usedIdx[jj] = 0
				next jj
			else
				usedIdx[idt] = usedIdx[idt] + 1
			endif
		else
			usedIdx[idt] = usedIdx[idt] + 1
		endif
	next zz
return


! ==============================================================================
! Check Bounding box intersection
! ------------------------------------------------------------------------------
! Input variables:
!	boxAminX
!	boxAmaxX
!	boxAminY
!	boxAmaxY
!
!	boxBminX
!	boxBmaxX
!	boxBminY
!	boxBmaxY
!
! Returned variables:
!	state		0: No itersection
!				1 intersected
! ==============================================================================
"checkBoxIntersection":

	!!! If one rectangle is on left side of other
	!!if (boxAminX > boxBmaxX | boxBminX > boxAmaxX) then
	!!	state = 0
	!!	return
	!!endif
	!!
	!!! If one rectangle is above other
	!!if (boxAmaxY < boxBminY | boxBmaxY < boxAminY) then
	!!	state = 0
	!!	return
	!!endif

	! What if these two conditions combined
	if boxAminX-EPS > boxBmaxX | boxBminX > boxAmaxX-EPS | boxAmaxY < boxBminY | boxBmaxY < boxAminY then
		state = 0
	else
		state = 1
	endif

	!!aWidth	= boxAmaxX - boxAminX
	!!bWidth	= boxBmaxX - boxBminX
	!!aHeight	= boxAmaxY - boxAminY
	!!bHeight	= boxBmaxY - boxBminY

	!!state = (abs(boxAminX - boxBminX) * 2 < (aWidth + bWidth)) & (abs(boxAminY - boxBminY) * 2 < (aHeight + bHeight))
return


"brickRasterHalfprefer":
	if distance < BIGEPSCM then return

	gosub "brickTypeCalc"
	if brickH - topCut < minBrickHeight + EPS then
		return
	endif
	place				= 1
	bFirstBrick			= 1
	bLastBrick			= 0
	checkSpecial		= 1
	lastX				= xx1
	visszaszedLastX		= xx1
	problematicLastX	= xx1
	nCurrentGroutPoint						= nCurrentGroutPoint + 1
	currentGroutPoint[nCurrentGroutPoint]	= xx1
	while lastX < xx2-BIGEPSCM do
		bCheckLength		= 1
		nTeglaVisszaSzed	= 0
		_brickType			= preBrickType
		_brickW				= brickWidth
		if lastX + _brickW > xx2-BIGEPSCM then
			_brickW			= xx2 - lastX
		endif
		placeSpecial		= 0
		gosub "CheckSpecialElement"
		if placeSpecial then
			bFirstBrick = 0
		else
			if bFirstBrick then
				gosub "firstBrickCheckHalf"
				bFirstBrick = 0
			else
				gosub "brickSizeCheckHalf"
			endif
			gosub "AddStandardBrick"
		endif
	endwhile
	nCurrentGroutPoint						= nCurrentGroutPoint + 1
	currentGroutPoint[nCurrentGroutPoint]	= xx2
return


"brickRaster":
	if distance < BIGEPSCM then return

	gosub "brickTypeCalc"
	if brickH - topCut < minBrickHeight + EPS then
		return
	endif

	place				= 1
	bFirstBrick			= 1
	bLastBrick			= 0
	checkSpecial		= 1
	lastX				= xx1
	visszaszedLastX		= xx1
	problematicLastX	= xx1
	nCurrentGroutPoint						= nCurrentGroutPoint + 1
	currentGroutPoint[nCurrentGroutPoint]	= xx1
	while lastX < xx2-BIGEPSCM do
		bCheckLength		= 1
		nTeglaVisszaSzed	= 0
		_brickType			= preBrickType
		_brickW				= brickWidth
		if lastX + _brickW > xx2-BIGEPSCM then
			_brickW			= xx2 - lastX
		endif
		placeSpecial		= 0
		gosub "CheckSpecialElement"
		if placeSpecial then
			bFirstBrick = 0
		else
			if bFirstBrick then
				gosub "firstBrickCheck"
				bFirstBrick = 0
			else
				gosub "brickSizeCheck"
			endif
			if _brickW > minBrickSize-BIGEPS*5 then
				gosub "AddStandardBrick"
			endif
		endif
	endwhile
	nCurrentGroutPoint						= nCurrentGroutPoint + 1
	currentGroutPoint[nCurrentGroutPoint]	= xx2
return


"firstBrickCheckHalf":
	gosub "firstBrick"
	if ret = 0 then return


	!-------- Elöször megprobáljuk az alattalevő tengelyéhez igazitani -------------
	fx	= lastX + _brickW
	for f = 1 to nPrevGroutPoint-1
		if fx >= prevGroutPoint[f] & fx <= prevGroutPoint[f+1] then						!Két pont között van
			pd = prevGroutPoint[f+1]-prevGroutPoint[f]

			fugaDist1 = fx - prevGroutPoint[f]
			fugaDist2 = prevGroutPoint[f+1] - fx

			if fugaDist1 < minBrickOverlap-eps | fugaDist2 < minBrickOverlap-eps then
				if f > 1 then
					if f < nPrevGroutPoint - 2 then		!TODO ez itt kurva nagy hack
						halfPoint	= prevGroutPoint[f+1] + (prevGroutPoint[f+2]-prevGroutPoint[f+1])/2
						tb			= halfPoint - lastX
						if tb > minBrickSize - BIGEPS & tb < brickWidth + BIGEPS then
							tBrickW = tb
							gosub "fugaCheck"
							if iFuga = FUGA_NONE then
								_brickW = tBrickW
								return
							endif
						endif
					endif

					if prevGroutPoint[f]-prevGroutPoint[f-1] > minBrickSize then
						halfPoint	= prevGroutPoint[f-1] + (prevGroutPoint[f]-prevGroutPoint[f-1])/2
						tb			= halfPoint - lastX
						if tb > minBrickSize - BIGEPS then
							tBrickW = tb
							gosub "fugaCheck"
							if iFuga = FUGA_NONE then
								_brickW = tBrickW
								return
							endif
						endif
					endif
				endif
			endif

			if pd < brickWidth + BIGEPS & pd > minBrickSize then				!!Tégla között van
				halfPoint = prevGroutPoint[f] + pd/2
				if halfPoint - lastX < brickWidth + BIGEPS then					!Helyben vagyunk tudjuk felesbe rakni
					tb	= halfPoint - lastX
					if tb > minBrickSize - BIGEPS then
						tBrickW = tb
						gosub "fugaCheck"
						if iFuga = FUGA_NONE then
							_brickW = tBrickW
							return
						endif
					endif
					if (halfPoint - fx) < KOZEPEPS & iRowLength > ROWLENGTH_MEDIUM then 		!Megprobáljuk a feles közelihez igazitani már közepes sornál
						tBrickW = max(minBrickSize, tb)
						gosub "fugaCheck"
						if iFuga = FUGA_NONE then
							_brickW = tBrickW
							return
						endif
					endif
				endif
			endif
		endif
	next f

	!_brickW	= brickWidth		!TODO ez itt nem biztos hogy jó
	tBrickW	= _brickW
	gosub "brickSizeCheckHalf"
return

"firstBrick":
	ret				= 0
	lastX			= xx1
	checkSpecial	= 1

    fx = lastX + _brickW
    if fx > xx2-BIGEPS then
		_brickW = xx2 - lastX
		return
	endif

	if s1 = STATUS_ABOVE_LINDER | s2 = STATUS_ABOVE_LINDER then
		_brickW	= brickWidth
	else
		!!if distance < 2*brickWidth+BIGEPS then
		if startBigCsorba then
			_brickW = brickWidth/2
			tBrickW = _brickW
			gosub "fugaCheck"
			if iFuga = FUGA_NONE then
				_brickW = tBrickW
				return
			endif
		else
			if iRowLength = ROWLENGTH_SMALL then
				if bcs1 | bcs2 then
					if bcs1 then
						otherBrick	= min(max(distance-endElemWidth, minBrickSize), brickWidth)
						_brickW	= distance - otherBrick
	
						tBrickW = _brickW
						gosub "fugaCheck"
						if iFuga = FUGA_NONE then
							_brickW = tBrickW
							return
						endif
	
						tBrickW = otherBrick
						gosub "fugaCheck"
						if iFuga = FUGA_NONE then
							_brickW = tBrickW
							return
						endif
					else
						_brickW	= min(max(distance-endElemWidth, minBrickSize), brickWidth)
	
						tBrickW = _brickW
						gosub "fugaCheck"
						if iFuga = FUGA_NONE then
							_brickW = tBrickW
							return
						endif
	
						tBrickW = distance - _brickW
						gosub "fugaCheck"
						if iFuga = FUGA_NONE then
							_brickW = tBrickW
							return
						endif
					endif
					
				else
					if eltoltSor then
						_brickW	= min(max(distance-brickWidth, minBrickSize), brickWidth)
		
						tBrickW = _brickW
						gosub "fugaCheck"
						if iFuga = FUGA_NONE then
							_brickW = tBrickW
							return
						endif
		
						tBrickW = distance - _brickW
						gosub "fugaCheck"
						if iFuga = FUGA_NONE then
							_brickW = tBrickW
							return
						endif
					else
						otherBrick	= min(max(distance-brickWidth, minBrickSize), brickWidth)
						_brickW	= distance - otherBrick
		
						tBrickW = _brickW
						gosub "fugaCheck"
						if iFuga = FUGA_NONE then
							_brickW = tBrickW
							return
						endif
		
						tBrickW = otherBrick
						gosub "fugaCheck"
						if iFuga = FUGA_NONE then
							_brickW = tBrickW
							return
						endif
					endif
				endif
	
			else
				if eltoltSor then
					_brickW	= brickWidth/2
					if not(bcs1) & (s1 = STATUS_CSORBA_1 | s1 = STATUS_CSORBA_2) then
						if abs(csorbaX1 - brickWidth/2) < 0.01 then _brickW	= brickWidth
					endif
				else
					_brickW	= brickWidth
				endif
	
				if bcs1 then
					_brickW	= endElemWidth	!min(max(_brickW, csorbaX1 + minBrickOverlap), brickWidth)	!TODO melyiket
					tBrickW = _brickW
					gosub "fugaCheck"
					if iFuga = FUGA_NONE then
						_brickW = tBrickW
						return
					endif
				endif
			endif
		endif
	endif

	ret = 1
return

"firstBrickCheck":
	gosub "firstBrick"
	if ret = 0 then return

	tBrickW	= _brickW
	gosub "fugaCheck"
	gosub "brickSizeCheck"
return

"brickSizeCheckHalf":
	fx	= lastX + _brickW
	if fx > xx2-BIGEPS then
		_brickW = xx2-lastX
		return
	endif

	tBrickW	= _brickW
	gosub "fugaCheck"

	!-------- Fugában van -------------
	if iFuga then
		if bFugaDebug & GLOB_SCRIPT_TYPE = 3 then
			!print "fugaütközés sor", iFuga, nSor, "oszlop", nBrick-rowIndex[nSor][1], fugaDist1, fugaDist2, _brickW
			add lastX + _brickW, -brickThk, currentMag
			if iFuga = FUGA_BRICK then
				sphere 0.04
			else
				sphere 0.02
			endif
			del 1
		endif

		if iFuga = FUGA_SECTION then
			gosub "brickSizeCheckHalfTop"
		else
			gosub "brickSizeCheckHalfBottom"
		endif
	else
		if iRowLength > ROWLENGTH_NORMAL then	!ha nagy a sor akkor a második téglát megprobáljuk fugára igazitani
			if nBrick = colStartIdx + 1 then
				if abs(fugaDist1 - fugaDist2) > BIGEPSCM then
					!-------- Nincs prevGroutPoint tömb vagy áthidaló felett van ----------
					if nPrevGroutPoint < 1 | (s1 = STATUS_ABOVE_LINDER & s2 = STATUS_ABOVE_LINDER) then return
				
					!-------- kivul van a méreten -------------------
					fx	= lastX + _brickW
					if fx > prevGroutPoint[nPrevGroutPoint] + KOZEPEPS then return
				
					!-------- Fugadist tesztelése -------------
					wPoint = 0
					for w = nPrevGroutPoint to 1 step -1
						if w < nPrevGroutPoint then
							if fx >= prevGroutPoint[w] & fx <= prevGroutPoint[w+1] then
								wPoint = w
							endif
						else
							if abs(prevGroutPoint[w] - fx) < KOZEPEPS then
								wPoint = w
							endif
						endif
					next w

					if wPoint > 0 then
						tb = (prevGroutPoint[wPoint] + (fugaDist1 + fugaDist2) / 2) - lastX
						if tb > minBrickSize - BIGEPS & tb < brickWidth + BIGEPS then
							tBrickW	= tb
							gosub "fugaCheck"
							if iFuga = FUGA_NONE then
								_brickW = tBrickW
								return
							endif
						endif
					endif
				endif
			endif
		endif
	endif
return

"brickSizeCheckHalfTop":
	!Eltesszük az értékeket mert felülvágja a vizsgálat
	tFugaDist1	= fugaDist1
	tFugaDist2	= fugaDist2

	! ------------ Ha teljes méretű akkor megprobáljuk leszedni háromnegyedes téglára ---------------------
	if abs(brickWidth-_brickW) < EPS then
		tBrickW = brickWidth - KOZEPEPS
		gosub "fugaCheck"
		if iFuga = FUGA_NONE then
			_brickW = tBrickW
			return
		endif
	endif

	! ------------ Ha kisebb mint feles tégla akkor felnöveljük egy negyedtéglával ---------------------
	if _brickW < brickWidth/2 + BIGEPS then
		tBrickW = brickWidth - KOZEPEPS
		gosub "fugaCheck"
		if iFuga = FUGA_NONE then
			_brickW = tBrickW
			return
		endif
	endif

	! ------------ Fugákhoz teszteljük (ez olyan mint a sima) ---------------------
	if tFugaDist1 < minBrickOverlap-eps then
		if abs(brickWidth-_brickW) < EPS then
			tb = brickWidth - tFugaDist1 - minBrickOverlap
			if tb > minBrickSize - BIGEPS then
				tBrickW	= tb
				gosub "fugaCheck"
				if iFuga = FUGA_NONE then
					_brickW = tBrickW
					return
				endif
			endif
		endif
	endif

	if tFugaDist2 < minBrickOverlap-eps then
		if abs(brickWidth-_brickW) < EPS then
			tb = brickWidth - (minBrickOverlap - tFugaDist2) 
			if tb > minBrickSize - BIGEPS then
				tBrickW	= tb
				gosub "fugaCheck"
				if iFuga = FUGA_NONE then
					_brickW = tBrickW
					return
				endif
			endif
		endif
	endif

	gosub "veryProblematicBrick"
return

"brickSizeCheckHalfBottom":
	!Eltesszük az értékeket mert felülvágja a vizsgálat
	tFugaDist1	= fugaDist1
	tFugaDist2	= fugaDist2

	!-------- Utolsó tesztelése -------------
	fx	= lastX + _brickW
	if nPrevGroutPoint > 0 then
		if fx > prevGroutPoint[nPrevGroutPoint]+BIGEPS then
			pd = prevGroutPoint[nPrevGroutPoint]-prevGroutPoint[nPrevGroutPoint-1]
			halfPoint = prevGroutPoint[nPrevGroutPoint-1] + pd/2
			tb	= halfPoint - lastX
			if tb > EPS then
				if tb + HALFEPS > brickWidth - EPS & pd > minBrickSize then
					tBrickW = brickWidth	
				else			
					tBrickW = max(tb, minBrickSize)
				endif
				gosub "fugaCheck"
				if iFuga = FUGA_NONE then
					_brickW = tBrickW
					return
				endif
				gosub "veryProblematicBrick"
				return
			endif		
		endif
	endif

	!-------- Köztesek tesztelése -------------
	for f = nPrevGroutPoint-1 to 1 step -1
		if fx <= prevGroutPoint[f+1]+BIGEPSCM & fx >= prevGroutPoint[f] then							!Két pont között van
			pd = prevGroutPoint[f+1]-prevGroutPoint[f]
			if pd < brickWidth + BIGEPS then				!!Tégla között van
				halfPoint = prevGroutPoint[f] + pd/2
				if halfPoint - lastX < brickWidth + BIGEPS then		!Helyben vagyunk egész téglán belülre esik
					tb	= halfPoint - lastX
					if tb > EPS then
						if tb + HALFEPS > brickWidth - EPS & pd > minBrickSize then
							tBrickW = brickWidth	
						else	
							tBrickW = max(tb, minBrickSize)
						endif
						gosub "fugaCheck"
						if iFuga = FUGA_NONE then
							_brickW = tBrickW
							return
						endif
						gosub "veryProblematicBrick"
						return
					endif
				else
					if f > 1 then	!Második elem
						if prevGroutPoint[f]-prevGroutPoint[f-1] > minBrickSize then
							halfPoint	= prevGroutPoint[f-1] + (prevGroutPoint[f]-prevGroutPoint[f-1])/2
							tb			= halfPoint - lastX
							if tb > EPS then
								if tb + HALFEPS > brickWidth - EPS & pd > minBrickSize then
									tBrickW = brickWidth	
								else			
									tBrickW = max(tb, minBrickSize)
								endif
								gosub "fugaCheck"
								if iFuga = FUGA_NONE then
									_brickW = tBrickW
									return
								endif
								gosub "veryProblematicBrick"
								return
							endif
						else
							if f > 2 then
								halfPoint	= prevGroutPoint[f-2] + (prevGroutPoint[f-1]-prevGroutPoint[f-2])/2
								tb			= halfPoint - lastX
								if tb > EPS then
									if tb + HALFEPS > brickWidth - EPS & pd > minBrickSize then
										tBrickW = brickWidth	
									else			
										tBrickW = max(tb, minBrickSize)
									endif
									gosub "fugaCheck"
									if iFuga = FUGA_NONE then
										_brickW = tBrickW
										return
									endif
									gosub "veryProblematicBrick"
									return
								endif
							endif
						endif
					endif
				endif
			endif
		endif
	next f

	gosub "veryProblematicBrick"
return

"veryProblematicBrick":
	checkSpecial = 1
	gosub "vegtelenFugaCheckBack"
	if not(foundGoodPoint) then
		problematicLastX = lastX
		gosub "teglaVisszaSzed"	!TODO ez itt nagyon végtelen ciklusra tud futni amikor két egymást követő téglát kell visszaszedni
	endif
return


! ==============================================================================
! Per Brick Type Calculation
! ------------------------------------------------------------------------------
! Input variables:
!	currentMag
!	s1, s2
!
! Returned variables:
!	preBrickType		! Tégla tipusa
!	rowH				! Sor Magassága
! ==============================================================================
"brickTypeCalc":
	!Meghatározzuk hogy normal vagy alacsony tégláról van e szó
	
	preBrickType	= TYPE_NORMAL
	preBrick		= iProductType
	preBrickIdx		= idxProduct
	rowH			= currentMag
	brickH			= datBrickSize[idxProduct][BRICKSIZE_HEIGHT]
	topCut			= 0


	!Összenézés az áthidalókkal
	bBeamCutTop     = 0
	bBeamCutBottom  = 0
	for i = 1 to nLinderGeomUnified
		bb1 = unifiedGeomLinderCoords[i][LINDER_CENTER_X]-unifiedGeomLinderCoords[i][LINDER_LENGTH]/2 - BIGEPSCM
		bb2 = unifiedGeomLinderCoords[i][LINDER_CENTER_X]+unifiedGeomLinderCoords[i][LINDER_LENGTH]/2 + BIGEPSCM

		if xx1 > bb1 & xx2 < bb2 then		!Az áthidaló közt van
			!Áthidaló alatt van
			if abs(currentMag - yPos) < EPS then
				hDiffUnder = unifiedGeomLinderCoords[i][LINDER_CENTER_Y] - beamGroutThk - currentMag
				if BIGEPS < hDiffUnder & hDiffUnder < brickHeight + BIGEPS then
					topCut			= max(0, (currentMag + brickHeight) - (unifiedGeomLinderCoords[i][LINDER_CENTER_Y] - beamGroutThk))
					bBeamCutBottom  = 1
				endif
			else
				!Áthidaló Felett van
				rowH		= yPos
				hDiffAbove	= (currentMag+brickHeight) - (unifiedGeomLinderCoords[i][LINDER_CENTER_Y]+unifiedGeomLinderCoords[i][LINDER_HEIGHT])
				if BIGEPS < hDiffAbove & hDiffAbove  < brickHeight  + beamTopGroutThk + EPS then
					rowH            = unifiedGeomLinderCoords[i][LINDER_CENTER_Y] + unifiedGeomLinderCoords[i][LINDER_HEIGHT] + groutHorizontal
					topCut          = max(0, (rowH + brickHeight) - (currentMag + brickHeight))
					bBeamCutTop     = 1
				endif
			endif
		endif
	next i

	! Összenézés a lukakkal
	bOpeningBottomCut = 0
	if not(bBeamCutTop) & not(bBeamCutBottom) then
		for i = 1 to nOpeningPolygons
			bb1 = origOpeningBoundingBox[i][1]
			bb2 = origOpeningBoundingBox[i][3]
			if xx1 > bb1 - BIGEPSCM & xx2 < bb2 + BIGEPSCM then		!Between hole
				hDiff = origOpeningBoundingBox[i][2] - currentMag
				if BIGEPS < hDiff & hDiff < brickHeight + BIGEPS then
					topCut				= max(0, brickHeight-hDiff)
					bOpeningBottomCut	= 1
					i					= nOpeningPolygons
				endif
			endif
		next i
	endif
	
    ! Alsó sor
	if rowTypes[nSor] = ROWTYPE_HALF | rowTypes[nSor] = ROWTYPE_CUTTED then
		hDiff = brickHeight - (rowHeights[nSor][1] - groutHorizontal)
		if abs(hDiff) > BIGEPS then
			!topCut = max(0, brickHeight - hDiff)
			topCut = max(0, hDiff)
		endif
	endif

	!Az utolsó sorban van
	bLastSor = 0
	if nSor = nMagPoint & not(bOpeningBottomCut) then
		_brickH = brickHeight - topCut
		_brickY = rowH
		if _brickY + _brickH > surfaceYmax - topSpace - BIGEPS then
			topCut = max(0.0, (_brickY + brickHeight)-(surfaceYmax - topSpace))
			if elemHalf > 0 then
				bLastSor = 1
				if _brickY + halfElemHeight > surfaceYmax - topSpace - BIGEPSCM - BIGEPS then
					preBrickType	= TYPE_LOW
					preBrick		= elemHalf
					preBrickIdx		= elemHalfIdx
					brickH			= halfElemHeight
					_topCut			= max(0.0, (_brickY + halfElemHeight)-(surfaceYmax - topSpace))
					if bBeamCutTop then
						topCut = min(topCut, _topCut)
					else
						topCut = _topCut
					endif
				endif
			endif
		endif
	endif

	!Félelemek vizsgálata
	if elemHalf > 0 & not(bLastSor) then
		if brickH - topCut < halfElemHeight + BIGEPSCM then 
			if preBrickType <> TYPE_LOW then  
				preBrickType    = TYPE_LOW
				preBrick		= elemHalf
				preBrickIdx		= elemHalfIdx
				brickH          = halfElemHeight 
				!!topCut          = max(0, halfElemHeight - (brickH - topCut))
				topCut          = max(0, topCut - halfElemHeight)
			endif     
		endif
	endif
return


"calculateBrickDir":
	!TODO nem tudom mit csináljak pontosan
	!itt még lehet az a gond is a különböző szakaszoknál egymásba kell tolni a téglákat ami a blockos modban gondot okozhat

	needForgo	= 0
	esBrickDir	= brickDir
	if iWallType <> WALLTYPE_INTERNAL_WALL then
		if bcs1 & bcs2 then	
			needForgo	= 1 * abs(forgoNut) > EPS
			esBrickDir	= 1
		else
			if bcs1 | bcs2 then
				if bcs1 then
					esBrickDir = 1
				else
					esBrickDir = 0
				endif
			endif
		endif
	endif
return


"CheckStatusVertical":
    startX  = xx1
    endX    = xx2

    if not(bcs1) & (s1 = STATUS_LINDER | s1 = STATUS_UNDER_LINDER | s1 = STATUS_ABOVE_LINDER) then
        startX = startX + groutVertical
	endif
    if not(bcs2) & (s2 = STATUS_LINDER | s2 = STATUS_UNDER_LINDER | s2 = STATUS_ABOVE_LINDER) then
        endX = endX - groutVertical
	endif
return


"CalcColumnData":
	gosub "calculateBrickDir"
	gosub "CheckStatusVertical"
	startPointX		= startX 
	endPointX		= endX
	distance		= endX - startX
	!brickDir        = esBrickDir	!TODO Szerintem ez nem jó
	minLengthColumn	= 0.0
	minOverlap		= 0.0
	sectDist		= 0.0
	startBigCsorba	= 0
	nSpec			= 0
	dim specials[][9]


	if elemColumn then
		minLengthColumn = max(datBrickSize[elemColumnIdx][BRICKSIZE_THK] + 0.1, datBrickSize[elemColumnIdx][BRICKSIZE_HEIGHT] * 0.4)        !DE
	endif
	
	!TODO ha van nutolás akkor azzal foglalkozni kell "needForgo"  needForgo * parameters.brick.brickNutSize
	!FIXME itt most a téglák mindig a speciális élükkel számítanak mert így egyszerűbb számolni (a databan a nonstandard elemek mirror poziciója lesz figylembe véve lehelyezéskor)

	
	! Left
	if columnStart = COLUMN_CONCRETE_OFFSET & elemColumn then
		if bcs1 then
			dDist   = connWallStartThk + datBrickSize[elemColumnIdx][BRICKSIZE_THK]
			bLength = connWallStartThk / 2.0 + datBrickSize[elemColumnIdx][BRICKSIZE_THK]
			if dDist > datBrickSize[elemColumnIdx][BRICKSIZE_WIDTH] + BIGEPSCM then

				iLengthType	= BRICK_LENGTH_FIX
				type		= TYPE_END
				mirrored	= 0
				fixPointX	= startX
				length		= dDist - bLength - groutVertical
				minLength	= 0.0
				maxLength	= 0.0
				minPosX		= 0.0
				maxPosX		= 0.0
				gosub "AddSpecial"

				iLengthType	= BRICK_LENGTH_FIX
				type		= TYPE_COLUMN
				mirrored	= 1
				fixPointX	= startX + dDist
				length		= bLength
				minLength	= 0.0
				maxLength	= 0.0
				minPosX		= 0.0
				maxPosX		= 0.0
				gosub "AddSpecial"
			else
				iLengthType	= BRICK_LENGTH_FIX
				type		= TYPE_COLUMN
				mirrored	= 1
				fixPointX	= startX + dDist
				length		= dDist
				minLength	= 0.0
				maxLength	= 0.0
				minPosX		= 0.0
				maxPosX		= 0.0
				gosub "AddSpecial"
			endif
		else
			iLengthType	= BRICK_LENGTH_VAR
			type		= TYPE_COLUMN
			mirrored	= 0
			fixPointX	= startX
			length		= 0.0
			minLength	= minLengthColumn
			maxLength	= datBrickSize[elemColumnIdx][BRICKSIZE_WIDTH]
			minPosX		= 0.0
			maxPosX		= 0.0
			gosub "AddSpecial"
		endif
	else
		if columnStart = COLUMN_CONCRETE & elemColumn then
			if bcs1 then
				iLengthType	= BRICK_LENGTH_VAR
				type		= TYPE_COLUMN
				mirrored	= 0
				fixPointX	= startX
				length		= 0.0
				minLength	= minLengthColumn
				maxLength	= datBrickSize[elemColumnIdx][BRICKSIZE_WIDTH]
				minPosX		= 0.0
				maxPosX		= 0.0
				gosub "AddSpecial"
			else
				if s1 <> STATUS_CSORBA_1 & s1 <> STATUS_CSORBA_2 then
					if eltoltSor then
						iLengthType	= BRICK_LENGTH_FIX
						type		= TYPE_COLUMN
						mirrored	= 0
						fixPointX	= startX
						length		= datBrickSize[elemColumnIdx][BRICKSIZE_WIDTH]
						minLength	= 0.0
						maxLength	= 0.0
						minPosX		= 0.0
						maxPosX		= 0.0
						gosub "AddSpecial"
					else
						iLengthType	= BRICK_LENGTH_FIX
						type		= TYPE_COLUMN
						mirrored	= 0
						fixPointX	= startX
						length		= datBrickSize[elemColumnIdx][BRICKSIZE_WIDTH] / 2
						minLength	= 0.0
						maxLength	= 0.0
						minPosX		= 0.0
						maxPosX		= 0.0
						gosub "AddSpecial"
					endif
				endif
			endif
		else
			if bcs1 then
				if connWallStartIangle = ANGLE_PERPENDICULAR then
					if iHasEndElem = HAS_END_ELEM_SPECIAL & elemEnd then
						if (bcs2 & distance > 2 * datBrickSize[elemEnd][BRICKSIZE_WIDTH] - BIGEPS) | (not(bcs2) & distance > datBrickSize[elemEnd][BRICKSIZE_WIDTH] + minBrickSize - BIGEPS) then
							iLengthType	= BRICK_LENGTH_FIX
							type		= TYPE_END
							mirrored	= 0
							fixPointX	= startX
							length		= datBrickSize[elemEnd][BRICKSIZE_WIDTH]
							minLength	= 0.0
							maxLength	= 0.0
							minPosX		= 0.0
							maxPosX		= 0.0
							gosub "AddSpecial"
						endif
					else
						if iHasEndElem = HAS_END_ELEM_NORMAL then
							iLengthType	= BRICK_LENGTH_VAR
							type		= TYPE_END
							mirrored	= 0
							fixPointX	= startX
							length		= 0.0
							minLength	= minBrickSize
							maxLength	= datBrickSize[elemEnd][BRICKSIZE_WIDTH]
							minPosX		= 0.0
							maxPosX		= 0.0
							gosub "AddSpecial"
						endif
					endif
				else
					if connWallStartIangle = ANGLE_ACUTE | connWallStartIangle = ANGLE_OBTUSE then
						distBrickAxis   = connWallStartThk / sin(connWallStartAngle)
						minOverlap      = max(0.1, 0.4 * brickHeight)
						sectDist        = distBrickAxis + abs((brickThk/2) / tan(connWallStartAngle))

						if connWallStartIangle = ANGLE_ACUTE then
							sectDistOver    = sectDist + minOverlap
							if sectDistOver < brickWidth + BIGEPSCM then
								minLengthC	= max(minBrickSize, sectDistOver)

								iLengthType	= BRICK_LENGTH_VAR
								type		= TYPE_NORMAL
								mirrored	= 0
								fixPointX	= startX
								length		= 0.0
								minLength	= minLengthC
								maxLength	= brickWidth
								minPosX		= 0.0
								maxPosX		= 0.0
								gosub "AddSpecial"
							else
								startBigCsorba = 1

								iLengthType	= BRICK_LENGTH_POS
								type		= TYPE_NORMAL
								mirrored	= 0
								fixPointX	= startX
								length		= 0.0
								minLength	= minBrickSize
								maxLength	= brickWidth
								minPosX		= sectDist-minOverlap
								maxPosX		= sectDist+minOverlap
								gosub "AddSpecial"
							endif
						endif
	
						if connWallStartIangle = ANGLE_OBTUSE then
							sectDistOver    = sectDist + minOverlap
							if sectDistOver < brickWidth + BIGEPSCM then
								minLengthC	= max(minBrickSize, sectDistOver)

								iLengthType	= BRICK_LENGTH_VAR
								type		= TYPE_NORMAL
								mirrored	= 0
								fixPointX	= startX
								length		= 0.0
								minLength	= minLengthC
								maxLength	= brickWidth
								minPosX		= 0.0
								maxPosX		= 0.0
								gosub "AddSpecial"
							else
								startBigCsorba = 1

								iLengthType	= BRICK_LENGTH_POS
								type		= TYPE_NORMAL
								mirrored	= 0
								fixPointX	= startX
								length		= 0.0
								minLength	= minBrickSize
								maxLength	= brickWidth
								minPosX		= sectDist-minOverlap
								maxPosX		= sectDist+minOverlap
								gosub "AddSpecial"
							endif
						endif
					endif
				endif
			endif
		endif
	endif

	
	! Right
	if columnEnd = COLUMN_CONCRETE_OFFSET & elemColumn then
		if bcs2 then
			dDist   = connWallEndThk + datBrickSize[elemColumnIdx][BRICKSIZE_THK]
			bLength = connWallEndThk / 2.0 + datBrickSize[elemColumnIdx][BRICKSIZE_THK]
			if dDist > datBrickSize[elemColumnIdx][BRICKSIZE_WIDTH] + BIGEPSCM then
				iLengthType	= BRICK_LENGTH_FIX
				type		= TYPE_END
				mirrored	= 1
				fixPointX	= endX
				length		= dDist - bLength - groutVertical
				minLength	= 0.0
				maxLength	= 0.0
				minPosX		= 0.0
				maxPosX		= 0.0
				gosub "AddSpecial"

				iLengthType	= BRICK_LENGTH_FIX
				type		= TYPE_COLUMN
				mirrored	= 0
				fixPointX	= endX - dDist
				length		= bLength
				minLength	= 0.0
				maxLength	= 0.0
				minPosX		= 0.0
				maxPosX		= 0.0
				gosub "AddSpecial"
			else
				iLengthType	= BRICK_LENGTH_FIX
				type		= TYPE_COLUMN
				mirrored	= 1
				fixPointX	= endX - dDist
				length		= dDist
				minLength	= 0.0
				maxLength	= 0.0
				minPosX		= 0.0
				maxPosX		= 0.0
				gosub "AddSpecial"
			endif
		else
			iLengthType	= BRICK_LENGTH_VAR
			type		= TYPE_COLUMN
			mirrored	= 1
			fixPointX	= endX
			length		= 0.0
			minLength	= minLengthColumn
			maxLength	= datBrickSize[elemColumnIdx][BRICKSIZE_WIDTH]
			minPosX		= 0.0
			maxPosX		= 0.0
			gosub "AddSpecial"
		endif
	else
		if columnEnd = COLUMN_CONCRETE & elemColumn then
			if bcs2 then
				iLengthType	= BRICK_LENGTH_VAR
				type		= TYPE_COLUMN
				mirrored	= 1
				fixPointX	= endX
				length		= 0.0
				minLength	= minLengthColumn
				maxLength	= datBrickSize[elemColumnIdx][BRICKSIZE_WIDTH]
				minPosX		= 0.0
				maxPosX		= 0.0
				gosub "AddSpecial"
			else
				if s2 <> STATUS_CSORBA_1 & s2 <> STATUS_CSORBA_2 then
					if eltoltSor then
						iLengthType	= BRICK_LENGTH_FIX
						type		= TYPE_COLUMN
						mirrored	= 1
						fixPointX	= endX
						length		= datBrickSize[elemColumnIdx][BRICKSIZE_WIDTH]
						minLength	= 0.0
						maxLength	= 0.0
						minPosX		= 0.0
						maxPosX		= 0.0
						gosub "AddSpecial"
					else
						iLengthType	= BRICK_LENGTH_FIX
						type		= TYPE_COLUMN
						mirrored	= 1
						fixPointX	= endX
						length		= datBrickSize[elemColumnIdx][BRICKSIZE_WIDTH] / 2
						minLength	= 0.0
						maxLength	= 0.0
						minPosX		= 0.0
						maxPosX		= 0.0
						gosub "AddSpecial"
					endif
				endif
			endif
		else
			if bcs2 then
				if connWallEndIangle = ANGLE_PERPENDICULAR then
					if iHasEndElem = HAS_END_ELEM_SPECIAL & elemEnd then
						if (bcs1 & distance > 2 * datBrickSize[elemEnd][BRICKSIZE_WIDTH] - BIGEPS) | (not(bcs1) & distance > datBrickSize[elemEnd][BRICKSIZE_WIDTH] + minBrickSize - BIGEPS) then
							iLengthType	= BRICK_LENGTH_FIX
							type		= TYPE_END
							mirrored	= 1
							fixPointX	= endX
							length		= datBrickSize[elemEnd][BRICKSIZE_WIDTH]
							minLength	= 0.0
							maxLength	= 0.0
							minPosX		= 0.0
							maxPosX		= 0.0
							gosub "AddSpecial"
						endif
					else
						if iHasEndElem = HAS_END_ELEM_NORMAL then
							iLengthType	= BRICK_LENGTH_VAR
							type		= TYPE_END
							mirrored	= 1
							fixPointX	= endX
							length		= 0.0
							minLength	= minBrickSize
							maxLength	= datBrickSize[elemEnd][BRICKSIZE_WIDTH]
							minPosX		= 0.0
							maxPosX		= 0.0
							gosub "AddSpecial"
						endif
					endif
				else
					if connWallEndIangle = ANGLE_ACUTE | connWallEndIangle = ANGLE_OBTUSE then
						distBrickAxis   = connWallEndThk / sin(connWallEndAngle)
						minOverlap      = max(0.1, 0.4 * brickHeight)
						sectDist        = distBrickAxis + abs((brickThk/2) / tan(connWallEndAngle))
			
						if connWallEndIangle = ANGLE_ACUTE then
							sectDistOver    = sectDist + minOverlap
							minLengthC       = max(minBrickSize, sectDistOver)
							if sectDistOver < brickWidth + BIGEPSCM then
								iLengthType	= BRICK_LENGTH_VAR
								type		= TYPE_NORMAL
								mirrored	= 1
								fixPointX	= endX
								length		= 0.0
								minLength	= minLengthC
								maxLength	= brickWidth
								minPosX		= 0.0
								maxPosX		= 0.0
								gosub "AddSpecial"
							else
								iLengthType	= BRICK_LENGTH_POS
								type		= TYPE_NORMAL
								mirrored	= 0
								fixPointX	= endX
								length		= 0.0
								minLength	= minBrickSize
								maxLength	= brickWidth
								minPosX		= -(sectDist+minOverlap)
								maxPosX		= -(sectDist-minOverlap)
								gosub "AddSpecial"
							endif
						endif

						if connWallEndIangle = ANGLE_OBTUSE then
							sectDistOver    = sectDist + minOverlap
							minLengthC       = max(minBrickSize, sectDistOver)
							if sectDistOver < brickWidth + BIGEPSCM then
								iLengthType	= BRICK_LENGTH_VAR
								type		= TYPE_NORMAL
								mirrored	= 1
								fixPointX	= endX
								length		= 0.0
								minLength	= minLengthC
								maxLength	= brickWidth
								minPosX		= 0.0
								maxPosX		= 0.0
								gosub "AddSpecial"
							else
								iLengthType	= BRICK_LENGTH_POS
								type		= TYPE_NORMAL
								mirrored	= 0
								fixPointX	= endX
								length		= 0.0
								minLength	= minBrickSize
								maxLength	= brickWidth
								minPosX		= -(sectDist+minOverlap)
								maxPosX		= -(sectDist-minOverlap)
								gosub "AddSpecial"
							endif
						endif
					endif
				endif
			endif
		endif
	endif


	!Centers
	if elemColumn then
		for j = 1 to vardim1(midColumns)
			axis    = midColumns[j]
			dif     = datBrickSize[elemColumnIdx][BRICKSIZE_THK] / 2.0
			if eltoltSor then
				if brickDir then
					iLengthType	= BRICK_LENGTH_VAR
					type		= TYPE_COLUMN
					mirrored	= 1
					fixPointX	= axis + dif
					length		= 0.0
					minLength	= minLengthColumn
					maxLength	= datBrickSize[elemColumnIdx][BRICKSIZE_WIDTH]
					minPosX		= 0.0
					maxPosX		= 0.0
					gosub "AddSpecial"
				else
					iLengthType	= BRICK_LENGTH_VAR
					type		= TYPE_COLUMN
					mirrored	= 0
					fixPointX	= axis - dif
					length		= 0.0
					minLength	= minLengthColumn
					maxLength	= datBrickSize[elemColumnIdx][BRICKSIZE_WIDTH]
					minPosX		= 0.0
					maxPosX		= 0.0
					gosub "AddSpecial"
				endif
			else
				if brickDir then
					iLengthType	= BRICK_LENGTH_VAR
					type		= TYPE_COLUMN
					mirrored	= 0
					fixPointX	= axis - dif
					length		= 0.0
					minLength	= minLengthColumn
					maxLength	= datBrickSize[elemColumnIdx][BRICKSIZE_WIDTH]
					minPosX		= 0.0
					maxPosX		= 0.0
					gosub "AddSpecial"
				else
					iLengthType	= BRICK_LENGTH_VAR
					type		= TYPE_COLUMN
					mirrored	= 1
					fixPointX	= axis + dif
					length		= 0.0
					minLength	= minLengthColumn
					maxLength	= datBrickSize[elemColumnIdx][BRICKSIZE_WIDTH]
					minPosX		= 0.0
					maxPosX		= 0.0
					gosub "AddSpecial"
				endif
			endif
		next j
	endif

    !Windows
	if elemWindow & iWindowBrick then
		elemWinWidth	= datBrickSize[elemWindowIdx][BRICKSIZE_WIDTH]
		dist13			= elemWinWidth / 3.0
		dist23			= dist13 * 2

		if s1 = STATUS_DOOR then
			if s2 = STATUS_UNDER_LINDER & distance < elemWinWidth then
				iLengthType	= BRICK_LENGTH_FIX
				type		= TYPE_WINDOW
				mirrored	= 0
				fixPointX	= startX
				length		= distance
				minLength	= 0.0
				maxLength	= 0.0
				minPosX		= 0.0
				maxPosX		= 0.0
				gosub "AddSpecial"
			else
				if distance > elemWinWidth+groutVertical then
					if eltoltSor then
						iLengthType	= BRICK_LENGTH_CHOICE
						type		= TYPE_WINDOW
						mirrored	= 0
						fixPointX	= startX
						length		= 0.0
						minLength	= dist13
						maxLength	= dist23
						minPosX		= 0.0
						maxPosX		= 0.0
						gosub "AddSpecial"
					else
						iLengthType	= BRICK_LENGTH_CHOICE
						type		= TYPE_WINDOW
						mirrored	= 0
						fixPointX	= startX
						length		= 0.0
						minLength	= dist23
						maxLength	= dist13
						minPosX		= 0.0
						maxPosX		= 0.0
						gosub "AddSpecial"
					endif
				else
					if s2 = STATUS_DOOR then
						if distance > elemWinWidth/2-BIGEPS then
							dd = distance / 3
							if eltoltSor then
								iLengthType	= BRICK_LENGTH_FIX
								type		= TYPE_WINDOW
								mirrored	= 0
								fixPointX	= startX
								length		= dd
								minLength	= 0.0
								maxLength	= 0.0
								minPosX		= 0.0
								maxPosX		= 0.0
								gosub "AddSpecial"
							else
								iLengthType	= BRICK_LENGTH_FIX
								type		= TYPE_WINDOW
								mirrored	= 0
								fixPointX	= startX
								length		= distance - dd - groutVertical
								minLength	= 0.0
								maxLength	= 0.0
								minPosX		= 0.0
								maxPosX		= 0.0
								gosub "AddSpecial"
							endif
						endif
					else
						iLengthType	= BRICK_LENGTH_VAR
						type		= TYPE_WINDOW
						mirrored	= 0
						fixPointX	= startX
						length		= 0.0
						minLength	= dist13
						maxLength	= dist23
						minPosX		= 0.0
						maxPosX		= 0.0
						gosub "AddSpecial"
					endif
				endif
			endif
		endif

		if s2 = STATUS_DOOR then
			if s1 = STATUS_UNDER_LINDER & distance < elemWinWidth then
				iLengthType	= BRICK_LENGTH_FIX
				type		= TYPE_WINDOW
				mirrored	= 1
				fixPointX	= endX
				length		= distance
				minLength	= 0.0
				maxLength	= 0.0
				minPosX		= 0.0
				maxPosX		= 0.0
				gosub "AddSpecial"
			else
				if distance > elemWinWidth-BIGEPS then
					if eltoltSor then
						iLengthType	= BRICK_LENGTH_CHOICE
						type		= TYPE_WINDOW
						mirrored	= 1
						fixPointX	= endX
						length		= 0.0
						minLength	= dist23
						maxLength	= dist13
						minPosX		= 0.0
						maxPosX		= 0.0
						gosub "AddSpecial"
					else
						iLengthType	= BRICK_LENGTH_CHOICE
						type		= TYPE_WINDOW
						mirrored	= 1
						fixPointX	= endX
						length		= 0.0
						minLength	= dist13
						maxLength	= dist23
						minPosX		= 0.0
						maxPosX		= 0.0
						gosub "AddSpecial"
					endif
				else
					if s1 = STATUS_DOOR then
						if distance > elemWinWidth/2-BIGEPS then
							dd = distance / 3
							if eltoltSor then
								iLengthType	= BRICK_LENGTH_FIX
								type		= TYPE_WINDOW
								mirrored	= 1
								fixPointX	= endX
								length		= distance - dd - groutVertical
								minLength	= 0.0
								maxLength	= 0.0
								minPosX		= 0.0
								maxPosX		= 0.0
								gosub "AddSpecial"
							else
								iLengthType	= BRICK_LENGTH_FIX
								type		= TYPE_WINDOW
								mirrored	= 1
								fixPointX	= endX
								length		= dd
								minLength	= 0.0
								maxLength	= 0.0
								minPosX		= 0.0
								maxPosX		= 0.0
								gosub "AddSpecial"
							endif
						endif
					else
						iLengthType	= BRICK_LENGTH_VAR
						type		= TYPE_WINDOW
						mirrored	= 1
						fixPointX	= endX
						length		= 0.0
						minLength	= dist13
						maxLength	= dist23
						minPosX		= 0.0
						maxPosX		= 0.0
						gosub "AddSpecial"
					endif
				endif
			endif
		endif
	endif			

	!---- Put Datas -----------
	nColumnDatas[nSor]		= nColumnDatas[nSor] + 1
	n						= (nColumnDatas[nSor]-1)*nColData
	columnDatas[nSor][n+12]	= nSpec
	columnDatas[nSor][n+11]	= startBigCsorba
	columnDatas[nSor][n+10]	= esBrickDir
	columnDatas[nSor][n+9]	= yPos-EPS
	columnDatas[nSor][n+8]	= xx2
	columnDatas[nSor][n+7]	= xx1
	columnDatas[nSor][n+6]	= bcs2
	columnDatas[nSor][n+5]	= bcs1
	columnDatas[nSor][n+4]	= s2
	columnDatas[nSor][n+3]	= s1
	columnDatas[nSor][n+2]	= iRowLength
	columnDatas[nSor][n+1]	= eltoltSor


	!--------- Specialok sortolasa fixPointX-re ----------------
	dim unsortedCoords2[][2]
	if nSpec > 0 then
		for j = nSpec to 1 step -1
			unsortedCoords2[j][1] = specials[j][4]
			unsortedCoords2[j][2] = j
		next j
		gosub "insertionSort2"
	endif

	!-------- Put Specials -----------
	for j = 1 to nSpec
		idx = unsortedCoords2[j][2]
		put	specials[idx][1],
			specials[idx][2],
			specials[idx][3],
			specials[idx][4],
			specials[idx][5],
			specials[idx][6],
			specials[idx][7],
			specials[idx][8],
			specials[idx][9]
	next j
return

"AddSpecial":
	nSpec				= nSpec + 1
	specials[nSpec][1]	= iLengthType
	specials[nSpec][2]	= type
	specials[nSpec][3]	= mirrored
	specials[nSpec][4]	= fixPointX
	specials[nSpec][5]	= length
	specials[nSpec][6]	= minLength
	specials[nSpec][7]	= maxLength
	specials[nSpec][8]	= minPosX
	specials[nSpec][9]	= maxPosX

!!	if type = TYPE_WINDOW then
!!		if bBrickRevealDebug then
!!			if GLOB_SCRIPT_TYPE = 3 then
!!				add fixPointX, 0, magCurrent
!!					_d = 0.02
!!					if iLengthType = BRICK_LENGTH_CHOICE then _d = minLength / 4
!!					sphere _d
!!				del 1
!!			endif
!!		endif
!!	endif
return

"AddStandardBrick":
	!Add Standard brick to BrickArray

	if _brickW > BIGEPSCM then
		if _brickW > datBrickSize[preBrickIdx][BRICKSIZE_WIDTH]+EPS then
			_brickW = datBrickSize[preBrickIdx][BRICKSIZE_WIDTH]
		endif

		gosub "brickUnionCheck"

		nBrick					= nBrick + 1
		brickDef[nBrick][1]		= preBrickType
		brickDef[nBrick][2]		= esBrickDir
		brickDef[nBrick][3]		= preBrick
		brickDef[nBrick][4]		= preBrickIdx
		brickDef[nBrick][5]		= 0
		brickDef[nBrick][6]		= 0
		brickCoord[nBrick][1]	= lastX * not(esBrickDir) + (lastX - (datBrickSize[preBrickIdx][BRICKSIZE_WIDTH]-_brickW)) * esBrickDir
		brickCoord[nBrick][2]	= rowH
		brickCoord[nBrick][3]	= _brickW
		brickCoord[nBrick][4]	= lastX
		brickCoord[nBrick][5]	= brickH
		brickCut[nBrick][1]		= (lastX-brickCoord[nBrick][1]) * esBrickDir
		brickCut[nBrick][2]		= (datBrickSize[preBrickIdx][BRICKSIZE_WIDTH]-_brickW) * not(esBrickDir)
		brickCut[nBrick][3]		= topCut

		lastX = lastX + _brickW + groutVertical
		gosub "AddToCurrentGroutArray"
	endif
return

"AddCustomBrick":
	! Add Custom brick to BrickArray
	! param posX         float
	! param length       float
	! return:            None

	
	ll = _length
	if posX + ll > xx2 + BIGEPSCM then   !Ha kilógna a sorból
		ll = xx2 - posX
	endif

	elem	= iProducType
	elemIdx = idxProduct
	if specElemInts[currentSpec][SPEC_TYPE] = TYPE_END		& elemEnd then
		elem	= elemEnd
		elemIdx = elemEndIdx
	endif
	if specElemInts[currentSpec][SPEC_TYPE] = TYPE_LOW		& elemHalf then
		elem	= elemHalf
		elemIdx = elemHalfIdx
	endif
	if specElemInts[currentSpec][SPEC_TYPE] = TYPE_COLUMN	& elemColumn then
		elem	= elemColumn
		elemIdx = elemColumnIdx
	endif
	if specElemInts[currentSpec][SPEC_TYPE] = TYPE_WINDOW	& elemWindow then
		elem	= elemWindow
		elemIdx = elemWindowIdx
	endif

	bNormalElem = ( elem = iProductType )
	
	if not(bNormalElem) then
		!if not(datSpecMirror[elemIdx]) then
			specMirrored = specElemInts[currentSpec][SPEC_MIRROR]
		!else
		!	specMirrored = not(specElemInts[currentSpec][SPEC_MIRROR])
		!endif

		lastX					= posX
		nBrick					= nBrick + 1
		brickDef[nBrick][1]		= specElemInts[currentSpec][SPEC_TYPE]
		brickDef[nBrick][2]		= specMirrored
		brickDef[nBrick][3]		= elem
		brickDef[nBrick][4]		= elemIdx
		brickDef[nBrick][5]		= 0
		brickDef[nBrick][6]		= 1
		brickCoord[nBrick][1]	= lastX * not(specMirrored) + (lastX - (datBrickSize[elemIdx][BRICKSIZE_WIDTH]-ll)) * specMirrored
		brickCoord[nBrick][2]	= rowH
		brickCoord[nBrick][3]	= ll
		brickCoord[nBrick][4]	= lastX
		brickCoord[nBrick][5]	= datBrickSize[elemIdx][BRICKSIZE_HEIGHT]
		brickCut[nBrick][1]		= (lastX-brickCoord[nBrick][1]) * specMirrored
		brickCut[nBrick][2]		= (datBrickSize[elemIdx][BRICKSIZE_WIDTH]-ll) * not(specMirrored)
		brickCut[nBrick][3]		= topCut
	else
		! Példaul ha nincs véglelem akkor sima elemet foguk lerakni

		_brickW					= ll
		lastX					= posX
		gosub "brickUnionCheck"
		ll						= _brickW

		nBrick					= nBrick + 1
		brickDef[nBrick][1]		= preBrickType
		brickDef[nBrick][2]		= esBrickDir
		brickDef[nBrick][3]		= preBrick
		brickDef[nBrick][4]		= preBrickIdx
		brickDef[nBrick][5]		= 0
		brickDef[nBrick][6]		= 1
		brickCoord[nBrick][1]	= lastX * not(esBrickDir) + (lastX - (datBrickSize[preBrickIdx][BRICKSIZE_WIDTH]-ll)) * esBrickDir
		brickCoord[nBrick][2]	= rowH
		brickCoord[nBrick][3]	= ll
		brickCoord[nBrick][4]	= lastX
		brickCoord[nBrick][5]	= datBrickSize[preBrickIdx][BRICKSIZE_HEIGHT]
		brickCut[nBrick][1]		= (lastX-brickCoord[nBrick][1]) * esBrickDir
		brickCut[nBrick][2]		= (datBrickSize[preBrickIdx][BRICKSIZE_WIDTH]-ll) * not(esBrickDir)
		brickCut[nBrick][3]		= topCut
	endif
	
	lastX = lastX + ll + groutVertical
	gosub "AddToCurrentGroutArray"
	currentSpec = currentSpec + 1
return


"AddToCurrentGroutArray":
	!Add to currentGroutPoint Array
    bSorMagas = ( abs(rowHeights[nSor][1]-groutHorizontal - (brickCoord[nBrick][5] - brickCut[nBrick][3])) < BIGEPS )
    if abs(brickCut[nBrick][3]) > EPS & abs(rowH-currentMag) > EPS & not(bSorMagas) then  ! Áthidaló alatti vágott tégla
        brickDef[nBrick][5]						= 0
    else
		brickDef[nBrick][5]						= 1
		nCurrentGroutPoint						= nCurrentGroutPoint + 1
		currentGroutPoint[nCurrentGroutPoint]	= lastX - groutVertical/2
	endif
return

"VeryProblematicSpecialBrick":
	! input posXspec
	! return foundGoodPoint

	foundGoodPoint = 0
	
	if nBrick < 1 then
		return
	endif
	if rowIndex[nSor][1] > nBrick then
		return
	endif
	if brickDef[nBrick][6] then	!custom brick
		return
	endif
	tLastGrout = 0.0
	if brickDef[nBrick][5] then	!addGrout
		nCurrentGroutPoint	= nCurrentGroutPoint-1
		tLastGrout			= currentGroutPoint[nCurrentGroutPoint]
	endif
	tLastX	= lastX
	lastX	= brickCoord[nBrick][4]	!posLastX
	
	maxBr			= posXspec - lastX - groutVertical
	largestSize1	= min(maxBr, datBrickSize[brickDef[nBrick][4]] [BRICKSIZE_WIDTH])
	minimalSize1	= minBrickSize
	bCheckLength	= 0
	checkSpecial	= 0
	for qBrickW = minimalSize1 to largestSize1 step 0.01
		tBrickW = qBrickW 
		gosub "fugaCheck"
		if iFuga = FUGA_NONE then
			_brickW	= min(tBrickW, datBrickSize[brickDef[nBrick][4]] [BRICKSIZE_WIDTH])
			foundGoodPoint = 1
			qBrickW = largestSize1 + 0.1
		endif
	next qBrickW
	checkSpecial	= 1
	
	if foundGoodPoint then
		nBrick = nBrick - 1
		gosub "AddStandardBrick"
	else
		lastX = tLastX
		if brickDef[nBrick][5] then	!addGrout
			nCurrentGroutPoint						= nCurrentGroutPoint + 1
			currentGroutPoint[nCurrentGroutPoint]	= tLastGrout
		endif
	endif
return

"CheckSpecialBrickPre":
	!Megnézi hogy a speciális elem előtti téglával mi legyen
	!input iLengthType, place, posX, posXmin, posXmax 
	!return _brickW, posX

	_length		= 0.0
	posNew		= posX
	_posXmin	= posXmin
	_posXmax	= posXmax
	if posXmin > posXmax then
		_tt = posXmin
		posXmin = posXmax
		posXmax = _tt
	endif
	
	if iLengthType = BRICK_LENGTH_FIX then
		!Megnézzük kell e kiegészítő elem
		_length		= specElemFloats[currentSpec][SPEC_LENGTH]
		distance	= posX - groutVertical - lastX
		if distance > groutVertical + BIGEPSCM then
			if distance > minBrickSize - BIGEPS*5 then
				_brickW = distance
			else
				if rowIndex[nSor][1]-1 = nBrick then
					_brickW = distance
				else
					posXspec = posX
					gosub "VeryProblematicSpecialBrick"
					if not(foundGoodPoint) then
						_brickW = distance      !TODO hát ez most nincs nagyon lekezelve (meg kéne írni egy ujfajta visszaszedést)
					else
						_brickW = posX - groutVertical - lastX
					endif
				endif
			endif
			if place then
				gosub "AddStandardBrick"
			endif
		endif

		if specElemInts[currentSpec][SPEC_MIRROR] then
			posX = specElemFloats[currentSpec][SPEC_FIXPOINT] - _length
		endif
	endif

	if iLengthType = BRICK_LENGTH_VAR then
		distanceMin	= posXmax - groutVertical - lastX
		distanceMax	= posXmin - groutVertical - lastX
		if distanceMin > distanceMax then
			_tt			= distanceMax
			distanceMax = distanceMin
			distanceMin	= _tt
		endif
		_length		= specElemFloats[currentSpec][SPEC_MAXLENGTH]

		if distanceMax > groutVertical + BIGEPSCM then
			bFoundValidSize = 0
			minimalSize2    = distanceMin
			largestSize2    = distanceMax
			if distanceMax > minBrickSize - BIGEPS*5 then
				checkSpecial = 0
				for zBrickW = minimalSize2 to largestSize2 step 0.01
					tBrickW = zBrickW
					gosub "fugaCheck"
					if iFuga = FUGA_NONE then
						_brickW = min(tBrickW, brickWidth)
						if _brickW > minBrickSize - BIGEPS then
							_length			= posX - (lastX + _brickW + groutVertical)
							bFoundValidSize	= 1
							if place then
								gosub "AddStandardBrick"
							endif
						endif
						zBrickW = largestSize2 + 0.1
					endif
				next zBrickW
				checkSpecial = 1
			endif

			if not(bFoundValidSize) then
				if distanceMin > minBrickSize then
					_brickW = distanceMin
				else
					if distanceMax > minBrickSize then
						_brickW = distanceMax
					else
						posXspec = posXmax
						gosub "VeryProblematicSpecialBrick"
						if not(foundGoodPoint) then
							_brickW = distanceMax      !TODO hát ez most nincs nagyon lekezelve (meg kéne írni egy ujfajta visszaszedést)
						else
							!TODO ezt is lehetne szépíteni
							distanceMin2 = posXmax - groutVertical - lastX
							distanceMax2 = posXmin - groutVertical - lastX
							if distanceMin2 > distanceMax2 then
								_tt				= distanceMax2
								distanceMax2	= distanceMin2
								distanceMin2	= _tt
							endif
							if distanceMin2 > minBrickSize then
								_brickW = distanceMin2
							else
								_brickW = distanceMax2
							endif
						endif
					endif
				endif
				_length = posX - (lastX + _brickW + groutVertical)
				if place then
					gosub "AddStandardBrick"
				endif
			endif
		endif
	
		if specElemInts[currentSpec][SPEC_MIRROR] then
			posNew = specElemFloats[currentSpec][SPEC_FIXPOINT] - _length
		endif
	endif

	if iLengthType = BRICK_LENGTH_POS then
		!Elöször is megnézzük hogy lessz e az előtte levő tégla vagy beolvad, de ez feltételezi hogy sima tégla kerül bele
		egybeLength = posXmax - lastX
		if egybeLength < specElemFloats[currentSpec][SPEC_MAXLENGTH] + BIGEPS then
			! egybe lehet vonni
			posNew			= lastX
			minLength		= max(specElemFloats[currentSpec][SPEC_MINLENGTH], posXmax - posNew)
			maxLength		= specElemFloats[currentSpec][SPEC_MAXLENGTH]
			posXC			= posNew
			minimalSizeX	= minLength
			maximalSizeX	= maxLength
			gosub "CheckValidSizeLarger"
			_length			= retLength
		else
			! Le kell rakni egy sima téglát
			maxLength		= min(posXmin - lastX - groutVertical, minBrickSize)
			posXC			= posNew
			minimalSizeX	= minBrickSize
			maximalSizeX	= maxLength
			gosub "CheckValidSizeLarger"
			_brickW			= retLength
			if place then
				gosub "AddStandardBrick"
				posNew = lastX
			else
				posNew = lastX + _brickW + groutVertical
			endif

			posXC			= posNew
			minimalSizeX	= specElemFloats[currentSpec][SPEC_MINLENGTH]
			maximalSizeX	= specElemFloats[currentSpec][SPEC_MAXLENGTH]
			gosub "CheckValidSizeLarger"
			_length			= retLength
		endif
	endif

	if iLengthType = BRICK_LENGTH_CHOICE then
		distanceMin	= _posXmax - groutVertical - lastX
		distanceMax	= _posXmin - groutVertical - lastX

		checkSpecial = 0

		tBrickW = distanceMax
		gosub "fugaCheck"
		_fuga11 = fugaDist1
		_fuga12 = fugaDist2
		if iFuga = FUGA_NONE then
			_length	= specElemFloats[currentSpec][SPEC_MINLENGTH]
		else
			tBrickW = distanceMin
			gosub "fugaCheck"
			_fuga21 = fugaDist1
			_fuga22 = fugaDist2
			if iFuga = FUGA_NONE then
				_length	= specElemFloats[currentSpec][SPEC_MAXLENGTH]
			else
				_min1 = min(abs(_fuga11), abs(_fuga12))
				_min2 = min(abs(_fuga21), abs(_fuga22))
				if _min1 > min2  then
					_length	= specElemFloats[currentSpec][SPEC_MINLENGTH]
				else
					_length	= specElemFloats[currentSpec][SPEC_MAXLENGTH]
				endif
			endif
		endif

		checkSpecial = 1

		if specElemInts[currentSpec][SPEC_MIRROR] then
			posNew = specElemFloats[currentSpec][SPEC_FIXPOINT] - _length
		endif


		distance = posNew - groutVertical - lastX
		if distance > groutVertical + BIGEPSCM then
			if distance > minBrickSize - BIGEPS*5 then
				if distance < brickWidth + BIGEPS then
					_brickW = distance
					if place then
						gosub "AddStandardBrick"
					endif
				else
					elemDiff = abs(specElemFloats[currentSpec][SPEC_MINLENGTH] - specElemFloats[currentSpec][SPEC_MAXLENGTH])

					posXC			= lastX
					minimalSizeX	= max(minBrickSize, elemDiff)
					maximalSizeX	= brickWidth 
					gosub "CheckValidSizeSmaller"
					_brickW			= retLength

					if place then
						gosub "AddStandardBrick"
						posNew = lastX
					else
						posNew = lastX + _brickW + groutVertical
					endif
					ttLength = distance - _brickW - groutVertical
					_brickW = ttLength
					if place then
						gosub "AddStandardBrick"
						posNew = lastX
					else
						posNew = lastX + _brickW + groutVertical
					endif
				endif
			else
				if rowIndex[nSor][1]-1 = nBrick then
					_brickW = distance
				else
					posXspec = posX
					gosub "VeryProblematicSpecialBrick"
					if not(foundGoodPoint) then
						_brickW = distance      !TODO hát ez most nincs nagyon lekezelve (meg kéne írni egy ujfajta visszaszedést)
					else
						_brickW = posNew - groutVertical - lastX
					endif
				endif
				if place then
					gosub "AddStandardBrick"
				endif
			endif
		endif
	endif

	posX = posNew
return


"CheckSpecialBrickAfter":
	!Megnézi hogy a speciális elem utáni fuga hol legyen
	! return _length, posX
	
	if specElemInts[currentSpec][SPEC_LENGTHTYPE] = BRICK_LENGTH_FIX then
		_length = specElemFloats[currentSpec][SPEC_LENGTH]
	endif

	if specElemInts[currentSpec][SPEC_LENGTHTYPE] = BRICK_LENGTH_VAR then
		posXC			= posX
		minimalSizeX	= specElemFloats[currentSpec][SPEC_MINLENGTH]
		maximalSizeX	= specElemFloats[currentSpec][SPEC_MAXLENGTH]
		gosub "CheckValidSizeLarger"
		_length			= retLength
	endif

	if specElemInts[currentSpec][SPEC_LENGTHTYPE] = BRICK_LENGTH_CHOICE then
		checkSpecial = 0

		tBrickW = specElemFloats[currentSpec][SPEC_MINLENGTH]
		gosub "fugaCheck"
		_fuga11 = fugaDist1
		_fuga12 = fugaDist2
		if iFuga = FUGA_NONE then
			_length	= specElemFloats[currentSpec][SPEC_MINLENGTH]
		else
			tBrickW = specElemFloats[currentSpec][SPEC_MAXLENGTH]
			gosub "fugaCheck"
			_fuga21 = fugaDist1
			_fuga22 = fugaDist2
			if iFuga = FUGA_NONE then
				_length	= specElemFloats[currentSpec][SPEC_MAXLENGTH]
			else
				_min1 = min(abs(_fuga11), abs(_fuga12))
				_min2 = min(abs(_fuga21), abs(_fuga22))
				if _min1 > min2  then
					_length	= specElemFloats[currentSpec][SPEC_MINLENGTH]
				else
					_length	= specElemFloats[currentSpec][SPEC_MAXLENGTH]
				endif
			endif
		endif

		checkSpecial = 1
	endif
return


"CheckValidSizeLarger":
	!Megnézi hogy hogy a legnagyobb téglamérettel talál e valamit
	!input posXC, minimalSize, maximalSize
	!return retLength

	checkSpecial	= 0
	retLength		= maximalSizeX
	tempLastX		= lastX
	lastX			= posXC

	if minimalSizeX > maximalSizeX then
		_tt				= maximalSizeX
		maximalSizeX	= minimalSizeX
		minimalSizeX 	= _tt
	endif
	
	for wBrickW = maximalSizeX to minimalSizeX step -0.01
		tBrickW = wBrickW
		gosub "fugaCheck"
		if iFuga = FUGA_NONE then
			retLength = min(tBrickW, maximalSizeX)
			wBrickW = minimalSizeX - 0.1
		endif
	next wBrickW
	
	checkSpecial	= 1
	lastX			= tempLastX
return

"CheckValidSizeSmaller":
	!Megnézi hogy hogy a legnagyobb téglamérettel talál e valamit
	!input posXC, minimalSize, maximalSize
	!return retLength

	checkSpecial	= 0
	retLength		= minimalSizeX
	tempLastX		= lastX
	lastX			= posXC

	if minimalSizeX > maximalSizeX then
		_tt				= maximalSizeX
		maximalSizeX	= minimalSizeX
		minimalSizeX 	= _tt
	endif
	
	for wBrickW = minimalSizeX to maximalSizeX step 0.01
		tBrickW = wBrickW
		gosub "fugaCheck"
		if iFuga = FUGA_NONE then
			retLength	= min(tBrickW, maximalSizeX)
			wBrickW		= maximalSizeX + 0.1
		endif
	next wBrickW
	
	checkSpecial	= 1
	lastX			= tempLastX
return



"CheckSpecialElement":
	!Check special element
	!input place
	!return placeSpecial

	placeSpecial = 0
	!checkSpecial = 0

	if nSpecElem then
		if currentSpec <= nSpecElem then     !TODO itt ez elvileg nem kéne de valamiért ráfut
			if specElemInts[currentSpec][SPEC_LENGTHTYPE] = BRICK_LENGTH_POS then
				elemX1  = specElemFloats[currentSpec][SPEC_FIXPOINT]
				elemX2  = specElemFloats[currentSpec][SPEC_FIXPOINT]

				if	elemX1 - groutVertical - BIGEPS < lastX & lastX < elemX2 + groutVertical + BIGEPS										|\
					elemX1 - groutVertical - BIGEPS < lastX + _brickW & lastX + _brickW < elemX2 + groutVertical + BIGEPS					|\
					lastX - BIGEPS < elemX1 & elemX1 < lastX + _brickW + BIGEPS & lastX - BIGEPS < elemX2 & elemX2 < lastX + _brickW + BIGEPS	\
				then
					iLengthType	= BRICK_LENGTH_POS
					posX		= 0.0
					posXmin		= elemX1
					posXmax 	= elemX2
					gosub "CheckSpecialBrickPre"

					gosub "AddCustomBrick"
					placeSpecial = 1
					return
				endif
			else
				elemX1  = specElemFloats[currentSpec][SPEC_FIXPOINT]
				elemX2  = specElemFloats[currentSpec][SPEC_FIXPOINT]
				elemX3  = specElemFloats[currentSpec][SPEC_FIXPOINT]

				if specElemInts[currentSpec][SPEC_MIRROR] then
					if specElemInts[currentSpec][SPEC_LENGTHTYPE] = BRICK_LENGTH_FIX then
						elemX1 = elemX2 - specElemFloats[currentSpec][SPEC_LENGTH]
					endif
					if specElemInts[currentSpec][SPEC_LENGTHTYPE] = BRICK_LENGTH_VAR then
						elemX1 = elemX2 - specElemFloats[currentSpec][SPEC_MAXLENGTH]
					endif
					if specElemInts[currentSpec][SPEC_LENGTHTYPE] = BRICK_LENGTH_CHOICE then
						elemX1 = elemX2 - specElemFloats[currentSpec][SPEC_MINLENGTH]
						elemX3 = elemX2 - specElemFloats[currentSpec][SPEC_MAXLENGTH]
					endif
				else
					if specElemInts[currentSpec][SPEC_LENGTHTYPE] = BRICK_LENGTH_FIX then
						elemX2 = elemX1 + specElemFloats[currentSpec][SPEC_LENGTH]
					endif
					if specElemInts[currentSpec][SPEC_LENGTHTYPE] = BRICK_LENGTH_VAR then
						elemX2 = elemX1 + specElemFloats[currentSpec][SPEC_MAXLENGTH]
					endif
					if specElemInts[currentSpec][SPEC_LENGTHTYPE] = BRICK_LENGTH_CHOICE then
						elemX2 = elemX1 + specElemFloats[currentSpec][SPEC_MINLENGTH]
						elemX3 = elemX1 + specElemFloats[currentSpec][SPEC_MAXLENGTH]
					endif
				endif

				! az első pont beleesik e
				bMax1 = (elemX1 - groutVertical - BIGEPS < lastX & lastX < elemX2 + groutVertical + BIGEPS)
				bMax2 = (elemX1 - groutVertical - BIGEPS < lastX + _brickW & lastX + _brickW < elemX2 + groutVertical + BIGEPS)
				bMin1 = 0
				bMin2 = 0

				if specElemInts[currentSpec][SPEC_LENGTHTYPE]	= BRICK_LENGTH_CHOICE then
					if specElemInts[currentSpec][SPEC_MIRROR] then
						bMin1 = (elemX3 - groutVertical - BIGEPS < lastX & lastX < elemX2 + groutVertical + BIGEPS)
						bMin2 = (elemX3 - groutVertical - BIGEPS < lastX + _brickW & lastX + _brickW  < elemX2 + groutVertical + BIGEPS)
					else
						bMin1 = (elemX1 - groutVertical - BIGEPS < lastX & lastX < elemX3 + groutVertical + BIGEPS)
						bMin2 = (elemX1 - groutVertical - BIGEPS < lastX + _brickW & lastX + _brickW  < elemX3 + groutVertical + BIGEPS)
					endif
				endif
				
				if bMax1 | bMax2 | bMin1 | bMin2 then
					if specElemInts[currentSpec][SPEC_MIRROR] then
!!if bBrickRevealDebug then
!!	add specElemFloats[currentSpec][SPEC_FIXPOINT], 0, currentMag
!!		sphere 0.05
!!	del 1
!!endif 
						iLengthType	= specElemInts[currentSpec][SPEC_LENGTHTYPE]
						posX		= specElemFloats[currentSpec][SPEC_FIXPOINT] - specElemFloats[currentSpec][SPEC_LENGTH]
						posXmin		= specElemFloats[currentSpec][SPEC_FIXPOINT] - specElemFloats[currentSpec][SPEC_MINLENGTH]
						posXmax		= specElemFloats[currentSpec][SPEC_FIXPOINT] - specElemFloats[currentSpec][SPEC_MAXLENGTH]
						gosub "CheckSpecialBrickPre"
					else
						posX    	= specElemFloats[currentSpec][SPEC_FIXPOINT]
						posXtemp	= posX
						iLengthType = BRICK_LENGTH_FIX
						gosub "CheckSpecialBrickPre"
						posX		= posXtemp
						gosub "CheckSpecialBrickAfter"
					endif
	
					gosub "AddCustomBrick"
					placeSpecial = 1
					return
				endif
			endif
		endif
	endif
	!checkSpecial = 0
return


! ==============================================================================
! Size Check
! ------------------------------------------------------------------------------
! Input variables:
!	lastX:
!	iFuga				!fugában van e
!	fugaDist1
!	fugaDist2
!	_brickW
!
! Returned variables:
!	_brickW
! ==============================================================================
"brickSizeCheck":
	if iFuga then
		if bFugaDebug & GLOB_SCRIPT_TYPE = 3 then
			!print "fugaütközés sor", iFuga, nSor, "oszlop", nBrick-rowIndex[nSor][1], fugaDist1, fugaDist2, _brickW
			add lastX + _brickW, -brickThk, currentMag
			if iFuga = FUGA_BRICK then
				sphere 0.04
			else
				sphere 0.02
			endif
			del 1
		endif

		!Eltesszük az értékeket mert felülvágja a vizsgálat
		tFugaDist1 = fugaDist1
		tFugaDist2 = fugaDist2

		if tFugaDist1 < minBrickOverlap-eps then
			if abs(brickWidth-_brickW) < EPS then
				tBrickW = brickWidth - tFugaDist1 - minBrickOverlap
				gosub "fugaCheck"
				if iFuga = FUGA_NONE then
					_brickW = tBrickW
					return
				endif
			endif
		endif

		if tFugaDist2 < minBrickOverlap-eps then
			if abs(brickWidth-_brickW) < EPS then
				tBrickW = brickWidth - (minBrickOverlap - tFugaDist2) 
				gosub "fugaCheck"
				if iFuga = FUGA_NONE then
					_brickW = tBrickW
					return
				endif
			endif
		endif

		gosub "veryProblematicBrick"

	else
		fx	= lastX + _brickW
		if (xx2 - fx) < -EPS then		!Hosszu az utolsó tégla
			!!print "téglahossz csökkentés", xx2 - fx, lastX, xx2, _brickW
			_brickW = xx2 - lastX
			return
		endif
	
		gosub "brickLastTeglaCheck"
		if bChangeBrickSize then _brickW = tBrickW
	endif
return

"teglaVisszaSzed":
	nTeglaVisszaSzed = nTeglaVisszaSzed + 1

	if bFugaDebug & GLOB_SCRIPT_TYPE = 3 then
		add lastX + _brickW, -brickThk-0.04, currentMag
		block 0.04, 0.04, 0.04
		del 1
	endif

	if nBrick < colStartIdx+1 then
		return
	endif

	if abs(problematicLastX - lastX) < BIGEPS then
		return
	endif

	if abs(visszaszedLastX - brickCoord[nBrick][4]) < EPS then
		return
	endif

	!!print nSor, nCol, nBrick, colStartIdx, nTeglaVisszaSzed
	if nTeglaVisszaSzed > teglaVisszaSzedLimit | nBrick < colStartIdx+1 then
		!!if bPrintError then print stBrickError
		return
	endif

	nBrick				= nBrick - 1
	nCurrentGroutPoint	= nCurrentGroutPoint - 1
	lastX				= brickCoord[nBrick][4]!+brickCoord[nBrick][3] !TODO szerintem itt ez nem kell
	visszaszedLastX		= lastX

	gosub "vegtelenFugaCheckFront"
	if foundGoodPoint then return

	gosub "teglaVisszaSzed"
return

"vegtelenFugaCheckFront":
	foundGoodPoint	= 0
	bCheckLength	= 0

	largestSize = min(brickWidth, int((xx2 - lastX - minBrickSize)*100)/100)

	if bFugaDebug & GLOB_SCRIPT_TYPE = 3 then
		add lastX, -brickThk-0.06, currentMag
		block 0.02, 0.06, 0.02
		del 1
	endif

	for tBrickW = minBrickSize to largestSize step 0.01
		gosub "fugaCheck"
		if iFuga = FUGA_NONE then
			_brickW			= tBrickW
			foundGoodPoint	= 1
			return
		endif
	next tBrickW
return

"vegtelenFugaCheckBack":
	foundGoodPoint	= 0
	bCheckLength	= 0

	largestSize = min(brickWidth, int((xx2 - lastX - minBrickSize)*100)/100)

	for tBrickW = largestSize to minBrickSize step -0.005
		gosub "fugaCheck"
		if iFuga = FUGA_NONE then
			_brickW			= tBrickW
			foundGoodPoint	= 1
			return
		endif
	next tBrickW
return

"brickLastTeglaCheck":
	bChangeBrickSize = 0
	if bcs2 then
		minBD	= min(csorbaX2 + minBrickOverlap, brickWidth)
	else
		minBD	= minBrickSize
	endif

	if (xx2 - fx) < minBD & (xx2 - fx) > BIGEPS then		!Az utolsó tégla kisebb lenne mint a minimum csökkentsük a hosszat
		!!print "az utolsó tégla kisebb lesz a minimum méret", xx2 - fx, _brickW, xx2
		ww = xx2 - minBD - lastX
		if ww > minBrickSize - BIGEPS then
			tBrickW = ww
			bChangeBrickSize	= 1
		endif
	endif
return

"brickUnionCheck":
	!Csekkoljuk hogy az elözövel össze tudjuk e vonni (hogy ne legyen tuldarabolási kényszer)
	if nBrick > colStartIdx + 1 then
		lastBrickWidth = brickCoord[nBrick][3]
		if _brickW + groutVertical + lastBrickWidth < brickWidth + EPS then
			if brickDef[nBrick][5] then
				nCurrentGroutPoint	= nCurrentGroutPoint - 1
			endif
			nBrick	= nBrick - 1
			lastX	= brickCoord[nBrick][4]+brickCoord[nBrick][3]
			_brickW	= _brickW + lastBrickWidth + groutVertical
		endif
	endif
return



! ==============================================================================
! Grout Check
! ------------------------------------------------------------------------------
! Input variables:
!	nPrevGroutPoint:
!	prevGroutPoint:
!	bCheckLength
!
! Returned variables:
!	iFuga				!fugában van e
!	fugaDist1
!	fugaDist2
! ==============================================================================
"fugaCheck":
	fugaDist1	= brickWidth
	fugaDist2	= brickWidth
	iFuga		= FUGA_NONE
	fx			= lastX + tBrickW

	!-------- Utolsó elem akárhova kerül -------------
	if fx > xx2-BIGEPS then return

	!-------- Speciális elemek tesztelése -------------
	if checkSpecial then
		gosub "CheckSpecialElement"
		if placeSpecial then
			!TODO itt csak a távolságot kéne behatárolni
			return
		endif
	endif

	!-------- Utolsó elem hosszának tesztelése ------------- 
	if bCheckLength then
		gosub "brickLastTeglaCheck"
		if bChangeBrickSize then
			_brickW = tBrickW
			fx		= lastX + tBrickW
		endif
	endif

	if not(bHalfStone) | iRowLength	< ROWLENGTH_NORMAL | not(bCheckLength) | bChangeBrickSize | bFirstBrick*bcs1 then		!Ha kicsi a sor akkor mindenképpen a 8 cm es játszik
		!-------- Next Points tesztelése -------------
		for w = nSectPoint to 1 step -1
			if abs(nextSectionPoints[w] - fx) < minBrickOverlap-BIGEPS then
				!if nextSectionPoints[w] < fx then fugaDist1 = fx - nextSectionPoints[w]
				fugaDist1 = fx - nextSectionPoints[w]
				if w < nSectPoint then
					if nextSectionPoints[w+1] > fx then fugaDist2 = nextSectionPoints[w+1] - fx
				endif
				iFuga	= FUGA_SECTION
				return
			endif
		next w
	
		!-------- Nincs prevGroutPoint tömb vagy áthidaló felett van ----------
		if nPrevGroutPoint < 1 | (s1 = STATUS_ABOVE_LINDER & s2 = STATUS_ABOVE_LINDER) then return
	
		!-------- kivul van a méreten -------------------
		if fx > prevGroutPoint[nPrevGroutPoint] + minBrickOverlap + BIGEPS then
			fugaDist1	= fx - prevGroutPoint[nPrevGroutPoint]
			return
		endif
	
		!-------- Fugadist tesztelése -------------
		for w = nPrevGroutPoint to 1 step -1
			if w < nPrevGroutPoint then
				if fx >= prevGroutPoint[w] & fx <= prevGroutPoint[w+1] then
					fugaDist1 = fx - prevGroutPoint[w]
					fugaDist2 = prevGroutPoint[w+1] - fx
					if fugaDist1 < minBrickOverlap-BIGEPSBRICK | fugaDist2 < minBrickOverlap-BIGEPSBRICK then iFuga = FUGA_BRICK
					return
				else
					if w < 2-EPS & fx < prevGroutPoint[w] then
						fugaDist2	= prevGroutPoint[w] - fx
						if fugaDist2 < minBrickOverlap-EPS then
							iFuga = FUGA_BRICK
						endif
						return
					endif
				endif
			else
				if abs(prevGroutPoint[w] - fx) < minBrickOverlap-BIGEPSBRICK then
					fugaDist1	= fx - prevGroutPoint[w]
					iFuga		= FUGA_BRICK
					return
				endif
			endif
		next w
	else
		!-------- Next Points tesztelése -------------
		for w = nSectPoint to 1 step -1
			if abs(nextSectionPoints[w] - fx) < minBrickOverlap-BIGEPS then
				if abs(nextSectionPoints[w]-fx - xx1) > BIGEPS & abs(nextSectionPoints[w]-fx - xx2) > BIGEPS then
					!if nextSectionPoints[w] < fx then fugaDist1 = fx - nextSectionPoints[w]
					fugaDist1 = fx - nextSectionPoints[w]
					if w < nSectPoint then
						if nextSectionPoints[w+1] > fx then fugaDist2 = nextSectionPoints[w+1] - fx
					endif
					iFuga	= FUGA_SECTION
					return
				else
					fugaDist2	= fx - nextSectionPoints[w]
					iFuga		= FUGA_SECTION
					return
				endif
			endif
		next w
	
		!-------- Nincs prevGroutPoint tömb vagy áthidaló felett van ----------
		if nPrevGroutPoint < 1 | (s1 = STATUS_ABOVE_LINDER & s2 = STATUS_ABOVE_LINDER) then return
	
		!-------- kivul van a méreten -------------------
		if fx > prevGroutPoint[nPrevGroutPoint] + KOZEPEPS then
			fugaDist1	= fx - prevGroutPoint[nPrevGroutPoint]
			return
		endif
	
		!-------- Fugadist tesztelése -------------
		for w = nPrevGroutPoint to 1 step -1
			if w < nPrevGroutPoint then
				if fx >= prevGroutPoint[w] & fx <= prevGroutPoint[w+1] then
					fugaDist1 = fx - prevGroutPoint[w]
					fugaDist2 = prevGroutPoint[w+1] - fx
					if fugaDist1 < KOZEPEPS | fugaDist2 < KOZEPEPS then iFuga = FUGA_BRICK
					return
				else
					if w < 2-EPS & fx < prevGroutPoint[w] then
						fugaDist2	= prevGroutPoint[w] - fx
						if fugaDist2 < KOZEPEPS then
							iFuga = FUGA_BRICK
						endif
						return
					endif
				endif
			else
				if abs(prevGroutPoint[w] - fx) < KOZEPEPS then
					fugaDist1	= fx - prevGroutPoint[w]
					iFuga		= FUGA_BRICK
					return
				endif
			endif
		next w
	endif
return


!! ==============================================================================
!! Check Poly Direction
!! ------------------------------------------------------------------------------
!! Input variables:
!!	coords[][2]		polygon(closed)
!!
!! Returned variable:
!!	dir:		 1 clockwise
!!				-1 counter clockwise
!! ==============================================================================
!"checkPolyDir":
!	dir 	= 1
!	edgeD	= 0
!
!	ii = vardim1(coords)
!	for zz = 1 to ii-1
!		edgeD = edgeD + (coords[zz+1][1]-coords[zz][1]) * (coords[zz+1][2]+coords[zz][2]) 
!	next zz
!
!	if edgeD > EPS then	dir = -1
!return


! ==============================================================================
! Direction Angle
! ------------------------------------------------------------------------------
! Input variables:
!	vx, vy:		vector
!
! Returned variable:
!	angle:		direction angle of the vector
! ==============================================================================

"directionAngle":
	if abs(vx) < EPS & abs(vy) < EPS then
		angle = 0
		return
	endif

	if abs(vx) < EPS then
		if vy > 0 then
			angle = 90
		else
			angle = 270
		endif
	else
		angle = atn(vy / vx)
		if vx >= 0 then
			if angle < 0 then
				angle = angle + 360
			endif
		else
			angle = 180 + angle
		endif
	endif
return

! ==============================================================================
! Angle Normalizer
! ------------------------------------------------------------------------------
! Input variables:
!	angle:
!
! Returned variable:
!	angle:
! ==============================================================================
"angleNormalizer":
	if angle > 360	then angle = angle - 360
	if angle < 0	then angle = angle + 360
	angle = angle mod 360
return


! ==============================================================================
! Calculate polygon area
! ==============================================================================
! Input:
!	GDL stack:		coordX[1], coordY[1], status[1], ...
! Output:
!	area:			area of polygon
! ==============================================================================
! Remarks:
!	The input polygon must have closed
! ==============================================================================

"calculatePolygonArea":
	area = 0
	tempNumPnts = NSP/3
	dim polygon1[][3]

	for p = 1 to tempNumPnts
		polygon1[p][1] = get(1)	!coordX
		polygon1[p][2] = get(1)	!coordY
		polygon1[p][3] = get(1)	!status
	next p

	for areaI=1 to tempNumPnts-1
		area = area + (polygon1[areaI+1][1] + polygon1[areaI][1]) * (polygon1[areaI+1][2] - polygon1[areaI][2]) * 0.5
	next areaI
	area = area + (polygon1[1][1] + polygon1[tempNumPnts][1]) * (polygon1[1][2] - polygon1[tempNumPnts][2]) * 0.5

return


! ==============================================================================
! GET GDL Polygon
! ------------------------------------------------------------------------------
! Input variables:
!	ch:				Channel ID
!	polygonID:		Polygon ID
!	mask:
!	bEdgeInfo:
!
! Returned variables:
!	GDL stack:			GDL polygon
! ==============================================================================
"getGDLpolygonFromAPI":
	dim resVertices[]
	numVertices = CALLFUNCTION (ch, "GetVertices", polygonID, resVertices)
	numVertices = numVertices / 3

	dim contArray[]
	numContours = CALLFUNCTION (ch, "GetContourEnds", polygonID, contArray)

	dim inhEdgeInfos[]
	numEdges = CALLFUNCTION (ch, "GetInhEdgeInfos", polygonID, inhEdgeInfos)

	for contIndex = 1 to numContours
		if contIndex = 1 then
			begIdx = 0
		else
			begIdx = endIdx +1
		endif
		if contIndex = numContours then
			endIdx = numVertices - 1
		else
			endIdx = contArray[contIndex + 1] - 2 -(contIndex - 1)
		endif

		bClosed = 0
		bStartWithLast = 0

		index = endIdx * 3
		lastVertX = resVertices[index + 1]
		lastVertY = resVertices[index + 2]
		lastVertA = resVertices[index + 3]
		edgeInfo  = inhEdgeInfos[endIdx + 1]

		if abs(lastVertA) > EPS then
			if bEdgeInfo then
				put lastVertX, lastVertY, edgeInfo
			else
				put lastVertX, lastVertY, mask
			endif
			bStartWithLast = 1
		endif

		for vertIndex = begIdx to endIdx
			index = vertIndex * 3
			actVertX = resVertices[index + 1]
			actVertY = resVertices[index + 2]
			actVertA = resVertices[index + 3]

			! ------------------------------------------------------------------------------
			! Show inherited edge information number
			! ------------------------------------------------------------------------------
			!
			!	if bShowText then
			!			text2	(lastVertX + actVertX) / 2,
			!					(lastVertY + actVertY) / 2,
			!					edgeInfo
			!	endif
			! ------------------------------------------------------------------------------

			if vertIndex = begIdx then
				if bStartWithLast then
					ac2gdl_spx = lastVertX
					ac2gdl_spy = lastVertY
				else
					ac2gdl_spx = actVertX
					ac2gdl_spy = actVertY
				endif
			endif

			if abs(lastVertA) > EPS then
				ac2gdl_mx = (actVertX + lastVertX) / 2
				ac2gdl_my = (actVertY + lastVertY) / 2
				ac2gdl_ratio = 1 / 2 / tan (lastVertA / 2)
			
				ac2gdl_cx = ac2gdl_mx - ac2gdl_ratio * (actVertY - lastVertY)	! Arc center
				ac2gdl_cy = ac2gdl_my + ac2gdl_ratio * (actVertX - lastVertX)
			
				put ac2gdl_cx,	ac2gdl_cy,	900+mask,
					0,			lastVertA,	4000+mask
			!else
			!	if edgeInfo then
			!		line2 lastVertX, lastVertY, actVertX, actVertY
			!	endif
			endif

			bPointMatch = 0
			if bStartWithLast | (vertIndex > begIdx) then
				if abs(lastVertX - actVertX) < EPS then
					if abs(lastVertY - actVertY) < EPS then
						bPointMatch = 1
					endif
				endif
			endif

			if not(bPointMatch) then
				if vertIndex > begIdx & ABS(ac2gdl_spx - actVertX) < EPS & ABS(ac2gdl_spy - actVertY) < EPS then
					put ac2gdl_spx, ac2gdl_spy, -1
					bClosed = 1
				else
					if vertIndex < endIdx | NOT(bStartWithLast) then
						edgeInfo  = inhEdgeInfos[vertIndex + 1]
						if bEdgeInfo then
							PUT actVertX, actVertY, edgeInfo
						else
							PUT actVertX, actVertY, mask
						endif
					endif
				endif
			endif

			lastVertX	= actVertX
			lastVertY	= actVertY
			lastVertA	= actVertA
			!!edgeInfo	= inhEdgeInfos[vertIndex + 1]

		next vertIndex

		if not(bClosed) then	! Close the polygon if it has holes
			put ac2gdl_spx, ac2gdl_spy, -1
		endif

	next contIndex
return

"getGDLpolygonMinMaxX":
!Csak a min max X meghatározásához jó
	dim resVertices[]
	numVertices = CALLFUNCTION (ch, "GetVertices", polygonID, resVertices)
	numVertices = numVertices / 3

	dim contArray[]
	numContours = CALLFUNCTION (ch, "GetContourEnds", polygonID, contArray)

	for contIndex = 1 to numContours
		if contIndex = 1 then
			begIdx = 0
		else
			begIdx = endIdx +1
		endif
		if contIndex = numContours then
			endIdx = numVertices - 1
		else
			endIdx = contArray[contIndex + 1] - 2 -(contIndex - 1)
		endif

		bClosed = 0
		bStartWithLast = 0

		index = endIdx * 3
		lastVertX = resVertices[index + 1]
		lastVertY = resVertices[index + 2]
		lastVertA = resVertices[index + 3]

		if abs(lastVertA) > EPS then
			put lastVertX	!!, lastVertY, 1
			bStartWithLast = 1
		endif

		for vertIndex = begIdx to endIdx
			index = vertIndex * 3
			actVertX = resVertices[index + 1]
			actVertY = resVertices[index + 2]
			actVertA = resVertices[index + 3]

			if vertIndex = begIdx then
				if bStartWithLast then
					ac2gdl_spx = lastVertX
					ac2gdl_spy = lastVertY
				else
					ac2gdl_spx = actVertX
					ac2gdl_spy = actVertY
				endif
			endif

			bPointMatch = 0
			if bStartWithLast | (vertIndex > begIdx) then
				if abs(lastVertX - actVertX) < EPS then
					if abs(lastVertY - actVertY) < EPS then
						bPointMatch = 1
					endif
				endif
			endif

			if not(bPointMatch) then
				if vertIndex > begIdx & ABS(ac2gdl_spx - actVertX) < EPS & ABS(ac2gdl_spy - actVertY) < EPS then
					put ac2gdl_spx		!!, ac2gdl_spy, -1
					bClosed = 1
				else
					if vertIndex < endIdx | NOT(bStartWithLast) then
						put actVertX		!!, actVertY, mask
					endif
				endif
			endif

			lastVertX	= actVertX
			lastVertY	= actVertY
			lastVertA	= actVertA
			!!edgeInfo	= inhEdgeInfos[vertIndex + 1]

		next vertIndex
	next contIndex
return


! ==============================================================================
"geometryChecksum":
! ==============================================================================
	geomChecksum	= 0
	useSidepoly		= 0		!Ha kell a T csatlakozás

	geomChecksum = geomChecksum + ac_wall_height * ac_wall_length

	geomChecksum = geomChecksum + ac_curved_wall
	geomChecksum = geomChecksum + ac_wall_radius
	geomChecksum = geomChecksum + ac_curved_wall
	geomChecksum = geomChecksum + ac_wall_thk1 * ac_wall_thk2
	geomChecksum = geomChecksum + ac_refside

	if useSidepoly then
		geomChecksum = geomChecksum + vardim1(ac_angles) * vardim2(ac_angles)
		for i = 1 to vardim1(ac_angles)
			geomChecksum = geomChecksum + ac_angles[i][1] + ac_angles[i][2]
		next i

		if vardim1(ac_angles) > 1 then
			geomChecksum = geomChecksum + vardim1(ac_side_poly) * vardim2(ac_side_poly)
			for i = 1 to vardim1(ac_top_poly)
				geomChecksum = geomChecksum + ac_side_poly[i][1] * ac_side_poly[i][2]
				geomChecksum = geomChecksum + ac_side_poly[i][3] * ac_side_poly[i][4]
			next i
		endif
	else
		geomChecksum = geomChecksum + ac_angles[1][1] + ac_angles[vardim1(ac_angles)][vardim2(ac_angles)]
!!print ac_angles[1][1], ac_angles[vardim1(ac_angles)][vardim2(ac_angles)]
	endif

	geomChecksum = geomChecksum + vardim1(ac_top_poly) * vardim2(ac_top_poly)
	for i = 1 to vardim1(ac_top_poly)
		geomChecksum = geomChecksum + ac_top_poly[i][1] * ac_top_poly[i][2]
	next i

	geomChecksum = geomChecksum + vardim1(ac_bot_poly) * vardim2(ac_bot_poly)
	for i = 1 to vardim1(ac_bot_poly)
		geomChecksum = geomChecksum + ac_bot_poly[i][1] * ac_bot_poly[i][2]
	next i

	for i = 1 to vardim1(ac_wd_poly)
		nWP = int((ac_wd_poly[i][1]+1/32")/1")
		for z = 2 to nWP * 2 step 2
			geomChecksum = geomChecksum + ac_wd_poly[i][z] * ac_wd_poly[i][z+1]
		next z
	next i
	
	if abs(geomChecksum - checkSum) > EPS then
		!if GLOB_CONTEXT <> 5 then
			parameters checkSum = geomChecksum
		!endif
		bResetGeom = 1
	endif
return

! ==============================================================================
! String Separator
! ------------------------------------------------------------------------------
! Input variables:
!	allString:			char*
!	separator:			char
!
! Returned variables:
!	strArray[]:			strings Array
! ==============================================================================
allString	= ""
separator	= ""
"stringSeparator":
	dim strArray[]
	charLength = strlen(allString)
	if charLength < 2 then return
	
	restString	= allString
	strValid	= 1
	nStr		= 0
	while strValid do
		sepPos = strstr(restString, separator)
		if sepPos then
			nStr			= nStr + 1
			strL			= strlen(restString)
			strArray[nStr]	= strsub(restString, 1, sepPos-1)
			restString		= strsub(restString, sepPos+1, strL-(sepPos+1))
		else
			strL			= strlen(restString)
			if strL then
				nStr		= nStr + 1
				strArray[nStr]	= restString
			endif
			strValid		= 0
		endif
	endwhile
return

"productNamesWithDim":
	dim productDisplayName[]
	for i = vardim1(datBrickName) to 1 step -1
		productDisplayName[i] = ""
		if datBrickCustomName[i] then
			productDisplayName[i] = datBrickObjectName[i]
		else
			if datBrickName[i] <> "" then
				productDisplayName[i] = datBrickName[i] + " " + str(datBrickSize[i][BRICKSIZE_THK]*mmMultiplier,1,0) + "x" + str(datBrickSize[i][BRICKSIZE_HEIGHT]*mmMultiplier,1,0) + "x" + str(datBrickSize[i][BRICKSIZE_WIDTH]*mmMultiplier,1,0)
				if datBrickNutProf[i] <> "" then
					productDisplayName[i] = productDisplayName[i] + " " + datBrickNutProf[i]
				endif
			else
				productDisplayName[i] = datBrickObjectName[i]
			endif
		endif
	next i
return

dim strBrickInfo[][3]
"brickProductPhysik":
	n = 0

	dim brickCerts[]
	if brickCert <> "" then
		allString = brickCert
		separator = ";"
		gosub "stringSeparator" 
		brickCerts = strArray

		if vardim1(brickCerts) then
			n = n + 1
			strBrickInfo[n][1] = ""
			strBrickInfo[n][2] = ""
			strBrickInfo[n][3] = ""
			for i = 1 to vardim1(brickCerts)
				if i <> 1 then
					strBrickInfo[n][3] = strBrickInfo[n][3] + ", "
				endif
				strBrickInfo[n][3] = strBrickInfo[n][3] + brickCerts[i]
			next i
		endif
	endif

!!	if elemColumn then
!!		n = n + 1
!!		strBrickInfo[n][1]	= ""
!!		strBrickInfo[n][2]	= ""
!!		strBrickInfo[n][3]	= `Formwork block is available`
!!	endif

	if brickLambdaDry > EPS then
		n = n + 1
		strBrickInfo[n][1]	= `lambda dry`
		strBrickInfo[n][2]	= str(brickLambdaDry, 3, 2) + " W/mK"
		strBrickInfo[n][3]	= ""
	endif

	if brickLambdaNormal > EPS then
		n = n + 1
		strBrickInfo[n][1]	= `lambda design`
		strBrickInfo[n][2]	= str(brickLambdaNormal, 3, 2) + " W/mK"
		strBrickInfo[n][3]	= ""
	endif

	if brickUvalue > EPS then
		n = n + 1
		strBrickInfo[n][1]	= `U value`
		strBrickInfo[n][2]	= str(brickUvalue, 3, 2) + " W/m2K"
		strBrickInfo[n][3]	= ""
	endif

	if brickNperMm2 > EPS then
		n					= n + 1
		strBrickInfo[n][1]	= `compressive strength`
		strBrickInfo[n][2]	= str(brickNperMm2, 3, 2) + " N/mm2"
		strBrickInfo[n][3]	= ""
	endif

	if brickKgPerM3 > EPS | brickKgPerPc > EPS then
		if brickKgPerM3 > EPS then
			n					= n + 1
			strBrickInfo[n][1]	= `density`
			strBrickInfo[n][2]	= str(brickKgPerM3, 3, 2) + " kg/m3"
			strBrickInfo[n][3]	= ""
		endif
		if brickKgPerPc > EPS then
			n					= n + 1
			strBrickInfo[n][1]	= `blocks`
			strBrickInfo[n][2]	= str(brickKgPerPc, 3, 2) + " " + `kg/pc`
			strBrickInfo[n][3]	= ""
		endif
	endif

	if brickPcPerM2 > EPS | brickM2PerPc > EPS then
		if brickPcPerM2 > EPS then
			n					= n + 1
			strBrickInfo[n][1]	= `blocks`
			strBrickInfo[n][2]	= str(brickPcPerM2, 3, 2) + " " + `m2/pc`
			strBrickInfo[n][3]	= ""
		endif
		if brickM2PerPc > EPS then
			n					= n + 1
			strBrickInfo[n][1]	= `blocks`
			strBrickInfo[n][2]	= str(brickM2PerPc, 3, 2) + " " + `pc/m2`
			strBrickInfo[n][3]	= ""
		endif
	endif

	if brickKNperm3 > EPS then
		n					= n + 1
		strBrickInfo[n][1]	= `dead load`
		strBrickInfo[n][2]	= str(brickKNperm3, 3, 2) + " kN/m3"
		strBrickInfo[n][3]	= ""
	endif

	if brickShearStrength > EPS | brickFk > EPS then
		n					= n + 1
		strBrickInfo[n][1]	= `p0/fk`
		strBrickInfo[n][3]	= ""
		if brickFk > EPS then
			strBrickInfo[n][2] = str(brickShearStrength, 3, 2) + "/" + str(brickFk, 3, 2) + " MN/m2"
		else
			strBrickInfo[n][2] = str(brickShearStrength, 3, 2) + "/-" + " MN/m2"
		endif
	endif

	if brickMortarPerM2 > EPS | brickMortarPerM2str <> "" then
		n					= n + 1
		strBrickInfo[n][1]	= `mortar`
		if brickMortarPerM2 > EPS then
			strBrickInfo[n][2]	= str(brickMortarPerM2, 3, 2) + " kg/m2"
		else
			strBrickInfo[n][2]	= brickMortarPerM2str
		endif
		strBrickInfo[n][3]	= ""
	endif

	if brickWorkHperStructure > EPS | brickWorkHperFull > EPS then
		n					= n + 1
		strBrickInfo[n][1]	= `closed/openings`
		strBrickInfo[n][2]	= str(brickWorkHperStructure, 3, 2) + "/" + str(brickWorkHperFull, 3, 2) + " h/m2"
		strBrickInfo[n][3]	= ""
	endif

	if brickFireResistance <> "" then
		n					= n + 1
		strBrickInfo[n][1]	= `fire resistance`
		strBrickInfo[n][2]	= brickFireResistance
		strBrickInfo[n][3]	= ""
	endif

	if brickAcustic <> "" then
		n					= n + 1
		strBrickInfo[n][1]	= "R"
		strBrickInfo[n][2]	= brickAcustic
		strBrickInfo[n][3]	= " dB"
	endif

	!TODO ezek hiányoznak
	!self.grossDensity   = grossDensity
return



dim bCoords[6], bTypes[9]
"BeamSelector":
	!dim bCoords[6]	!(1)centerPos, (2)y, (3)length, (4)height, (5)opening size, (6)overhang
	!dim bTypes[9]	!(1)iBeamFamily, (2)iBeamFamilyIdx, (3)iBeamID, (4)iBeamIdx,  (5)iBeamTyp, (6)multiIdx, (7)overLapped, (8)overSized, (9)posError

	!openIdx
    !param beam:            BeamData()
    !param parameters:      Parameters()
    !param iBeamTyp         integer
    !param bOpeningSizeX    float
	!param bCenterPosX		float
	!param bCenterPosY		float
    !param bOverhang		float
    !param bHeight			float
	!return bCoords, bTypes

	!KS-Quadro
	!TODO nyelv ki és blockok csekkolása ha kell
	if iBeamTyp <> BEAM_TYP_CUSTOM and iBeamTyp <> BEAM_TYP_NONE then
		if iBeamTyp <> BEAM_TYP_BLOCK & iBeamTyp <> BEAM_TYP_RANGE then
			if bOpeningSizeX < 2.5 + EPS then
				iBeamTyp = BEAM_TYP_NORMAL
			else
				if uBlockAvailable then
					iBeamTyp = BEAM_TYP_BLOCK
				endif
				if uBlockRangeAvailable then
					iBeamTyp = BEAM_TYP_RANGE
				endif
			endif
		endif
	endif

	bFoundBeam	= 0

	if iBeamTyp = BEAM_TYP_CUSTOM then
		bTypes[LINDER_FAMILY_NAME]	= BEAM_FAMILY_CUSTOM
		bTypes[LINDER_TYPE]			= BEAM_TYP_CUSTOM
		bTypes[LINDER_NAME]			= BEAM_CUSTOM
		bTypes[LINDER_IDX]			= 0
		bTypes[LINDER_FAMILY_IDX]	= 0
		bTypes[LINDER_MULTI_IDX]	= 0
		bTypes[LINDER_OVERLAPPED]	= 0
		bTypes[LINDER_OVERSIZED]	= 0
		bTypes[LINDER_POSERROR]		= 0
		bCoords[LINDER_CENTER_X]	= bCenterPosX
		bCoords[LINDER_CENTER_Y]	= bCenterPosY
		bCoords[LINDER_LENGTH]		= bOpeningSizeX + 2*bOverhang
		bCoords[LINDER_HEIGHT]		= bHeight
		bCoords[LINDER_OPENING_SIZE]= bOpeningSizeX
		bCoords[LINDER_OVERHANG]	= bOverhang
		bFoundBeam					= 1
	else
		if iBeamTyp <> BEAM_TYP_NONE then
			bTypes[LINDER_FAMILY_NAME]	= BEAM_FAMILY_CUSTOM
			bTypes[LINDER_TYPE]			= BEAM_TYP_CUSTOM
			bTypes[LINDER_NAME]			= BEAM_CUSTOM
			bTypes[LINDER_IDX]			= 0
			bTypes[LINDER_FAMILY_IDX]	= 0
			bTypes[LINDER_MULTI_IDX]	= 0
			bTypes[LINDER_OVERLAPPED]	= 0
			bTypes[LINDER_OVERSIZED]	= 0
			bTypes[LINDER_POSERROR]		= 0
			bCoords[LINDER_CENTER_X]	= bCenterPosX
			bCoords[LINDER_CENTER_Y]	= bCenterPosY
			bCoords[LINDER_LENGTH]		= bOpeningSizeX + 2*bOverhang
			bCoords[LINDER_HEIGHT]		= bHeight
			bCoords[LINDER_OPENING_SIZE]= bOpeningSizeX
			bCoords[LINDER_OVERHANG]	= bOverhang
	
!print "tt", nAvaBeamTypes, vardim1(iAvaBeamFamilysAllIdxs), iAvaBeamFamilysAllIdxs
			if iBeamTyp = BEAM_TYP_NORMAL | iBeamTyp = BEAM_TYP_RANGE then
				! Preferred type
				dim preferType[], preferIdxs[], preferMulti[]
				iBeamFam	= 0
				iBeamFamIdx	= 0
				for zz = 1 to nAvaBeamTypes
					if iAvaBeamFamilysAllIdxs[zz] > 0 & nMaxAvaBeams[zz] > 0 then
						if datProdBeamType[iAvaBeamFamilysAllIdxs[zz]]  = _beamPreferType then
							if iAvaBeamFamilysAll[zz] = _beamPreferFamily then
								if nMaxAvaBeams[zz] > 0 then
									iBeamFam	= iAvaBeamFamilysAll[zz]
									iBeamFamIdx	= iAvaBeamFamilysAllIdxs[zz]
									preferType	= avaBeamTypes[zz]
									preferIdxs	= avaBeamTypesIdxs[zz]
									preferMulti	= avaBeamTypesMulti[zz]
									zz			= nAvaBeamTypes
								endif
							endif
						endif
					endif
				next zz

				! Ha nincs olyan vastagságban akkor továbbkeresünk
!print "iBeamFam", iBeamFam
				if not(iBeamFam) then
					for jj = 1 to nAvaBeamTypes
						if iAvaBeamFamilysAllIdxs[jj] > 0 & nMaxAvaBeams[zz] > 0 then
							if datProdBeamType[iAvaBeamFamilysAllIdxs[jj]]  = _beamPreferType then
								! TODO itt ezt lehetne finomitani hogy milyen sorrendben jönnek
								if nMaxAvaBeams[jj] > 0 then
									iBeamFam	= iAvaBeamFamilysAll[jj]
									iBeamFamIdx	= iAvaBeamFamilysAllIdxs[jj]
									preferType	= avaBeamTypes[jj]
									preferIdxs	= avaBeamTypesIdxs[jj]
									preferMulti	= avaBeamTypesMulti[jj]
									zz			= nAvaBeamTypes
								endif
							endif
						endif
					next jj
!print "iBeamFamBe", iBeamFam
				endif

	
				! Search in preferred type
				if iBeamFam then
					_iBeamFam		= iBeamFam
					_iBeamFamIdx	= iBeamFamIdx
					_iBeamTyp		= iBeamTyp
					gosub "BeamTypeSelector"
				endif
			endif

			if iBeamTyp = BEAM_TYP_BLOCK then
				!_iBeamFam		= iBeam
				!_iBeamFamIdx	= iBeamFamIdx
				_iBeamTyp		= iBeamTyp
				gosub "BeamTypeSelector"
!print "itt"
			endif

			if not(bFoundBeam) then
!print "not bFoundBeam"
				!Ha nem talált semmit akkor mindben probálkozik
				for z = 1 to nAvaBeamTypes
					idx = iAvaBeamFamilysAllIdxs[z]
					!if datProdBeamType[idx] <> BEAM_TYP_CUSTOM & datProdBeamType[idx] <> BEAM_TYP_NONE then
					if idx > 0 then
						_iBeamFam		= iAvaBeamFamilysAll[z]
						_iBeamFamIdx	= idx
						_iBeamTyp		= datProdBeamType[idx]
!print "ben", _iBeamFam, _iBeamFamIdx, _iBeamTyp
						gosub "BeamTypeSelector"
						if bFoundBeam then
							z = nAvaBeamTypes
						endif
					endif
				next z
!!				if not(bFoundBeam) then
!!					print `Error: cannot found valid beam type`
!!				endif
			endif
		endif
	endif
	
	!TODO lang ha kell
	if iBeamTyp <> BEAM_TYP_CUSTOM & iBeamTyp <> BEAM_TYP_NONE then
		if iBeamTyp = BEAM_TYP_RANGE then
			if openingSizeX > 5.5 + EPS then
				bTypes[LINDER_OVERSIZED] = 1
			endif
		endif
	endif

return


"BeamTypeSelector":
	!_iBeamFam
	!_iBeamFamIdx
	!_iBeamTyp
	!preferType[]
	!bOpeningSizeX
	!return bFoundBeam

	if _iBeamTyp = BEAM_TYP_NORMAL | _iBeamTyp = BEAM_TYP_RANGE then
		nPreferType	= vardim1(preferType)
		for nBeam = 1 to vardim1(preferType)
			if preferType[nBeam] < BEAM_CUSTOM then
				nPreferType	= nBeam - 1
				nBeam		= vardim1(preferType)
			endif
		next nBeam
	endif
	bFoundBeam	= 0

	if _iBeamTyp = BEAM_TYP_NORMAL then
		for nBeam = 1 to nPreferType
			typ = preferType[nBeam]
			idx = preferIdxs[nBeam]
			if bOpeningSizeX - BIGEPSCM < datBeamSize[idx][BRICKSIZE_WIDTH] - 2*datBeamOverhang[idx] then
				bTypes[LINDER_FAMILY_NAME]	= _iBeamFam
				bTypes[LINDER_TYPE]			= datProdBeamType[_iBeamFamIdx]
				bTypes[LINDER_NAME]			= typ
				bTypes[LINDER_IDX]			= idx
				bTypes[LINDER_FAMILY_IDX]	= _iBeamFamIdx
				bTypes[LINDER_MULTI_IDX]	= preferMulti[nBeam]
				bTypes[LINDER_OVERLAPPED]	= 0
				bTypes[LINDER_OVERSIZED]	= 0
				bTypes[LINDER_POSERROR]		= 0
				bCoords[LINDER_CENTER_X]	= bCenterPosX
				bCoords[LINDER_CENTER_Y]	= bCenterPosY
				bCoords[LINDER_LENGTH]		= datBeamSize[idx][BRICKSIZE_WIDTH]
				bCoords[LINDER_HEIGHT]		= datBeamSize[idx][BRICKSIZE_HEIGHT]
				bCoords[LINDER_OPENING_SIZE]= bOpeningSizeX
				bCoords[LINDER_OVERHANG]	= datBeamOverhang[idx]
				bFoundBeam 					= 1
				nBeam						= nPreferType
			endif
		next nBeam
	endif
	
	if _iBeamTyp = BEAM_TYP_RANGE then 		!Állítható áthidaló
		for nBeam = 1 to nPreferType
			typ			= preferType[nBeam]
			idx 		= preferIdxs[nBeam]
			calcSize	= bOpeningSizeX + 2*datBeamOverhang[idx] - BIGEPSCM
			if calcSize < datBeamSize[idx][5] then
				bTypes[LINDER_FAMILY_NAME]	= _iBeamFam
				bTypes[LINDER_TYPE]			= datProdBeamType[_iBeamFamIdx]
				bTypes[LINDER_NAME]			= typ
				bTypes[LINDER_IDX]			= idx
				bTypes[LINDER_FAMILY_IDX]	= _iBeamFamIdx
				bTypes[LINDER_MULTI_IDX]	= preferMulti[nBeam]
				bTypes[LINDER_OVERLAPPED]	= 0
				bTypes[LINDER_OVERSIZED]	= 0
				bTypes[LINDER_POSERROR]		= 0
				bCoords[LINDER_CENTER_X]	= bCenterPosX
				bCoords[LINDER_CENTER_Y]	= bCenterPosY
				bCoords[LINDER_LENGTH]		= bOpeningSizeX + 2*datBeamOverhang[idx]
				if bCoords[LINDER_LENGTH] < datBeamSize[idx][4] - EPS then
					bCoords[LINDER_LENGTH]	= datBeamSize[idx][4]
				endif
				bCoords[LINDER_HEIGHT]		= datBeamSize[idx][BRICKSIZE_HEIGHT]
				bCoords[LINDER_OPENING_SIZE]= bOpeningSizeX
				bCoords[LINDER_OVERHANG]	= datBeamOverhang[idx]
				bFoundBeam 					= 1
				nBeam						= nPreferType
			endif
		next nBeam
	endif

	if _iBeamTyp = BEAM_TYP_BLOCK then
		dim avaUBlockFamilys[], avaUBlockFamilysIdxs[], nAvaUBlocks[], avaUBlockTypes[][], avaUBlockTypesIdxs[][], avaUBlockTypesMulti[][]
		nAvaUBlockFamilys = 0
		for nBeam = 1 to nAvaBeamTypes
			typ = iAvaBeamFamilysAll[nBeam]
			idx = iAvaBeamFamilysAllIdxs[nBeam]
			if idx > 0 then
				if datProdBeamType[idx] = BEAM_TYP_BLOCK then
					if nMaxAvaBeams[nBeam] > 0 then
						nAvaUBlockFamilys						= nAvaUBlockFamilys + 1
						nAvaUBlocks[nAvaUBlockFamilys]			= 0
						avaUBlockFamilys[nAvaUBlockFamilys]		= typ
						avaUBlockFamilysIdxs[nAvaUBlockFamilys]	= idx
						for ii = 1 to nMaxAvaBeams[nBeam]
							nAvaUBlocks[nAvaUBlockFamilys]											= nAvaUBlocks[nAvaUBlockFamilys] + 1
							avaUBlockTypes[nAvaUBlockFamilys][nAvaUBlocks[nAvaUBlockFamilys]] 		= avaBeamTypes[nBeam][ii]
							avaUBlockTypesIdxs[nAvaUBlockFamilys][nAvaUBlocks[nAvaUBlockFamilys]] 	= avaBeamTypesIdxs[nBeam][ii]
							avaUBlockTypesMulti[nAvaUBlockFamilys][nAvaUBlocks[nAvaUBlockFamilys]] 	= avaBeamTypesMulti[nBeam][ii]
						next ii
					endif
				endif
			endif
		next nBeam

!print "nAvaUBlockFamilys", nAvaUBlockFamilys, "nAvaUBlocks", nAvaUBlocks, "avaUBlockFamilys", avaUBlockFamilys, "avaUBlockFamilysIdxs", avaUBlockFamilysIdxs, "avaUBlockTypes", avaUBlockTypes, "avaUBlockTypesIdxs", avaUBlockTypesIdxs

		if nAvaUBlockFamilys then
			validFamilyIdx = 1
			if nAvaUBlockFamilys > 1 then
				bFoundPreferedType = 0
				for ii = 1 to nAvaUBlockFamilys
					if avaUBlockFamilys[ii] = _beamPreferFamily then
						validFamilyIdx		= ii
						bFoundPreferedType	= 1
						ii					= nAvaUBlockFamilys
					endif
				next ii

				!Több magasságú block van, most a téglamagassághoz igazítjuk
				if not(bFoundPreferedType) then
					for ii = 1 to nAvaUBlockFamilys
						idx		= avaUBlockTypesIdxs[ii][1]
						bHeight	= datBeamSize[idx][BRICKSIZE_HEIGHT]
						if abs(bHeight - brickHeight) < BIGEPSCM then
							validFamilyIdx	= ii
							ii				= nAvaUBlockFamilys
						endif
					next ii
				endif
			endif
!print "validFamilyIdx", validFamilyIdx
			gosub "FindUblockGoodWidth"

			beamIdx						= avaUBlockTypesIdxs[validFamilyIdx][subTypeIdx]
!print "array", avaUBlockTypesIdxs, "validFamilyIdx", validFamilyIdx, "subTypeIdx", subTypeIdx, "beamIdx", beamIdx
			uWidth						= datBeamSize[beamIdx][BRICKSIZE_WIDTH] + groutVertical
			nUH							= int(ceil((bOpeningSizeX + 2*datBeamOverhang[beamIdx] + groutVertical) / uWidth))
			bTypes[LINDER_FAMILY_NAME]	= avaUBlockFamilys[validFamilyIdx]
			bTypes[LINDER_TYPE]			= BEAM_TYP_BLOCK
			bTypes[LINDER_NAME]			= datBeamIdx[beamIdx]
			bTypes[LINDER_IDX]			= beamIdx
			bTypes[LINDER_FAMILY_IDX]	= avaUBlockFamilysIdxs[validFamilyIdx]
			bTypes[LINDER_MULTI_IDX]	= avaBeamTypesMulti[validFamilyIdx][subTypeIdx]
			bTypes[LINDER_OVERLAPPED]	= 0
			bTypes[LINDER_OVERSIZED]	= 0
			bTypes[LINDER_POSERROR]		= 0
			bCoords[LINDER_CENTER_X]	= bCenterPosX
			bCoords[LINDER_CENTER_Y]	= bCenterPosY
			bCoords[LINDER_LENGTH]		= uWidth * nUH - groutVertical
			bCoords[LINDER_HEIGHT]		= datBeamSize[beamIdx][BRICKSIZE_HEIGHT]
			bCoords[LINDER_OPENING_SIZE]= bOpeningSizeX
			bCoords[LINDER_OVERHANG]	= datBeamOverhang[beamIdx]
			bFoundBeam					= 1
		else
!!			print `Error: Not Found U Block Type`
		endif
	endif

return


! ------------------------------------------------------------------------------
"beamOverLappingCheck":
! ------------------------------------------------------------------------------
nOverlappedLinders = 0

if bOverlapReset then
	for i = 1 to nLinderUsed
		usedLinderTypes[i][LINDER_OVERLAPPED] = 0
	next i
endif

for i = 1 to nLinderUsed
	boxAminX	= usedLinderCoords[i][LINDER_CENTER_X] - usedLinderCoords[i][LINDER_LENGTH]/2 + BIGEPS
	boxAmaxX	= usedLinderCoords[i][LINDER_CENTER_X] + usedLinderCoords[i][LINDER_LENGTH]/2 - BIGEPS
	boxAminY	= usedLinderCoords[i][LINDER_CENTER_Y] + BIGEPS
	boxAmaxY	= usedLinderCoords[i][LINDER_CENTER_Y] + usedLinderCoords[i][LINDER_HEIGHT] - BIGEPS

	for j = i+1 to nLinderUsed
		boxBminX	= usedLinderCoords[j][LINDER_CENTER_X] - usedLinderCoords[j][LINDER_LENGTH]/2 + BIGEPS
		boxBmaxX	= usedLinderCoords[j][LINDER_CENTER_X] + usedLinderCoords[j][LINDER_LENGTH]/2 - BIGEPS
		boxBminY	= usedLinderCoords[j][LINDER_CENTER_Y] + BIGEPS
		boxBmaxY	= usedLinderCoords[j][LINDER_CENTER_Y] + usedLinderCoords[j][LINDER_HEIGHT] - BIGEPS

		gosub "checkBoxIntersection"
		if state = 1 then
			usedLinderTypes[i][LINDER_OVERLAPPED]	= 1
			usedLinderTypes[j][LINDER_OVERLAPPED]	= 1
			nOverlappedLinders						= nOverlappedLinders + 1
		endif
	next j
next i

! ------------------------------------------------------------------------------
"beamOverSizeCheck":
! ------------------------------------------------------------------------------
	nOversizedLinder = 0
	for i = nLinderUsed to 1 step -1
		if usedLinderTypes[i][LINDER_OVERSIZED] then
			nOversizedLinder	= nOversizedLinder + 1
		endif
	next i
return

! ------------------------------------------------------------------------------
"beamWallCheck":
! ------------------------------------------------------------------------------

	for i = nLinderUsed to 1 step -1
		usedLinderPosOrig[i] = usedLinderCoords[i][LINDER_CENTER_X]
	
		bpl     = usedLinderCoords[i][LINDER_CENTER_X] - usedLinderCoords[i][LINDER_LENGTH] / 2
		bpr     = usedLinderCoords[i][LINDER_CENTER_X] + usedLinderCoords[i][LINDER_LENGTH] / 2
	
		if surfaceXmin - BIGEPS > bpl then
			diff									= surfaceXmin - bpl
			usedLinderCoords[i][LINDER_CENTER_X]	= usedLinderCoords[i][LINDER_CENTER_X] + diff
		endif
		if surfaceXmax + BIGEPS < bpr then
			diff									= bpr - surfaceXmax 
			usedLinderCoords[i][LINDER_CENTER_X]	= usedLinderCoords[i][LINDER_CENTER_X] - diff
		endif
	next i
return

! ------------------------------------------------------------------------------
"beamWindowCheck":
! ------------------------------------------------------------------------------
	for i = nLinderUsed to 1 step -1
		bpl     = usedLinderCoords[i][LINDER_CENTER_X] - usedLinderCoords[i][LINDER_LENGTH] / 2
		bpr     = usedLinderCoords[i][LINDER_CENTER_X] + usedLinderCoords[i][LINDER_LENGTH] / 2
	
		!TODO ezek most itt nem szépek mert ész nélkül toligálom öket
		for o = 1 to nOpeningPolygons
			yy1	= origOpeningBoundingBox[o][2]
			yy2	= origOpeningBoundingBox[o][4]
			xx1	= origOpeningBoundingBox[o][1]
			xx2	= origOpeningBoundingBox[o][3]

			if (yy1+EPS < usedLinderCoords[i][LINDER_CENTER_Y] & yy2-BIGEPS > usedLinderCoords[i][LINDER_CENTER_Y]) then	!Ablak között van
				if bpl > xx1+BIGEPS & bpl < xx2-BIGEPS then
					diff									= xx2 - bpl
					usedLinderCoords[i][LINDER_CENTER_X]	= usedLinderCoords[i][LINDER_CENTER_X] + diff
				endif
				if bpr > xx1+BIGEPS & bpr < xx2-BIGEPS then
					diff									= bpr - xx1
					usedLinderCoords[i][LINDER_CENTER_X]	= usedLinderCoords[i][LINDER_CENTER_X] - diff
				endif
			endif
		next o
	next i

return

! ------------------------------------------------------------------------------
"beamOverLappingMove":
! ------------------------------------------------------------------------------
	!beams.sort(key = operator.attrgetter('centerPos.x'))
	for i = 1 to nLinderUsed
		if usedLinderTypes[i][LINDER_OVERLAPPED] then
			if usedLinderTypes[i][LINDER_TYPE] = BEAM_TYP_NORMAL | usedLinderTypes[i][LINDER_TYPE] = BEAM_TYP_RANGE then
				overhangDefault = datBeamOverhang[usedLinderTypes[i][LINDER_IDX]] 
				overhang        = (usedLinderCoords[i][LINDER_LENGTH] - usedLinderCoords[i][LINDER_OPENING_SIZE])/2
				overhangDiff    = overhang - overhangDefault
				if abs(overhangDiff) > BIGEPS then
					moveDiff            = usedLinderCoords[i][LINDER_CENTER_X] - usedLinderPosOrig[i]
					posLeft             = usedLinderCoords[i][LINDER_CENTER_X] - usedLinderCoords[i][LINDER_LENGTH]/2
					posRight            = usedLinderCoords[i][LINDER_CENTER_X] + usedLinderCoords[i][LINDER_LENGTH]/2
					overHangDiffLeft    = overhangDiff - moveDiff
					overHangDiffRight   = overhangDiff + moveDiff
	
					!Find near beams
					leftBeam    = 0
					rightBeam   = 0
					for j = 1 to nLinderUsed
						if i <> j then
							if	abs(usedLinderCoords[j][LINDER_CENTER_Y] - usedLinderCoords[i][LINDER_CENTER_Y]) < BIGEPS											|\
								usedLinderCoords[j][LINDER_CENTER_Y] < usedLinderCoords[i][LINDER_CENTER_Y]															&\
								usedLinderCoords[i][LINDER_CENTER_Y] < usedLinderCoords[j][LINDER_CENTER_Y] + usedLinderCoords[j][LINDER_HEIGHT]						|\
								usedLinderCoords[j][LINDER_CENTER_Y] < usedLinderCoords[i][LINDER_CENTER_Y] + usedLinderCoords[i][LINDER_HEIGHT]						&\
								usedLinderCoords[i][LINDER_CENTER_Y] + usedLinderCoords[i][LINDER_HEIGHT] < usedLinderCoords[j][LINDER_CENTER_Y] + usedLinderCoords[j][LINDER_HEIGHT]	\
							then
								if j < i then
									leftBeam = j
								else
									rightBeam = j
									j = nLinderUsed
								endif
							endif
						endif
					next j
	
					if leftBeam & rightBeam then
						posLeftRight = usedLinderCoords[leftBeam][LINDER_CENTER_X] + usedLinderCoords[leftBeam][LINDER_LENGTH]/2
						posRightLeft = usedLinderCoords[rightBeam][LINDER_CENTER_X] - usedLinderCoords[rightBeam][LINDER_LENGTH]/2
	
						if posLeftRight > posLeft and posRight > posRightLeft then
							!pass
							!TODO nem tudjuk mozgatni mert mindkettőbe beleért
						else
							if posLeftRight > posLeft then
								diffLeft    = posLeftRight - posLeft
								offsetLeft  = min(diffLeft, overHangDiffLeft)
								diffRight   = posRightLeft - posRight
								offsetRight = min(diffRight, overHangDiffRight)
								offset      = min(offsetLeft, offsetRight) !+ BIGEPS
								usedLinderCoords[i][LINDER_CENTER_X] = usedLinderCoords[i][LINDER_CENTER_X] + offset
							endif
							if posRight > posRightLeft then
								diffRight   = posRight - posRightLeft
								offsetRight = min(diffRight, overHangDiffRight)
								diffLeft    = posLeft - posLeftRight
								offsetLeft  = min(diffLeft, overHangDiffLeft)
								offset      = min(offsetLeft, offsetRight) !+ BIGEPS
								usedLinderCoords[i][LINDER_CENTER_X] = usedLinderCoords[i][LINDER_CENTER_X] - offset
							endif
						endif
					else
						if leftBeam then
							posLeftRight = usedLinderCoords[leftBeam][LINDER_CENTER_X] + usedLinderCoords[leftBeam][LINDER_LENGTH]/2
							if posLeftRight > posLeft then
								diff    = posLeftRight - posLeft
								offset  = min(diff, overHangDiffLeft) !+ BIGEPS
								usedLinderCoords[i][LINDER_CENTER_X] = usedLinderCoords[i][LINDER_CENTER_X] + offset
							endif
						endif
						if rightBeam then
							posRightLeft = usedLinderCoords[rightBeam][LINDER_CENTER_X] - usedLinderCoords[rightBeam][LINDER_LENGTH]/2
							if posRight > posRightLeft then
								diff    = posRight - posRightLeft
								offset  = min(diff, overHangDiffRight) !+ BIGEPS
								usedLinderCoords[i][LINDER_CENTER_X] = usedLinderCoords[i][LINDER_CENTER_X] - offset
							endif
						endif
					endif
				endif
			endif
		endif
	next i

return

! ------------------------------------------------------------------------------
"beamErrorsCheck":
! ------------------------------------------------------------------------------
	nLinderPosError = 0
	for i = 1 to nLinderUsed
		if usedLinderTypes[i][LINDER_IDX] then
			moveDiff            = usedLinderCoords[i][LINDER_CENTER_X] - usedLinderPosOrig[i]
			overhangDefault		= datBeamOverhang[usedLinderTypes[i][LINDER_IDX]] 
			if abs(moveDiff) > BIGEPS then
				openingXLeft	= usedLinderPosOrig[i] - usedLinderCoords[i][LINDER_LENGTH]/2
				openingXRight	= usedLinderPosOrig[i] + usedLinderCoords[i][LINDER_LENGTH]/2
				beamXLeft		= usedLinderCoords[i][LINDER_CENTER_X] - usedLinderCoords[i][LINDER_LENGTH]/2
				beamXRight		= usedLinderCoords[i][LINDER_CENTER_X] + usedLinderCoords[i][LINDER_LENGTH]/2
				overHangLeft	= openingXLeft - beamXLeft
				overHangRight	= beamXRight - openingXRight
				if overHangLeft < overhangDefault-BIGEPS | overHangRight < overhangDefault-BIGEPS then
					nLinderPosError						= nLinderPosError + 1
					usedLinderTypes[i][LINDER_POSERROR]	= 1
				endif
			endif
		endif
	next i
return

! ------------------------------------------------------------------------------
"checkCutterInArray":
! ------------------------------------------------------------------------------
	!input cutIdx
	for q = 1 to nBrickCutter
		if brickCuttersType[q] = cutIdx then
			bFound = 0
			for qq = 1 to nRowCutters[nSor]
				if rowCutters[nSor][qq] = cutIdx then
					bFound  = 1
					qq		= nRowCutters[nSor]
				endif
			next qq
			if not(bFound) then
				nRowCutters[nSor]					= nRowCutters[nSor] + 1
				rowCutters[nSor][nRowCutters[nSor]] 	= cutIdx
			endif
			q				= nBrickCutter
		endif
	next q
return

! ------------------------------------------------------------------------------
"findSpecElemIdx":
! ------------------------------------------------------------------------------
	resIdx = 0
	if findIdx = 0 then
		return
	endif
	for q = 1 to nAvaSpecialElemsAll
		if avaSpecialElemsAll[q] = findIdx then
			resIdx	= avaSpecialElemsAllIdxs[q]
			q		= nAvaSpecialElemsAll
		endif
	next q
return

! ------------------------------------------------------------------------------
"findBeamFamilyIdx":
! ------------------------------------------------------------------------------
	resIdx = 0
	for q = 1 to nAvaBeamFamilysAll
		if inputBeamFam = iAvaBeamFamilysAll[q] then
			resIdx = iAvaBeamFamilysAllIdxs[q]
			return
		endif
	next q
return

! ------------------------------------------------------------------------------
"findBeamThickness":
! ------------------------------------------------------------------------------
	foundBeamThk = 0
	for q = 1 to nAvaBeamTypesAll
		idx = avaBeamTypesIdxsAll[q]
		if datBeamFamily[idx] = fam then
			if abs(datBeamSize[idx][BRICKSIZE_THK] - findBeamThk) < BIGEPS then
				foundBeamThk = 1
				return
			endif
		endif
	next q
return

! ------------------------------------------------------------------------------
"findBeamLengths":
! ------------------------------------------------------------------------------
	dim beamMultiLengths[]
	nMulitBeamLengths = 0
	for q = 1 to nAvaBeamTypesAll
		idx = avaBeamTypesIdxsAll[q]
		if datBeamFamily[idx] = fam then
			if abs(datBeamSize[idx][BRICKSIZE_THK] - findBeamThk) < BIGEPS then
				foundBeamLength = datBeamSize[idx][BRICKSIZE_WIDTH]
				foundLength = 0
				for qq = 1 to nMulitBeamLengths
					if abs(beamMultiLengths[qq] - foundBeamLength) < BIGEPS then
						foundLength = 1
						qq			= nMulitBeamLengths
					endif
				next qq
				if not(foundLength) then
					nMulitBeamLengths					= nMulitBeamLengths + 1
					beamMultiLengths[nMulitBeamLengths]	= foundBeamLength 
				endif
			endif
		endif
	next q
return

! ------------------------------------------------------------------------------
"findBeamThkWithLength":
! ------------------------------------------------------------------------------
	foundBeamIdx = 0
	for q = 1 to nAvaBeamTypesAll
		idx = avaBeamTypesIdxsAll[q]
		if datBeamFamily[idx] = fam then
			if abs(datBeamSize[idx][BRICKSIZE_THK] - findBeamThk) < BIGEPS then
				if abs(datBeamSize[idx][BRICKSIZE_WIDTH] - findBeamLength) < BIGEPS then
					foundBeamIdx = idx
					return
				endif
			endif
		endif
	next q
return

! ------------------------------------------------------------------------------
"FindUblockGoodWidth":
! ------------------------------------------------------------------------------
	subTypeIdx	= 1
	nTypes		= nAvaUBlocks[validFamilyIdx]
	if nTypes > 1 then
		dim uLengths[]
		for ii = nTypes to 1 step -1
			uIdx			= avaUBlockTypesIdxs[validFamilyIdx][ii]
			uWidth  		= datBeamSize[uIdx][BRICKSIZE_WIDTH] + groutVertical
			nUH				= int(ceil((bOpeningSizeX + 2*datBeamOverhang[uIdx] + groutVertical) / uWidth))
			uLengths[ii]	= uWidth * nUH - groutVertical
		next ii

		minUlength = uLengths[1]
		for ii = 2 to nTypes
			if uLengths[ii] < minUlength then
				minUlength	= uLengths[ii]
				subTypeIdx	= ii	!avaUBlockTypesIdxs[validFamilyIdx][ii]
			endif
		next ii
	endif
return

! ------------------------------------------------------------------------------
"CheckContourIsRectange":
! ------------------------------------------------------------------------------
	!----Calculate Ref Area---
	for i = 1 to nPolygonPoint
		put contourPoints[i][1], contourPoints[i][2], 1
	next i
	gosub "calculatePolygonArea"
	refPolyContourArea = area
	
	!-----Bounding Box Are---
	bBoxArea = (boundingRef[1][3] - boundingRef[1][1]) * (boundingRef[1][4] - boundingRef[1][2])

	bRefContourIsRectangle = (abs(refPolyContourArea - bBoxArea) < BIGEPS)
return

! ------------------------------------------------------------------------------
"checkSectionInPoly":
! ------------------------------------------------------------------------------
	!TODO
	! python ban ez a _AddToSectionData függvény
return

inputStr		= ""
strSeparator	= ""
dim outStrs[]
! ------------------------------------------------------------------------------
"textSplitter":
! ------------------------------------------------------------------------------
! inputStr
! strSeparator
! outStrs
	k		= 0
	sepLen	= strlen(strSeparator) + 1 ! Ez most hack
	restTxt = inputStr
	pos		= strstr (restTxt , strSeparator)
	while pos > 0 do
		part		= strsub (restTxt, 1, pos - 1)
		restTxt		= strsub (restTxt, pos + sepLen, strlen(restTxt))
		k			= k + 1
		outStrs[k]	= part
		pos			= strstr (restTxt , strSeparator)
	endwhile

	! Last part (csak akkor kell ha van tartalma
	k = k + 1
	outStrs[k] = restTxt
return

! ------------------------------------------------------------------------------
"textReplacer":
! ------------------------------------------------------------------------------
! inputStr
! strSeparator
! outStrs
	k		= 0
	sepLen	= strlen(strSeparator) + 1 ! Ez most hack
	restTxt = inputStr
	pos		= strstr (restTxt , strSeparator)
	while pos > 0 do
		part		= strsub (restTxt, 1, pos - 1)
		restTxt		= strsub (restTxt, pos + sepLen, strlen(restTxt))
		k			= k + 1
		outStrs[k]	= part
		pos			= strstr (restTxt , strSeparator)
	endwhile

	! Last part (csak akkor kell ha van tartalma
	k = k + 1
	outStrs[k] = restTxt

	outStr = ""
	for k = 1 to vardim1(outStrs)
		if outStr <> "" then
			outStr = outStr + " " + outStrs[k]		
		else
			outStr = outStr + outStrs[k]
		endif
	next k
return

! ------------------------------------------------------------------------------
"getLocString":
! ------------------------------------------------------------------------------
	beamLocAuto		= `Auto`
	beamLocNone		= `None`
	beamLocCustom	= `Custom`

	if iLang = LANG_DE then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_AT then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_CH then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_FI then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_SE then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_NO then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_DK then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_NL then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_BE then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_FR then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_ES then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_UK then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_IT then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_XK then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_SI then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_BA then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_HR then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_RS then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_HU then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_BG then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_RO then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_PL then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_SK then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_CZ then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_RU then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_US then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_CH then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_MX then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
	if iLang = LANG_TR then
		!beamLocAuto		= ""
		!beamLocNone		= ""
		!beamLocCustom	= ""
	endif
return

! ==============================================================================
!
! End of Master Script
!
! ==============================================================================

"endMasterSript":
]]>
</Script_1D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_PR SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! ------------------------------------------------------------------------------
! Localization
! ------------------------------------------------------------------------------
stWallSurface		= `Wall Surface: `
dbName				= `KS-Quadro wall component`
dbName2				= `KS-Quadro wall`


! ------------------------------------------------------------------------------
! Database
! ------------------------------------------------------------------------------
DATABASE_SET `KS-Quadro Wall`

unitDB	= "001"
unitM	= "002"
unitCM	= "003"
unitM2	= "004"

separator	= " | "


! ------------------------------------------------------------------------------
! Properties
! ------------------------------------------------------------------------------
dim strBrickInfo[][3]
gosub "brickProductPhysik"


! ------------------------------------------------------------------------------
! Holes surface
! ------------------------------------------------------------------------------
holeSurface		= 0
holeCuttedAres	= 0
dim holeArea[]
if nOpeningPolygons > 0 then
	for i = 1 to nOpeningPolygons
		for ii = origOpeningStartEnd[i][1] to origOpeningStartEnd[i][2]
			put origOpeningPoligons[ii][1], origOpeningPoligons[ii][2], origOpeningPoligons[ii][3]
		next ii
	
		if NSP > 11 then
			gosub "calculatePolygonArea"
			if abs(area) > 1.0 then
				holeCuttedAres = holeCuttedAres + abs(area)
			endif
			holeArea[vardim1(holeArea)+1] = abs(area)
			holeSurface = holeSurface + abs(area)
		endif

		for j = 1 to NSP
			eee = get(1)
		next j
	next i
endif


! ------------------------------------------------------------------------------
! Wall surface
! ------------------------------------------------------------------------------
wallSurfaceWithoutHoles = 0
wallSurface				= 0
for i = 1 to nPolygonPoint
	put baseCubePoints[i][1], baseCubePoints[i][2], 1
next i
gosub "calculatePolygonArea"
wallSurfaceWithoutHoles = abs(area)
wallSurface				= wallSurfaceWithoutHoles - holeCuttedAres
component stWallSurface, wallSurface,  "m2", 1, dbName2, "002", unitM2


! ------------------------------------------------------------------------------
! Bricks
! ------------------------------------------------------------------------------
for i = 1 to nBrick
	pType	= brickDef[i][3]
	pIdx	= brickDef[i][4]
	call "ks_quadro_brick_m" parameters	iFamily				= datBrickFamily[pIdx],
									brickName			= datBrickName[pIdx],
									iProductType		= pType,
									iProductIdx			= pIdx,
									brickWidth			= datBrickSize[pIdx][BRICKSIZE_WIDTH],
									brickThk			= datBrickSize[pIdx][BRICKSIZE_THK],
									brickHeight			= datBrickSize[pIdx][BRICKSIZE_HEIGHT],
									minBrickSize		= minBrickSize,
									minBrickOverlap		= minBrickOverlap,
									bMirrored			= brickDef[i][2],
									startCut			= brickCut[i][1],
									endCut				= brickCut[i][2]
next i


! ------------------------------------------------------------------------------
! Linder
! ------------------------------------------------------------------------------
for i = 1 to nLinderUsed
	if usedLinderTypes[i][LINDER_FAMILY_NAME] <> BEAM_FAMILY_NONE and usedLinderTypes[i][LINDER_FAMILY_NAME] <> BEAM_FAMILY_CUSTOM then
		if usedLinderTypes[i][LINDER_MULTI_IDX] > 0 then !multi
			multiIdx = usedLinderTypes[i][LINDER_MULTI_IDX]
			for j = 1 to nMultiSubBeams[multiIdx]
				idx = multiBeamsIdxs[multiIdx][j]
				call "ks_quadro_lintel_m" parameters	beamName			= datBeamName[idx],
													iBeamFamily			= usedLinderTypes[i][LINDER_FAMILY_NAME],!	datBeamFamily[idx],
													iBeamType			= usedLinderTypes[i][LINDER_TYPE],
													iBeam				= datBeamIdx[idx],
													iBeamFamilyIdx		= usedLinderTypes[i][LINDER_FAMILY_IDX],
													iBeamIdx			= idx,
													bOverLapped			= usedLinderTypes[i][LINDER_OVERLAPPED],
													bOversized			= usedLinderTypes[i][LINDER_OVERSIZED],
													bPosError			= usedLinderTypes[i][LINDER_POSERROR],
			
													overhang			= usedLinderCoords[i][LINDER_OVERHANG],
													customLength		= usedLinderCoords[i][LINDER_LENGTH],
													brickWidthOne		= datBeamSize[idx][BRICKSIZE_WIDTH],
													beamWidth			= datBeamSize[idx][BRICKSIZE_WIDTH],
													beamThk				= datBeamSize[idx][BRICKSIZE_THK],
													beamHeight			= datBeamSize[idx][BRICKSIZE_HEIGHT]
			next j
		else
			idx = usedLinderTypes[i][LINDER_IDX]
			call "ks_quadro_lintel_m" parameters	beamName			= datBeamName[idx],
												iBeamFamily			= usedLinderTypes[i][LINDER_FAMILY_NAME],
												iBeamType			= usedLinderTypes[i][LINDER_TYPE],
												iBeam				= usedLinderTypes[i][LINDER_NAME],
												iBeamFamilyIdx		= usedLinderTypes[i][LINDER_FAMILY_IDX],
												iBeamIdx			= usedLinderTypes[i][LINDER_IDX],
												bOverLapped			= usedLinderTypes[i][LINDER_OVERLAPPED],
												bOversized			= usedLinderTypes[i][LINDER_OVERSIZED],
												bPosError			= usedLinderTypes[i][LINDER_POSERROR],
		
												overhang			= usedLinderCoords[i][LINDER_OVERHANG],
												customLength		= usedLinderCoords[i][LINDER_LENGTH],
												brickWidthOne		= datBeamSize[idx][BRICKSIZE_WIDTH],
												beamWidth			= datBeamSize[idx][BRICKSIZE_WIDTH],
												beamThk				= datBeamSize[idx][BRICKSIZE_THK],
												beamHeight			= datBeamSize[idx][BRICKSIZE_HEIGHT]
		endif
	endif
next i


]]>
</Script_PR>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_UI SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! ------------------------------------------------------------------------------
! Localization
! ------------------------------------------------------------------------------
dim stToolTips[6]
	stToolTips[1]	= `Previous`
	stToolTips[2]	= `Next`
	stToolTips[3]	= `First`
	stToolTips[4]	= `Up`
	stToolTips[5]	= `Down`
	stToolTips[6]	= `Last`

dim stTabPage[6]
	stTabPage[1] = `General Settings`
	stTabPage[2] = `Joints`
	stTabPage[3] = `T Connections`
	stTabPage[4] = `Columns`
	stTabPage[5] = `Attributes`
	stTabPage[6] = `Information`

dim stTconn[2]
	stTconn[1]	= `Oposite Side`
	stTconn[2]	= `Reference Side`

dim stJoint[6]
	stJoint[1]	= `Joints`
	stJoint[2]	= `Joint 1`
	stJoint[3]	= `Joint 2`
	stJoint[4]	= `Type`
	stJoint[5]	= `Override Angle`
	stJoint[6]	= `Angle`

dim stJointSide[8]
	stJointSide[1]	= `Automatic`
	stJointSide[2]	= `None`
	stJointSide[3]	= `With Profile`
	stJointSide[4]	= `End Cap`
	stJointSide[5]	= `Corner 1`
	stJointSide[6]	= `Corner 2`
	stJointSide[7]	= `Connection 1`
	stJointSide[8]	= `Connection 2`

dim stMortar[3]
	stMortar[1]	= `Mortars`
	stMortar[2]	= `Base Mortar`
	stMortar[3]	= `Mortar Thk.`

dim stStartRowHeight[4]
	stStartRowHeight[1]	= `Start Row`
	stStartRowHeight[2]	= `Start Row Height`
	stStartRowHeight[3]	= `None`
	stStartRowHeight[4]	= `Automatic`

dim stConnWalls[17]
	stConnWalls[1]	= `Position`
	stConnWalls[2]	= `Thickness`
	stConnWalls[3]	= `Bottom`
	stConnWalls[4]	= `Top`
	stConnWalls[5]	= `Connected Wall Definitions`
	stConnWalls[6]	= `Direction`
	stConnWalls[7]	= `Position from the left corner`
	stConnWalls[8]	= `Connected Wall Thickness`
	stConnWalls[9]	= `Connecting Wall Bottom level`
	stConnWalls[10]	= `Connecting Wall Top level`
	stConnWalls[11] = `On this side you can set up the connected walls' position, type and thickness!` 
	stConnWalls[12] = `The position and the orientation of the connection is also available to set up on the floor plan!`
	stConnWalls[13]	= `Add Connection`
	stConnWalls[14]	= `Delete Connection`
	stConnWalls[15]	= `Add New Connection`
	stConnWalls[16]	= `Angle`
	stConnWalls[17]	= `Thk.`

dim stColumns[9]
	stColumns[1]	= `Columns Definition`
	stColumns[2]	= `Position from the left corner`
	stColumns[3]	= ``
	stColumns[4]	= ``
	stColumns[5]	= `Add Column`
	stColumns[6]	= `Delete Column`
	stColumns[7]	= `Add New Column`
	stColumns[8]	= `On this side you can set up the colums position!` 
	stColumns[9]	= `The position of the columns is also available to set up on the floor plan!`

dim stGeneral[21]
	stGeneral[1]	= `Geometry Settings`
	stGeneral[2]	= `Block Type`
	stGeneral[3]	= `Mirror Block Direction`
	stGeneral[4]	= `Flip Rows`
	stGeneral[5]	= `Use Top Contour`
	stGeneral[6]	= `Use Bottom Contour`
	stGeneral[7]	= `Lintel Type`
	stGeneral[8]	= `Top Wall Connection`
	stGeneral[9]	= `Bottom Wall Connection`
	stGeneral[10]	= `Reveal type`
	stGeneral[11]	= ``
	stGeneral[12]	= `Prefer Half Block Joints`
	stGeneral[13]	= `Custom Thickness`
	stGeneral[14]	= `Weight system`
	stGeneral[15]	= `Thickness`
	stGeneral[16]	= `Product Settings`
	stGeneral[17]	= `Type`
	stGeneral[18]	= ``
	stGeneral[19]	= `Show Editing Hotspot`
	stGeneral[20]	= ``
	stGeneral[21]	= ``

dim st2DUI[9]
	st2DUI[1] = `2D Representation`
	st2DUI[2] = `Contour Pen`
	st2DUI[3] = `Fill Type`
	st2DUI[4] = `Fill Pen`
	st2DUI[5] = `Background Pen`
	st2DUI[6] = `Type`
	st2DUI[7] = `Blocks`
	st2DUI[8] = `Show Render`
	st2DUI[9] = `Show Side View`

dim st3DUI[12]
	st3DUI[1] = `3D Representation`
	st3DUI[2] = `Detail Level`
	st3DUI[3] = `3D Pen`
	st3DUI[4] = `Brick Material`
	st3DUI[5] = `Resolution`
	st3DUI[6] = `Grout Material`
	st3DUI[7] = `Show Grout`
	st3DUI[8] = `Insulation Material`
	st3DUI[9] = `Profile Material`
	st3DUI[10] = `Use Internal Material`
	st3DUI[11] = `Plaster Material`
	st3DUI[12] = `Show Render`


! ------------------------------------------------------------------------------
! Header
! ------------------------------------------------------------------------------
ui_dialog `KS-Quadro Wall`
ui_current_page gs_ui_current_page
ui_page gs_ui_current_page

xCompLogo	= 0
yCompLogo	= 0
wCompLogo	= 28
hCompLogo	= 28
dStartSep	= 0

px = 30
py = 20
cx = px
cy = py

factoryLink = ""
if iLang = LANG_DE then factoryLink = "http://http://www.ks-quadro.de/"

ui_pict "ks_quadro_logo", xCompLogo, yCompLogo, wCompLogo, hCompLogo, 1
!!if elemColumnIdx > 0 then
!!	ui_infield{3} "gs_ui_current_page", 100,0, 150, cy+5,
!!		2, "ks_quadro_ui_tabicons",
!!		10, 10,
!!		cx, cy, px, py,
!!		2,	stTabPage[1],	1,
!!		3,	stTabPage[2],	2,
!!		4,	stTabPage[3],	3,
!!		10,	stTabPage[6],	4,
!!		5,	stTabPage[4],	5,
!!		9,	stTabPage[5],	6
!!else
!!	ui_infield{3} "gs_ui_current_page", 100,0, 150, cy+5,
!!		2, "ks_quadro_ui_tabicons",
!!		10, 10,
!!		cx, cy, px, py,
!!		2,	stTabPage[1],	1,
!!		3,	stTabPage[2],	2,
!!		4,	stTabPage[3],	3,
!!		5,	stTabPage[4],	4,
!!		9,	stTabPage[5],	5
!!endif

UI_INFORMATION_ID	= 5 + (elemColumnIdx > 0)

!!ui_pict_button ui_prev, "", "ui_prev_menu", 253, 0, 28, 25, gs_ui_current_page - 1
!!if gs_ui_current_page < 5+(elemColumnIdx > 0) then
!!	ui_pict_button ui_next, "", "ui_next_menu", 282, 0, 28, 25, gs_ui_current_page + 1
!!	ui_pict "bimobject_logo_24", 312, 0, 131, 24, 1	ui_tooltip "http://bimobject.com"
!!else
!!	nameAC = ""
!!	qq = request ("name_of_program", "", nameAC)
!!	isWin = (strstr (nameAC, ".exe") or strstr (nameAC, ".EXE"))
!!	ui_pict_button ui_link, `Link to Manufacturer`, "", 282, 2 * isWin, 161, 25 - 4 * isWin, 0, factoryLink
!!endif
if gs_ui_current_page = UI_INFORMATION_ID then
	nameAC = ""
	qq = request ("name_of_program", "", nameAC)
	isWin = (strstr (nameAC, ".exe") or strstr (nameAC, ".EXE"))
	if not(factoryLink = "") then
		ui_pict_button ui_link, `Link to Manufacturer`, "", 282, 2 * isWin, 161, 25 - 4 * isWin, 0, factoryLink ui_tooltip factoryLink
	endif
endif

ui_separator 1 + dStartSep, 29, 443, 29

ui_style 0, 0

! --- Menu push-buttons ---
iMenuNum		= UI_INFORMATION_ID
wLogoSection	= 282 - (xCompLogo + wCompLogo) - 5
dxLogo			= wLogoSection / (iMenuNum - 1)
wMenuBut		= dxLogo - 2
idxMenu			= gs_ui_current_page
for w = iMenuNum to 1 step -1
	dyMenuBut	= (abs (idxMenu - w) < eps) * 2
	xb	= 282 + (w - iMenuNum) * dxLogo
	if w <= iMenuNum then
		if abs (w - iMenuNum) < eps and not(gs_ui_current_page = UI_INFORMATION_ID) then	ui_pict_button ui_function, "", "bimobject_logo_menubutton",	282, dyMenuBut, 161, 25, w	ui_tooltip stTabPage[6]
		if abs (w - 1) < eps then			ui_pict_button ui_function, "", "menu_icon_wall_general_ac20",				xb, dyMenuBut, wMenuBut, 25, w			ui_tooltip stTabPage[w]
		if abs (w - 2) < eps then			ui_pict_button ui_function, "", "menu_icon_wall_joints_ac20",	xb, dyMenuBut, wMenuBut, 25, w			ui_tooltip stTabPage[w]
		if abs (w - 3) < eps then			ui_pict_button ui_function, "", "menu_icon_Tconnection_2_ac20",		xb, dyMenuBut, wMenuBut, 25, w			ui_tooltip stTabPage[w]
		if elemColumnIdx > 0 then
			if abs (w - 4) < eps then			ui_pict_button ui_function, "", "menu_icon_wall_coloumn_ac20",		xb, dyMenuBut, wMenuBut, 25, w			ui_tooltip stTabPage[w]
		endif
		idx = 4 + (elemColumnIdx > 0)
		if abs (w - idx) < eps then			ui_pict_button ui_function, "", "menu_icon_2drepresentation_ac20",	xb, dyMenuBut, wMenuBut, 25, w		ui_tooltip stTabPage[5]
	endif
next w
if not(gs_ui_current_page = UI_INFORMATION_ID) then
	ui_pict "ui_bo_blue_1x1", 282 + (idxMenu - iMenuNum) * dxLogo, 27, wMenuBut, 2
endif


! ==============================================================================
! ==============================================================================



pageID = 0
pageID = pageID + 1
ui_page pageID, -1, stTabPage[pageID],				"menu_icon_wall_general_ac20"
gosub "general"

pageID = pageID + 1
ui_page pageID, -1, stTabPage[pageID],				"menu_icon_wall_joints_ac20"
gosub "joints"

pageID = pageID + 1
ui_page pageID, -1, stTabPage[pageID],				"menu_icon_Tconnection_2_ac20"
gosub "T-connection"

if elemColumnIdx > 0 then
	pageID = pageID + 1
	ui_page pageID, -1, stTabPage[pageID],			"menu_icon_wall_coloumn_ac20"
	gosub "coloumns"
endif

pageID = pageID + 1
ui_page pageID, -1, stTabPage[pageID],				"menu_icon_2drepresentation_ac20"
gosub "2drepresentation"

pageID = pageID + 1
ui_page UI_INFORMATION_ID, -1, stTabPage[pageID],	"menu_icon_boinfo_18x18"
gosub "info"


! ==============================================================================
! ============ END ============ END ============ END ============ END ==========
! ==============================================================================

end

! ==============================================================================
! ============ END ============ END ============ END ============ END ==========
! ==============================================================================


! ======================================================================
!
! Page 1	General
!
! ======================================================================
"general":
	xStart		= 10
	yStart		= 35
	dy			= 23
	dy2			= 14
	hRow		= 18
	hRow2		= 12
	xHalfLevel	= 300
	wDescript2	= 150
	wDescript1	= 70
	wDescript3	= 120
	wDescript4	= 100
	wDescript5	= 80
	wDescript6	= 120

	y = yStart

	! ------------- Product -----------------------------------------
	ui_style 0, 1
	ui_outfield stGeneral[16], 5, y, xHalfLevel-xStart-wDescript6-10, hRow-2
	ui_infield{3} "iLang", xHalfLevel-xStart-wDescript6, y-3, wDescript6, hRow+2,
		8,"",0,0,
		0, 0, 0, 0,
		0,	"Austria", 					LANG_AT,
		0,	"Belgium", 					LANG_BE,
		0,	"Bosnia and Hercegovina",	LANG_BA,
		0,	"Bulgaria",					LANG_BG,
		0,	"China",					LANG_CN,
		0,	"Croatia",					LANG_HR,
		0,	"Czech Republic",			LANG_CZ,
		0,	"Denmark",					LANG_DK,
		0,	"Finland",					LANG_FI,
		0,	"France", 					LANG_FR,
		0,	"Germany",					LANG_DE,
		0,	"Hungary",					LANG_HU,
		0,	"Italy",					LANG_IT,
		0,	"Kosovo",					LANG_XK,
		0,	"Mexico",					LANG_MX,
		0,	"Netherlands",				LANG_NL,
		0,	"Norway",					LANG_NO,
		0,	"Poland",					LANG_PL,
		0,	"Romania",					LANG_RO,
		0,	"Russia",					LANG_RU,
		0,	"Serbia",					LANG_RS,
		0,	"Slovakia",					LANG_SK,
		0,	"Slovenia",					LANG_SI,
		0,	"Spain",					LANG_ES,
		0,	"Sweden",					LANG_SE,
		0,	"Switzerland",				LANG_CH,
		0,	"Turkey",					LANG_TR,
		0,	"United Kingdom",			LANG_UK,
		0,	"United States",			LANG_US


	ui_style 0, 0
	y = y + dy

	if not(bValidFamily) then
		ui_outfield `Error: Not found valid family. Please choose other region`, xStart, y, xHalfLevel-2*xStart, hRow
		end
	endif
	
	maxFamily = 20
	dim avaFamilysStr[]
	for i = maxFamily to nAvailableFamilys + 1 step -1
		avaFamilys[i]		= 0
		avaFamilysStr[i]	= ""
	next i
	for i = nAvailableFamilys to 1 step -1
		avaFamilysStr[i] = datProdName[avaFamilysIdxs[i]] 
	next i

	ui_outfield stGeneral[17], xStart, y, wDescript1-2, hRow
	ui_infield{3} "iFamily", xStart+wDescript1, y-3, xHalfLevel-2*xStart-wDescript1, hRow+2,
		8,"",0,0,
		0, 0, 0, 0,
		0,	avaFamilysStr[ 1], avaFamilys[ 1],
		0,	avaFamilysStr[ 2], avaFamilys[ 2],
		0,	avaFamilysStr[ 3], avaFamilys[ 3],
		0,	avaFamilysStr[ 4], avaFamilys[ 4],
		0,	avaFamilysStr[ 5], avaFamilys[ 5],
		0,	avaFamilysStr[ 6], avaFamilys[ 6],
		0,	avaFamilysStr[ 7], avaFamilys[ 7],
		0,	avaFamilysStr[ 8], avaFamilys[ 8],
		0,	avaFamilysStr[ 9], avaFamilys[ 9],
		0,	avaFamilysStr[10], avaFamilys[10],
		0,	avaFamilysStr[11], avaFamilys[11],
		0,	avaFamilysStr[12], avaFamilys[12],
		0,	avaFamilysStr[13], avaFamilys[13],
		0,	avaFamilysStr[14], avaFamilys[14],
		0,	avaFamilysStr[15], avaFamilys[15],
		0,	avaFamilysStr[16], avaFamilys[16],
		0,	avaFamilysStr[17], avaFamilys[17],
		0,	avaFamilysStr[18], avaFamilys[18],
		0,	avaFamilysStr[19], avaFamilys[19],
		0,	avaFamilysStr[20], avaFamilys[20]
	y = y + dy

	maxThickness = 30
	dim showThickness[]
	for i = maxThickness to 1 step -1
		showThickness[i] = ""
	next i
	for i = vardim1(brickThicknesses) to 1 step -1
		showThickness[i] = str(brickThicknesses[i]*mmMultiplier,1,0) + "mm"
	next i
	ui_outfield stGeneral[15], xStart, y, wDescript1-2, hRow
	ui_infield{3} "iThickness", xStart+wDescript1, y-3, xHalfLevel-2*xStart-wDescript1, hRow+2,
		8,"",0,0,
		0, 0, 0, 0,
		0,	showThickness[1], 1,
		0,	showThickness[2], 2,
		0,	showThickness[3], 3,
		0,	showThickness[4], 4,
		0,	showThickness[5], 5,
		0,	showThickness[6], 6,
		0,	showThickness[7], 7,
		0,	showThickness[8], 8,
		0,	showThickness[9], 9,
		0,	showThickness[10], 10,
		0,	showThickness[11], 11,
		0,	showThickness[12], 12,
		0,	showThickness[13], 13,
		0,	showThickness[14], 14,
		0,	showThickness[15], 15,
		0,	showThickness[16], 16,
		0,	showThickness[17], 17,
		0,	showThickness[18], 18,
		0,	showThickness[19], 19,
		0,	showThickness[20], 20,
		0,	showThickness[21], 20,
		0,	showThickness[22], 22,
		0,	showThickness[23], 23,
		0,	showThickness[24], 24,
		0,	showThickness[25], 25,
		0,	showThickness[26], 26,
		0,	showThickness[27], 27,
		0,	showThickness[28], 28,
		0,	showThickness[29], 29,
		0,	showThickness[30], 30
	y = y + dy


	dim productDisplayName[]
	gosub "productNamesWithDim"
	maxProduct = 50
	dim avaProductTypesStr[]
	for i = maxProduct to nAvaProductTypes + 1 step -1
		avaProductTypes[i]		= 0
		avaProductTypesStr[i]	= ""
	next i
	for i = nAvaProductTypes to 1 step -1
		avaProductTypesStr[i] = productDisplayName[avaProductTypesIdxs[i]] 
	next i

	ui_outfield stGeneral[2], xStart, y, wDescript1-2, hRow

	ui_infield{3} "iProductType", xStart+wDescript1, y-3, xHalfLevel-2*xStart-wDescript1, hRow+2,
		8, "", 0, 0,
		0, 0, 0, 0,
		0,	avaProductTypesStr[ 1], avaProductTypes[ 1],
		0,	avaProductTypesStr[ 2], avaProductTypes[ 2],
		0,	avaProductTypesStr[ 3], avaProductTypes[ 3],
		0,	avaProductTypesStr[ 4], avaProductTypes[ 4],
		0,	avaProductTypesStr[ 5], avaProductTypes[ 5],
		0,	avaProductTypesStr[ 6], avaProductTypes[ 6],
		0,	avaProductTypesStr[ 7], avaProductTypes[ 7],
		0,	avaProductTypesStr[ 8], avaProductTypes[ 8],
		0,	avaProductTypesStr[ 9], avaProductTypes[ 9],
		0,	avaProductTypesStr[10], avaProductTypes[10],
		0,	avaProductTypesStr[11], avaProductTypes[11],
		0,	avaProductTypesStr[12], avaProductTypes[12],
		0,	avaProductTypesStr[13], avaProductTypes[13],
		0,	avaProductTypesStr[14], avaProductTypes[14],
		0,	avaProductTypesStr[15], avaProductTypes[15],
		0,	avaProductTypesStr[16], avaProductTypes[16],
		0,	avaProductTypesStr[17], avaProductTypes[17],
		0,	avaProductTypesStr[18], avaProductTypes[18],
		0,	avaProductTypesStr[19], avaProductTypes[19],
		0,	avaProductTypesStr[20], avaProductTypes[20],
		0,	avaProductTypesStr[21], avaProductTypes[21],
		0,	avaProductTypesStr[22], avaProductTypes[22],
		0,	avaProductTypesStr[23], avaProductTypes[23],
		0,	avaProductTypesStr[24], avaProductTypes[24],
		0,	avaProductTypesStr[25], avaProductTypes[25],
		0,	avaProductTypesStr[26], avaProductTypes[26],
		0,	avaProductTypesStr[27], avaProductTypes[27],
		0,	avaProductTypesStr[28], avaProductTypes[28],
		0,	avaProductTypesStr[29], avaProductTypes[29],
		0,	avaProductTypesStr[30], avaProductTypes[30],
		0,	avaProductTypesStr[31], avaProductTypes[31],
		0,	avaProductTypesStr[32], avaProductTypes[32],
		0,	avaProductTypesStr[33], avaProductTypes[33],
		0,	avaProductTypesStr[34], avaProductTypes[34],
		0,	avaProductTypesStr[35], avaProductTypes[35],
		0,	avaProductTypesStr[36], avaProductTypes[36],
		0,	avaProductTypesStr[37], avaProductTypes[37],
		0,	avaProductTypesStr[38], avaProductTypes[38],
		0,	avaProductTypesStr[39], avaProductTypes[39],
		0,	avaProductTypesStr[40], avaProductTypes[40],
		0,	avaProductTypesStr[41], avaProductTypes[41],
		0,	avaProductTypesStr[42], avaProductTypes[42],
		0,	avaProductTypesStr[43], avaProductTypes[43],
		0,	avaProductTypesStr[44], avaProductTypes[44],
		0,	avaProductTypesStr[45], avaProductTypes[45],
		0,	avaProductTypesStr[46], avaProductTypes[46],
		0,	avaProductTypesStr[47], avaProductTypes[47],
		0,	avaProductTypesStr[48], avaProductTypes[48],
		0,	avaProductTypesStr[49], avaProductTypes[49],
		0,	avaProductTypesStr[50], avaProductTypes[50]
	y = y + dy

	dim uiBeamTypes[], uiBeamIdx[]
	maxBeam = 20
	for i = maxBeam to 1 step -1
		uiBeamTypes[i]	= ""
		uiBeamIdx[i]	= 0
	next i
!!	for i = 1 to nBeamParameters
!!		if beamParametersArrayIdxs[i] = 0 then
!!			uiBeamTypes[i] = ""
!!			if beamParametersArray[i] = BEAM_FAMILY_NONE then
!!				uiBeamTypes[i] = beamLocNone
!!			endif
!!			if beamParametersArray[i] = BEAM_FAMILY_CUSTOM then
!!				uiBeamTypes[i] = beamLocCustom
!!			endif
!!		else
!!			uiBeamTypes[i]	= datProdBeamName[beamParametersArrayIdxs[i]] 
!!		endif
!!		uiBeamIdx[i]	= beamParametersArray[i]
!!	next i
	for i = 1 to nAvaBeamFamilysAll
		if iAvaBeamFamilysAllIdxs[i] = 0 then
			uiBeamTypes[i] = ""
			if iAvaBeamFamilysAll[i] = BEAM_FAMILY_NONE then
				uiBeamTypes[i] = beamLocNone
			endif
			if iAvaBeamFamilysAll[i] = BEAM_FAMILY_CUSTOM then
				uiBeamTypes[i] = beamLocCustom
			endif
		else
			uiBeamTypes[i]	= datProdBeamName[iAvaBeamFamilysAllIdxs[i]] 
		endif
		uiBeamIdx[i]	= iAvaBeamFamilysAll[i]
	next i
	ui_outfield stGeneral[7], xStart, y, wDescript1-2, hRow
	ui_infield{3} "iBeamFamily", xStart+wDescript1, y-3, xHalfLevel-2*xStart-wDescript1, hRow+2,
		8,"",0,0,
		0, 0, 0, 0,
		0,	uiBeamTypes[1], uiBeamIdx[1],
		0,	uiBeamTypes[2], uiBeamIdx[2],
		0,	uiBeamTypes[3], uiBeamIdx[3],
		0,	uiBeamTypes[4], uiBeamIdx[4],
		0,	uiBeamTypes[5], uiBeamIdx[5],
		0,	uiBeamTypes[6], uiBeamIdx[6],
		0,	uiBeamTypes[7], uiBeamIdx[7],
		0,	uiBeamTypes[8], uiBeamIdx[8],
		0,	uiBeamTypes[9], uiBeamIdx[9],
		0,	uiBeamTypes[10], uiBeamIdx[10],
		0,	uiBeamTypes[11], uiBeamIdx[11],
		0,	uiBeamTypes[12], uiBeamIdx[12],
		0,	uiBeamTypes[13], uiBeamIdx[13],
		0,	uiBeamTypes[14], uiBeamIdx[14],
		0,	uiBeamTypes[15], uiBeamIdx[15],
		0,	uiBeamTypes[16], uiBeamIdx[16],
		0,	uiBeamTypes[17], uiBeamIdx[17],
		0,	uiBeamTypes[18], uiBeamIdx[18],
		0,	uiBeamTypes[19], uiBeamIdx[19],
		0,	uiBeamTypes[20], uiBeamIdx[20]
	y = y + dy

	if elemWindowIdx then
		ui_outfield stGeneral[10], xStart, y, wDescript1-2, hRow
		ui_infield{3} "iWindowBrick", xStart+wDescript1, y-3, xHalfLevel-2*xStart-wDescript1, hRow+2,
			8,"",0,0,
			0, 0, 0, 0,
			0,	`None`, BRICK_NONE,
			0,	datBrickName[elemWindowIdx], elemWindowIdx

		y = y + dy
	endif


	dim strBrickInfo[][3]
	gosub "brickProductPhysik"

	dx = 0
!!	dy0 = 0
!!	y0 = y
	for i = 1 to vardim1(strBrickInfo)
!!		dx = 220 * (i > 8)
		if strBrickInfo[i][3] = "" then
			ui_outfield strBrickInfo[i][1], dx + xStart, y, xHalfLevel-2*xStart-wDescript4-2-70*0, hRow2
			ui_outfield strBrickInfo[i][2], dx + xHalfLevel-xStart-wDescript4-70*0, y, wDescript4, hRow2, 1
			y = y + dy2
		else
			ui_outfield strBrickInfo[i][3], dx + xStart, y, xHalfLevel-2*xStart-70*0, hRow2, 1
			y = y + dy-4
			dy0 = dy - 4
		endif
!!		if i = 8 then y = y0 + dy0
	next i
!!	if vardim1(strBrickInfo) > 8 then
!!		ui_separator dx + xStart - 5, y0, dx + xStart - 5, 264
!!	endif

	! ------------- Geometry -----------------------------------------
	y = yStart
	ui_style 0, 1
	ui_outfield stGeneral[1], xHalfLevel+5, y, 444-xHalfLevel-xStart, hRow-2
	ui_style 0, 0
	y = y + dy

	ui_infield{3} "bShowEdit", xHalfLevel+xStart, y-2, 444-xHalfLevel-2*xStart, hRow,
		7, "", 0, 0,
		0, 0, 0, 0,
		0,	stGeneral[19], 0,
		0,	stGeneral[19], 1
	y = y + dy

	ui_infield{3} "bUseTopContour", xHalfLevel+xStart, y-2, 40, 20,
		6, "ks_quadro_contour_top", 2, 1,
		32, 16, 32, 16,
		1,	stGeneral[5], 0,
		2,	stGeneral[5], 1		ui_tooltip stGeneral[5]

	ui_infield{3} "bTopWallConnection", xHalfLevel+xStart+45, y-2, 40, 20,
		6, "ks_quadro_con_top", 2, 1,
		32, 16, 32, 16,
		1,	stGeneral[8], 0,
		2,	stGeneral[8], 1		ui_tooltip stGeneral[8]
	y = y + dy

	ui_infield{3} "bUseBottomContour", xHalfLevel+xStart, y-2, 40, 20,
		6, "ks_quadro_contour_bot", 2, 1,
		32, 16, 32, 16,
		1,	stGeneral[6], 0,
		2,	stGeneral[6], 1		ui_tooltip stGeneral[6]

	ui_infield{3} "bBotWallConnection", xHalfLevel+xStart+45, y-2, 40, 20,
		6, "ks_quadro_con_bot", 2, 1,
		32, 16, 32, 16,
		1,	stGeneral[9], 0,
		2,	stGeneral[9], 1		ui_tooltip stGeneral[9]
	y = y + dy

!!	ui_infield{3} "brickDir", xHalfLevel+xStart, y-2, 444-xHalfLevel-2*xStart, hRow,
!!		7,"", 0, 0,
!!		0, 0, 0, 0,
!!		0,	stGeneral[3], 0,
!!		0,	stGeneral[3], 1
!!	y = y + dy

	ui_infield{3} "startRow", xHalfLevel+xStart, y-2, 444-xHalfLevel-2*xStart, hRow,
		7, "", 0, 0,
		0, 0, 0, 0,
		0,	stGeneral[4], 0,
		0,	stGeneral[4], 1
	y = y + dy

!!	ui_infield{3} "bHalfStone", xHalfLevel+xStart, y-2, 444-xHalfLevel-2*xStart, hRow,
!!		7, "", 0, 0,
!!		0, 0, 0, 0,
!!		0,	stGeneral[12], 0,
!!		0,	stGeneral[12], 1
!!	y = y + dy


	y = y + 4
	if bCurvedWall then
		ui_pict "ui_alert_16", xHalfLevel+xStart, y-2, 16, 16, 1
		ui_outfield stCurvedWall, xHalfLevel+xStart+20, y-4, 444-xHalfLevel-xStart-24, 28
		y = y + 30
	endif
	if nOversizedLinder then
		ui_pict "ui_alert_16", xHalfLevel+xStart, y-2, 16, 16, 1
		ui_outfield stOversized, xHalfLevel+xStart+20, y-4, 444-xHalfLevel-xStart-24, 50
		y = y + 55
	endif
	if nOverlappedLinders then
		ui_pict "ui_alert_16", xHalfLevel+xStart, y-2, 16, 16, 1
		ui_outfield stCollision, xHalfLevel+xStart+20, y-4, 444-xHalfLevel-xStart-24, 50
		y = y + 55
	endif
	if nLinderPosError then
		inputStr		= stPosIncorrect
		strSeparator	= "\n"
		gosub "textReplacer"
		ui_pict "ui_alert_16", xHalfLevel+xStart, y-2, 16, 16, 1
		ui_outfield outStr, xHalfLevel+xStart+20, y-4, 444-xHalfLevel-xStart-24, 50
		y = y + 55
	endif
	if bOpeningFormWarning then
		ui_pict "ui_alert_16", xHalfLevel+xStart, y-2, 16, 16, 1
		ui_outfield stOpeningForm, xHalfLevel+xStart+20, y-4, 444-xHalfLevel-xStart-24, 50
		y = y + 55
	endif
!!	if bHasCornerWindow then
!!		ui_pict "ui_alert_16", xHalfLevel+xStart, y-2, 16, 16, 1
!!		ui_outfield stCornerWindow, xHalfLevel+xStart+20, y-4, 444-xHalfLevel-xStart-24, 50
!!		y = y + 55
!!	endif

return

! ======================================================================
!
! Page 2	Joints
!
! ======================================================================
"joints":
	xStart		= 10
	yStart		= 40
	dy			= 21
	yInfield	= 19
	hRow		= 18
	xHalfLevel	= 222
	wDescript2	= 150
	wDescript1	= 70
	wDescript3	= 120
	wDescript4	= 70

	y = yStart
	! ------------- Joints -----------------------------------------
	ui_style 0, 1
	ui_outfield stJoint[1], 5, y, wDescript1, 16
	ui_style 0, 0
	y = y + dy+10

	ui_outfield stJoint[2], xStart, y, wDescript1-2, hRow
	ui_outfield stJoint[3], xHalfLevel+xStart, y, wDescript1-2, hRow

	ui_infield{3} "iJointType1", xStart+wDescript1, y-20, wDescript3, 68,
		2,"ks_quadro_connection", 8, 1,
		60, 60, 60, 60,
		1,	stJointSide[1], JOINT_SIDE_AUTO,
		2,	stJointSide[2], JOINT_SIDE_NONE,
		3,	stJointSide[3], JOINT_SIDE_PROFILE,
		4,	stJointSide[4], JOINT_SIDE_END,
		5,	stJointSide[5], JOINT_SIDE_CORNER_1,
		6,	stJointSide[6], JOINT_SIDE_CORNER_2,
		7,	stJointSide[7], JOINT_SIDE_CORNER_T_1,
		8,	stJointSide[8], JOINT_SIDE_CORNER_T_2

	ui_infield{3} "iJointType2", xHalfLevel+xStart+wDescript1, y-20, wDescript3, 68,
		2,"ks_quadro_connection", 8, 1,
		60, 60, 60, 60,
		1,	stJointSide[1], JOINT_SIDE_AUTO,
		2,	stJointSide[2], JOINT_SIDE_NONE,
		3,	stJointSide[3], JOINT_SIDE_PROFILE,
		4,	stJointSide[4], JOINT_SIDE_END,
		5,	stJointSide[5], JOINT_SIDE_CORNER_1,
		6,	stJointSide[6], JOINT_SIDE_CORNER_2,
		7,	stJointSide[7], JOINT_SIDE_CORNER_T_1,
		8,	stJointSide[8], JOINT_SIDE_CORNER_T_2

	y = y + 70 - 18

	ui_infield{3} "bJointAngle1", xStart, y, wDescript1+wDescript3-wDescript4-2, hRow,
		7,"", 0, 0,
		0, 0, 0, 0,
		0,	stJoint[5], 0,
		0,	stJoint[5], 1
	ui_infield "jointAngle1", xStart+wDescript1+wDescript3-wDescript4, y, wDescript4, hRow ui_tooltip stJoint[4]

	ui_infield{3} "bJointAngle2", xHalfLevel+xStart, y, wDescript1+wDescript3-wDescript4-2, hRow,
		7,"", 0, 0,
		0, 0, 0, 0,
		0,	stJoint[5], 0,
		0,	stJoint[5], 1
	ui_infield "jointAngle2", xHalfLevel+xStart+wDescript1+wDescript3-wDescript4, y, wDescript4, hRow ui_tooltip stJoint[4]
	y = y + dy-2

	yOff = 5	!10
	ui_infield{3} "bCustomCsorba1", xStart, y, wDescript1+wDescript3-wDescript4-2, hRow+yOff*2,
		7,"", 0, 0,
		0, 0, 0, 0,
		0,	stGeneral[13], 0,
		0,	stGeneral[13], 1
	ui_infield "csorbaW1", xStart+wDescript1+wDescript3-wDescript4, y+yOff, wDescript4, hRow

	ui_infield{3} "bCustomCsorba2", xHalfLevel+xStart, y, wDescript1+wDescript3-wDescript4-2, hRow+yOff*2,
		7,"", 0, 0,
		0, 0, 0, 0,
		0,	stGeneral[13], 0,
		0,	stGeneral[13], 1
	ui_infield "csorbaW2", xHalfLevel+xStart+wDescript1+wDescript3-wDescript4, y+yOff, wDescript4, hRow
	y = y + 10 + dy-2

	ui_separator 0, y, 444, y
	y = y + 8


	!----------------- Mortars --------------------------------------
	ui_style 0, 1
	ui_outfield stMortar[1], 5, y, wDescript1, 16
	ui_style 0, 0
	y = y + dy

	ui_outfield stMortar[2], xStart, y, wDescript1+wDescript3-wDescript4-2, hRow
	ui_infield "baseMortarThk", xStart+wDescript1+wDescript3-wDescript4, y-2, wDescript4, hRow ui_tooltip stMortar[2]

	ui_outfield stMortar[3], xHalfLevel+xStart, y, wDescript1+wDescript3-wDescript4-2, hRow
	ui_infield "mortarThk", xHalfLevel+xStart+wDescript1+wDescript3-wDescript4, y-2, wDescript4, hRow ui_tooltip stMortar[3]
	y = y + dy

	!----------------- Start Height --------------------------------------
	yStart = y
	ui_style 0, 1
	ui_outfield stStartRowHeight[1], 5, y, wDescript1, 16
	ui_style 0, 0

	ui_infield{3} "bAutoStartBrick", xStart+wDescript1+wDescript3-wDescript4, y-2, wDescript4, hRow,
		7,"", 0, 0,
		0, 0, 0, 0,
		0,	stStartRowHeight[4], 0,
		0,	stStartRowHeight[4], 1
	y = y + dy

	dim stRowH[]
	for i = 1 to vardim1(avaStartRowHeight)
		if abs(avaStartRowHeight[i]) < EPS then
			stRowH[i] = stStartRowHeight[3]
		else
			stRowH[i] = str(avaStartRowHeight[i] * mmMultiplier, 1, 0) + " mm"
		endif
	next i

	ui_outfield stStartRowHeight[2], xStart, y, wDescript1+wDescript3-wDescript4-2, hRow, 4 * (disableStartBrickHeight | bAutoStartBrick)
	ui_infield{3} "iStartBrickHeight", xStart+wDescript1+wDescript3-wDescript4, y-2, wDescript4, hRow,
		8,"", 0, 0,
		0, 0, 0, 0,
		0,	stRowH[1], 0,
		0,	stRowH[2], 1,
		0,	stRowH[3], 2,
		0,	stRowH[4], 3

return

! ======================================================================
!
! Page 3	T Connection Settings
!
! ======================================================================
"T-connection":
	x1			= 5
	xStart		= 10
	yStart		= 40
	dy			= 23
	dy2			= 30
	hRow		= 18
	fillBoxW	= 110
	matBoxW		= 100
	fillBoxH	= 26
	penBoxH		= 22
	xHalfLevel	= 222
	x1ndRow		= 20
	x2ndRow		= 130
	x3rdRow		= 200
	x4thRow		= 250
	x5thRow		= 300
	x6thRow		= 350
	x7thRow		= 400-2
	wDescript2	= 60
	wDescript3	= 100
	wDescript4	= 160
	penBoxW		= 35
	buttonX		= 13
	buttonY 	= 13

	y = yStart+1
	
	ui_style 0, 1
	ui_infield{3} "tConnections", xStart, y-2, xHalfLevel-xStart, hRow,
		7, "", 0, 0,
		0, 0, 0, 0,
		0, stConnWalls[5], 0,
		0, stConnWalls[5], 1

	y = y + dy-2
	ui_separator xStart, y, 444-xStart, y
	y = y  + 6

	if not(tConnections) then 
		ui_style 0, 0

		ui_outfield stConnWalls[11], xStart, y, 200, 40
		ui_outfield stConnWalls[12], xStart, y+40, 200, 40
	else

		ui_style 0, 0
		ui_outfield stConnWalls[6],  x1ndRow, y, x2ndRow-x1ndRow-1, 12
		ui_outfield stConnWalls[1],  x2ndRow, y, x3rdRow-x2ndRow-1, 12
		ui_outfield stConnWalls[17], x3rdRow, y, x4thRow-x3rdRow-1, 12
		ui_outfield stConnWalls[3],  x4thRow, y, x5thRow-x4thRow-1, 12
		ui_outfield stConnWalls[4],  x5thRow, y, x6thRow-x5thRow-1, 12
		!!ui_outfield stConnWalls[16], x6thRow, y, x7thRow-x6thRow-1, 12

		y = y + dy

		! ------------------------ Scroll ---------------------------
		gbw= uiEndX- uiStartX
		gbh= nUiRows_T*uiLineHeight+18
		ui_groupbox "", uiStartX, uiStartY, gbw-18, gbh
		butw= 15
		buth= 20
		butx= uiStartX+gbw-butw-2
		ui_groupbox "", uiEndX-20, uiStartY, 20, gbh
		ui_pict_button UI_FUNCTION, "", "ui_scroll_first",	butx, uiStartY+10,			butw, buth, BUTTON_UI_T_START	ui_tooltip stToolTips[3]
		ui_pict_button UI_FUNCTION, "", "ui_scroll_up",		butx, uiStartY+31, 			butw, buth, BUTTON_UI_T_UP		ui_tooltip stToolTips[4]
		ui_pict_button UI_FUNCTION, "", "ui_scroll_down",	butx, uiStartY+gbh-buth-26,	butw, buth, BUTTON_UI_T_DOWN	ui_tooltip stToolTips[5]
		ui_pict_button UI_FUNCTION, "", "ui_scroll_last",	butx, uiStartY+gbh-buth-5,	butw, buth, BUTTON_UI_T_END		ui_tooltip stToolTips[6]
	
		x10 = 10
		x11	= uiEndX - 25
		y	= uiStartY + 15
		firstFreePosT = nConnTParam
		for i = nUiStart_T to min(nUiStart_T+nUiRows_T-1, nTwallConn)
			idx = tValidConnIdxS[i]

			ui_infield{3} tConnWallDir[idx], x1ndRow, y, x2ndRow-x1ndRow-10, yInfield,
				8, "", 0, 0,
				0, 0, 0, 0,
				0, stTconn[1], 0,
				0, stTconn[2], brickThk

			ui_infield{2}  tConnWallPos[idx],   x2ndRow, y, 60, yInfield	ui_tooltip stConnWalls[7]
			ui_infield{2}  tConnWallThk[idx],   x3rdRow, y, 40, yInfield	ui_tooltip stConnWalls[8]
			ui_infield{2}  tConnWallHmin[idx],  x4thRow, y, 40, yInfield	ui_tooltip stConnWalls[9]
			ui_infield{2}  tConnWallHmax[idx],  x5thRow, y, 40, yInfield	ui_tooltip stConnWalls[10]
			!!ui_infield{2}  tConnWallAngle[idx], x6thRow, y, 40, yInfield	ui_tooltip stConnWalls[16]

			ui_pict_button ui_function, stConnWalls[14], "ui_button_minus", x7thRow, y+2, buttonX, buttonY, BUTTON_UI_T_MINUS+idx ui_tooltip stConnWalls[14]

			y = y + uiLineHeight
		next i


		! ======================================================================
		!!!!! Next Possible Connection Parameters 
		! ======================================================================

		y = 228
		ui_style 0, 1
		ui_outfield stConnWalls[15] ,xStart, y, wDescript4, hRow				

		y = y + dy-4
		ui_style 0, 0
		ui_infield{3} tConnWallDir[firstFreePosT], x1ndRow, y, x2ndRow-x1ndRow-10, yInfield,
			8, "", 0, 0,
			0, 0, 0, 0,
			0, stTconn[1], 0,
			0, stTconn[2], brickThk

		ui_infield{2}  tConnWallPos[firstFreePosT],   x2ndRow, y, 60, yInfield	ui_tooltip stConnWalls[7]
		ui_infield{2}  tConnWallThk[firstFreePosT],   x3rdRow, y, 40, yInfield	ui_tooltip stConnWalls[8]
		ui_infield{2}  tConnWallHmin[firstFreePosT],  x4thRow, y, 40, yInfield	ui_tooltip stConnWalls[9]
		ui_infield{2}  tConnWallHmax[firstFreePosT],  x5thRow, y, 40, yInfield	ui_tooltip stConnWalls[10]
		!!ui_infield{2}  tConnWallAngle[firstFreePosT], x6thRow, y, 40, yInfield	ui_tooltip stConnWalls[16]

		ui_pict_button ui_function, stConnWalls[13], "ui_button_plus", x7thRow, y+2, buttonX, buttonY, BUTTON_UI_T_PLUS ui_tooltip stConnWalls[15]

		y = y + dy
	endif
return

! ======================================================================
!
! Page 4	Columns
!
! ======================================================================
"coloumns":
	x1			= 5
	xStart		= 10
	yStart		= 40
	dy			= 23
	dy2			= 30
	hRow		= 18
	fillBoxW	= 110
	matBoxW		= 100
	fillBoxH	= 26
	penBoxH		= 22
	xHalfLevel	= 222
	x1ndRow		= 20
	x2ndRow		= 130
	x3rdRow		= 200
	x4thRow		= 250
	x5thRow		= 300
	x6thRow		= 350
	x7thRow		= 400-2
	wDescript2	= 60
	wDescript3	= 100
	wDescript4	= 160
	penBoxW		= 35
	buttonX		= 13
	buttonY 	= 13

	y = yStart+1
	
	ui_style 0, 1
	ui_infield{3} "bColPos", xStart, y-2, xHalfLevel-xStart, hRow,
		7, "", 0, 0,
		0, 0, 0, 0,
		0, stColumns[1], 0,
		0, stColumns[1], 1

	y = y + dy-2
	ui_separator xStart, y, 444-xStart, y
	y = y  + 6

	if not(bColPos) then 
		ui_style 0, 0

		ui_outfield stColumns[8], xStart, y, 200, 40
		ui_outfield stColumns[9], xStart, y+40, 200, 40
	else

		ui_style 0, 0
		ui_outfield stColumns[2],  x1ndRow, y, x2ndRow-x1ndRow-1, 12

		y = y + dy

		! ------------------------ Scroll ---------------------------
		gbw= uiEndX- uiStartX
		gbh= nUiRows_C*uiLineHeight+18
		ui_groupbox "", uiStartX, uiStartY, gbw-18, gbh
		butw= 15
		buth= 20
		butx= uiStartX+gbw-butw-2
		ui_groupbox "", uiEndX-20, uiStartY, 20, gbh
		ui_pict_button UI_FUNCTION, "", "ui_scroll_first",	butx, uiStartY+10,			butw, buth, BUTTON_UI_C_START	ui_tooltip stToolTips[3]
		ui_pict_button UI_FUNCTION, "", "ui_scroll_up",		butx, uiStartY+31, 			butw, buth, BUTTON_UI_C_UP		ui_tooltip stToolTips[4]
		ui_pict_button UI_FUNCTION, "", "ui_scroll_down",	butx, uiStartY+gbh-buth-26,	butw, buth, BUTTON_UI_C_DOWN	ui_tooltip stToolTips[5]
		ui_pict_button UI_FUNCTION, "", "ui_scroll_last",	butx, uiStartY+gbh-buth-5,	butw, buth, BUTTON_UI_C_END		ui_tooltip stToolTips[6]
	
		x10 = 10
		x11	= uiEndX - 25
		y	= uiStartY + 15
		firstFreePosC = nColumnParam
		for i = nUiStart_C to min(nUiStart_C+nUiRows_C-1, nColConn)
			idx = cValidConnIdxS[i]

			ui_infield{2}  colPosX[idx],   x1ndRow, y, 60, yInfield	ui_tooltip stColumns[2]

			ui_pict_button ui_function, stColumns[6], "ui_button_minus", x7thRow, y+2, buttonX, buttonY, BUTTON_UI_C_MINUS+idx ui_tooltip stColumns[6]

			y = y + uiLineHeight
		next i


		! ======================================================================
		!!!!! Next Possible Connection Parameters 
		! ======================================================================

		y = 248
		ui_style 0, 1
		ui_outfield stColumns[7] ,xStart, y, x2ndRow-xStart-1, hRow				

		ui_style 0, 0
		ui_infield{2}  colPosX[firstFreePosC],   x2ndRow, y-2, 60, yInfield	ui_tooltip stColumns[2]

		ui_pict_button ui_function, stColumns[5], "ui_button_plus", x7thRow, y-2, buttonX, buttonY, BUTTON_UI_C_PLUS ui_tooltip stColumns[5]

		y = y + dy
	endif
return


! ======================================================================
!
! Page 4	Attributes 2D
!
! ======================================================================
"2drepresentation":
	x1			= 5
	xStart		= 10
	yStart		= 40
	dy			= 28
	hRow		= 18
	yInfield	= 19
	fillBoxW	= 100
	fillBoxH	= 22
	penBoxH		= 21
	xHalfLevel	= 222
	penBoxW		= 35
	penBoxH		= 21
	wDescript2	= 150
	
	y = yStart
	
	! --------- 2D settings -----

	ui_style 0, 1
	ui_outfield st2DUI[1], x1, y, xHalfLevel-2*xStart, hRow
	ui_style 0, 0

	ui_infield{3} "bSideView", xHalfLevel+xStart, y-2, xHalfLevel-2*xStart, yInfield,
		7,"", 0, 0,
		0, 0, 0, 0,
		0,	st2DUI[9], 0,
		0,	st2DUI[9], 1

	y = y + dy


	ui_outfield st3DUI[2], x1+5, y, xHalfLevel-xStart-fillBoxW-x1-5-2, hRow
	ui_infield{3} "iDetlevel2D", xHalfLevel-xStart-fillBoxW, y-3, fillBoxW, yInfield,
		8,"", 0, 0,
		0, 0, 0, 0,
		0,	stDetlevel2D[3], 3,
		0,	stDetlevel2D[2], 2,
		0,	stDetlevel2D[1], 1

	ui_pict "ui_2d_pen", xHalfLevel+xStart, y-4, 24, 17, 1													!ui_fill_pen.png
	ui_outfield st2DUI[2], xHalfLevel+xStart+30, y, xHalfLevel-xStart*2-penBoxW*2-34, hRow
	ui_infield "iContPen", 444-xStart-penBoxW*2-2, y-3, penBoxW, hRow 
	ui_infield "gs_cont_pen", 444-xStart-penBoxW, y-4, penBoxW, penBoxH

	y = y + dy - 4

	ui_pict "ui_fill_pen", xHalfLevel+xStart, y, 24, 17, 1													!ui_fill_pen.png
	ui_outfield st2DUI[4], xHalfLevel+xStart+30, y+4, xHalfLevel-xStart*2-penBoxW*2-34, hRow
	ui_infield "iFillPen", 444-xStart-penBoxW*2-2, y+1, penBoxW, hRow 
	ui_infield "gs_fill_pen", 444-xStart-penBoxW, y, penBoxW, penBoxH
	
	y = y + dy
	
	ui_pict "ui_fill_type", xStart, y, 13, 17, 1															!ui_fill_type.png
	ui_outfield st2DUI[3], xStart+20, y+4, xHalfLevel-xStart-42-fillBoxW, hRow
	ui_infield "gs_fill_type", xHalfLevel-xStart-fillBoxW, y, fillBoxW, fillBoxH

	ui_pict "ui_back_pen", xHalfLevel+xStart, y, 24, 17, 1													!ui_back_pen.png
	ui_outfield st2DUI[5], xHalfLevel+xStart+30, y+4, xHalfLevel-xStart*2-penBoxW*2-34,hRow
	ui_infield "iBackPen", 444-xStart-penBoxW*2-2, y+1, penBoxW, hRow 
	ui_infield "gs_back_pen", 444-xStart-penBoxW, y, penBoxW, penBoxH
	y = y + dy + 4


	ui_separator 0, y, 444, y
	y = y + 10

	! --------- 3D -----
	ui_style 0, 1
	ui_outfield  st3DUI[1], x1, y, xHalfLevel, hRow
	ui_style 0, 0
	y = y + dy

	yStart = y

	ui_outfield  st3DUI[2], x1+5, y, xHalfLevel-xStart-fillBoxW-x1-5-2, hRow-1
	ui_infield{3} "iDetlevel3D", xHalfLevel-xStart-fillBoxW, y-3, fillBoxW, yInfield,
		8, "", 0,0,
		0, 0, 0, 0,
		0,	stDetlevel3D[3], DETLEVEL_3D_DETAILED,
		0,	stDetlevel3D[2], DETLEVEL_3D_SIMPLE,
		0,	stDetlevel3D[4], DETLEVEL_3D_BLOCK,
		0,	stDetlevel3D[1], DETLEVEL_3D_NONE

	iFlag = 4 *(iDetlevel3D = DETLEVEL_3D_NONE)
	if iFlag then
		ui_pict "ui_3D_pen_lock", xHalfLevel+xStart, y-4, 27, 17, 1
	else
		ui_pict "ui_3D_pen", xHalfLevel+xStart, y-4, 27, 17, 1
	endif
	ui_outfield  st3DUI[3], xHalfLevel+xStart+30, y, wDescript2-2-penBoxW*2, hRow , iFlag
	ui_infield "iPen3D", 444-xStart-penBoxW*2-2, y-3, penBoxW, hRow 	ui_tooltip  st3DUI[3]
	ui_infield "pen3D", 444-xStart-penBoxW, y-5, penBoxW, penBoxH		ui_tooltip  st3DUI[3]
	y = y + dy

	ui_outfield  st3DUI[5], xHalfLevel+xStart+30, y, wDescript2-2-penBoxW*2, hRow , iFlag
	ui_infield "gs_resol", 444-xStart-penBoxW*2-2, y-3, penBoxW*2+2, hRow 	ui_tooltip  st3DUI[5]

	ui_infield{3} "bShowGrout", xStart, y-2, xHalfLevel-2*xStart, hRow,
		7,"", 0, 0,
		0, 0, 0, 0,
		0,	st3DUI[7], 0,
		0,	st3DUI[7], 1
	y = y + dy
return

! =============================================================================
!
! BO Links
!
! =============================================================================
"info":
	strBIMobject	= `To download more high quality objects please visit us at bimobject.com`
	strWantToGet	= `Want to get more out of your BIM objects?`
	strDownloadApp	= `Download our ArchiCAD app now!`

	uilink_company_youtube	= ""
	if vartype (BO_youtube) = 2 then
		if BO_youtube <> "" then
			uilink_company_youtube	= BO_youtube
			if strsub (BO_youtube, 1, 7) <> "http://" and strsub (BO_youtube, 1, 8) <> "https://" then
				uilink_company_youtube = "http://" + uilink_company_youtube
			endif
		endif
	endif
	
	uilink_prod_descr	= ""
	if vartype (BO_prodaturl) = 2 then
		if BO_prodaturl <> "" then
			uilink_prod_descr		= "http://" + BO_prodaturl
		else
			uilink_prod_descr		= ""
		endif
	endif
	
	uilink_mont_instr	= ""
	if vartype (BO_montins) = 2 then
		if BO_montins <> "" then
			uilink_mont_instr	= BO_montins
			if strsub (BO_montins, 1, 7) <> "http://" then
				uilink_mont_instr	= "http://" + uilink_mont_instr
			endif
		endif
	endif
	
	uilink_techn_descr	= ""
	if vartype (BO_techcert) = 2 then
		if BO_techcert <> "" then
			uilink_techn_descr	= BO_techcert
			if strsub (BO_techcert, 1, 7) <> "http://" then
				uilink_techn_descr	= "http://" + uilink_techn_descr
			endif
		endif
	endif
	
	strButProductDescr	= `Product Description`
	strButInstallInstr	= `Installation Instructions`
	strButTechnDescr	= `Technical Description`
	
	x1	= 1
	x2	= 10
	y1	= 35
	dy1	= 15
	dy2	= 15
	w1	= 240
	w2	= 230
	
	x3	= 282
	w3	= 161
	hBut	= 20
	dy3		= 25
	
	ui_style 0, 0
	
	yy	= y1
	ui_outfield `Product family / group:`, x1, yy, w1, 14
	yy = yy + dy1
	if vartype (BO_prodfam) = 2 then
		ui_outfield BO_prodfam, x2, yy, w2, 14
	endif
	yy = yy + dy1
	if vartype (BO_prodgroup) = 2 then
		ui_outfield BO_prodgroup, x2, yy, w2, 14
	endif
	yy = yy + dy2
	
	! -----------------------------------------------------------------------------
	uiVersionDate = ""
	dateInteger = iVersionNumber[nLastVersion][1]
	if dateInteger > 0 then
		strDate = str(dateInteger, 1, 0)
		stYear	= strsub (strDate, 1, 4)
		stMonth	= strsub (strDate, 5, 2)
		stDay	= strsub (strDate, 7, 2)
		uiVersionDate = stYear + "-" + stMonth + "-" + stDay
	endif
	
	ui_outfield `Object Version:`, x1, yy, w1 - 25, 14
	yy = yy + dy1
	ui_outfield uiVersionDate, x2, yy, w2 - 25, 14
	
	! -----------------------------------------------------------------------------
	
	yy = y1
	if uilink_prod_descr <> "" then
		ui_pict_button ui_link, strButProductDescr, "", x3, yy, w3, 20, 0, uilink_prod_descr
		yy = yy + dy3
	endif
	if uilink_mont_instr <> "" then
		ui_pict_button ui_link, strButInstallInstr, "", x3, yy, w3, 20, 0, uilink_mont_instr
		yy = yy + dy3
	endif
	if uilink_techn_descr <> "" then
		ui_pict_button ui_link, strButTechnDescr, "", x3, yy, w3, 20, 0, uilink_techn_descr
		yy = yy + dy3
	endif
	
	!if uilink_company_youtube <> "" then
	!	ui_pict_button ui_link, "", "youtube_icon", x2 + w2 - 22, y1 + 3 * dy3 - 26, 22, 22, 0, uilink_company_youtube ui_tooltip uilink_company_youtube
	!endif
	
	
	wLogo	= 169
	xLogo	= (444 - wLogo) / 2
	yLogo	= 115
	
	nIcon	= 5
	dIcon	= 18
	wIcon	= 32
	hIcon	= wIcon
	xIcon	= (444 - nIcon * wIcon - (nIcon - 1) * dIcon) / 2
	yIcon	= yLogo + 87
	dx		= wIcon + dIcon
	wDLButton	= nIcon * wIcon + (nIcon - 1) * dIcon
	
	uilink_bimobject	= `http://www.bimobject.com`
	uilink_bo_facebook	= "https://www.facebook.com/BIMobject"
	uilink_bo_youtube	= "https://www.youtube.com/user/BIMobject/videos"
	uilink_bo_twitter	= "https://twitter.com/BIMobject"
	uilink_bo_linkedin	= "https://www.linkedin.com/company/bimobject"
	uilink_bo_app		= "http://info.bimobject.com/archicad-app"
	
	yy = yLogo
	ui_pict "bimobject_logo_info", xLogo, yy, 169, 30
	yy = yy + 36
	
	ui_outfield strWantToGet, 0, yy, 444, 14, 2
	yy = yy + 18
	
	ui_button ui_link, strDownloadApp, xIcon, yy, wDLButton, 16, 0, uilink_bo_app
	yy = yy + 42
	
	xx	= xIcon
	ui_pict_button ui_link, "", "ui_icon_website", xx, yIcon, wIcon, hIcon, 0, uilink_bimobject
	xx	= xx + dx
	ui_pict_button ui_link, "", "ui_icon_facebook", xx, yIcon, wIcon, hIcon, 0, uilink_bo_facebook
	xx	= xx + dx
	ui_pict_button ui_link, "", "ui_icon_youtube", xx, yIcon, wIcon, hIcon, 0, uilink_bo_youtube
	xx	= xx + dx
	ui_pict_button ui_link, "", "ui_icon_twitter", xx, yIcon, wIcon, hIcon, 0, uilink_bo_twitter
	xx	= xx + dx
	ui_pict_button ui_link, "", "ui_icon_linkedin", xx, yIcon, wIcon, hIcon, 0, uilink_bo_linkedin
	
	ui_outfield strBIMobject, 0, 250, 444, 14, 2
return

]]>
</Script_UI>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_VL SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
isFirstRun = 0
n = APPLICATION_QUERY ("parameter_script", "firstoccasion_in_progress", isFirstRun)

! ==============================================================================
! ========== Menu
! ==============================================================================
if GLOB_UI_BUTTON_ID > 0 and GLOB_UI_BUTTON_ID < 10 then
	parameters gs_ui_current_page = GLOB_UI_BUTTON_ID
endif


! ==============================================================================
!
! Contour Profiles
!
! ==============================================================================
if bResetGeom then
	parameters	nPolygonPoint			= nPolygonPoint,
				contourPoints			= contourPoints,
				contourDirection		= contourDirection,
				nWallSide				= nWallSide,
				minXpointNumber			= minXpointNumber,
				maxXpointNumber			= maxXpointNumber,
				iBorderModes			= iBorderModes,
				contourAngles			= contourAngles,
				contourOutPoints		= contourOutPoints,
				baseCubePoints			= baseCubePoints,
				nUniContourPoint		= nUniContourPoint,
				uniContourPoint			= uniContourPoint,
				iBorderUni				= iBorderUni,
				uniAngles				= uniAngles,
				numWD					= numWD,
				nOpeningPolygons		= nOpeningPolygons,
				origOpeningPoligons		= origOpeningPoligons,
				origOpeningStartEnd		= origOpeningStartEnd,
				origOpeningBoundingBox	= origOpeningBoundingBox,
				origOpeningHoles		= origOpeningHoles,
				origOpeningForms		= origOpeningForms,
				origOpeningDirections	= origOpeningDirections,
				openingOrigSize			= openingOrigSize,
				doorAngleBorder			= doorAngleBorder,
				iDoorBorder				= iDoorBorder,
				bHasCornerWindow		= bHasCornerWindow,
				surfaceDir				= surfaceDir,
				bCsorba1				= bCsorba1,
				bCsorba2				= bCsorba2,
				csorbaX1				= csorbaX1,
				csorbaX2				= csorbaX2,
				bOverrideJoint1			= bOverrideJoint1,
				bOverrideJoint2			= bOverrideJoint2,
				iCalcJointType1			= iCalcJointType1,
				iCalcJointType2			= iCalcJointType2,
				cutAngle01				= cutAngle01,
				cutAngle02				= cutAngle02,
				boundingRef				= boundingRef,
				boundingOther			= boundingOther,
				surfaceXmin				= surfaceXmin,
				surfaceXmax				= surfaceXmax,
				surfaceYmin				= surfaceYmin,
				surfaceYmax				= surfaceYmax,
				surfaceX				= surfaceX,
				surfaceY				= surfaceY,
				connWallStartThk		= connWallStartThk,
				connWallStartIangle		= connWallStartIangle,
				connWallStartAngle		= connWallStartAngle,
				connWallEndThk			= connWallEndThk,
				connWallEndIangle		= connWallEndIangle,
				connWallEndAngle		= connWallEndAngle
endif

if bResetBrick then
	parameters	nMagPoint				= nMagPoint,
				rowHeights				= rowHeights,
				rowTypes				= rowTypes,
				nLinder					= nLinder,
				linderCoords			= linderCoords,
				linderTypes				= linderTypes,
				nLinderUsed				= nLinderUsed,
				usedLinderCoords		= usedLinderCoords,
				usedLinderTypes			= usedLinderTypes,
				nLinderGeomUnified		= nLinderGeomUnified,
				unifiedGeomLinderCoords	= unifiedGeomLinderCoords,
				nVerticalGlue			= nVerticalGlue,
				verticalGlue			= verticalGlue,
				edgeSection				= edgeSection,
				nEdgePoint				= nEdgePoint,
				edgeStatus				= edgeStatus,
				nColumnDatas			= nColumnDatas,
				columnDatas				= columnDatas,
				rowIndex				= rowIndex,
				nBrick					= nBrick,
				brickCoord				= brickCoord,
				brickDef				= brickDef,
				brickCut				= brickCut,
				nBrickCutter			= nBrickCutter,
				brickCutters			= brickCutters,
				brickCuttersType		= brickCuttersType,
				nRowCutters				= nRowCutters,
				rowCutters				= rowCutters
endif
	
	
if not(bDefaultElem) then
	parameters	bModifiedByAPI	= 0,
				bResetBrick		= bResetBrick
				!bResetGeom		= bResetGeom
endif


! ==============================================================================
!
! Parameters
!
! ==============================================================================
! ------------------------------------------------------------------------------
! Language
! ------------------------------------------------------------------------------
values "iLang" \
	LANG_DE
!!				LANG_AT,
!!				LANG_BE,
!!				LANG_BA,
!!				LANG_BG,
!!				LANG_CN,
!!				LANG_HR,
!!				LANG_CZ,
!!				LANG_DK,
!!				LANG_FI,
!!				LANG_FR,
!!				LANG_DE,
!!				LANG_HU,
!!				LANG_IT,
!!				LANG_XK,
!!!!				LANG_MX,
!!				LANG_NL,
!!				LANG_NO,
!!				LANG_PL,
!!				LANG_RO,
!!				LANG_RU,
!!				LANG_RS,
!!				LANG_SK,
!!				LANG_SI,
!!				LANG_ES,
!!				LANG_SE,
!!				LANG_CH,
!!				LANG_TR,
!!				LANG_UK
!!!!				LANG_US,



! ------------------------------------------------------------------------------
! Product
! ------------------------------------------------------------------------------
if bValidFamily then
	values "iFamily" avaFamilys
else
	end	!TODO ez itt lehet hogy nem jó
endif
values "iProductType"	avaProductTypes
values "baseMortarThk"	range [0.01, 0.02]
values "mortarThk"		range [0.001, 0.003]
for i = 1 to vardim1(brickThicknesses)
	put i
next i
if nsp then
	values "iThickness"	get(nsp)
endif

if datProdDisableFlipRow[idxFamily] then
	lock "startRow"
endif

if datProdDisableBrickDir[idxFamily] then
	lock "brickDir"
endif

values "iStartBrickHeight" 0,1,2,3
if disableStartBrickHeight then
	lock "iStartBrickHeight", "bAutoStartBrick"
endif
if bAutoStartBrick then
	lock "iStartBrickHeight"
endif

if elemWindowIdx then
	values "iWindowBrick" \
		BRICK_NONE,
		elemWindowIdx
endif

! ------------------------------------------------------------------------------
! Beam Type
! ------------------------------------------------------------------------------
if nBeamParameters then
	values "iBeamFamily" beamParametersArray
else
	values "iBeamFamily" BEAM_FAMILY_NONE!, BEAM_FAMILY_CUSTOM
!!	iBeamFamily	= BEAM_FAMILY_NONE
!!	parameters iBeamFamily = iBeamFamily
endif
parameters iPrevBeamFamily = iBeamFamily

minBeamHeight	= 0.06
minBeamOverlap	= 0.1
values "defBeamHeight"	range [minBeamHeight, ]
values "defBeamOverlap"	range [minBeamOverlap, ]
for i = 1 to nOpeningPolygons
	if customBeamHeights[i] < minBeamHeight then
		customBeamHeights[i] = minBeamHeight
		parameters customBeamHeights[i] = customBeamHeights[i]
	endif

	if customBeamOverlaps[i] < minBeamOverlap then
		customBeamOverlaps[i] = minBeamOverlap
		parameters customBeamOverlaps[i] = customBeamOverlaps[i]
	endif
next i


! ------------------------------------------------------------------------------
! Joint Angles
! ------------------------------------------------------------------------------
if bDefaultElem then
	hideparameter	"tConnections"
	lock			"tConnections"
endif

values "jointAngle1"	range (5, 175)
values "jointAngle2"	range (5, 175)


! ----- Side 1 -----
for i = 1 to nJointTypes
	put (i-1)*dAng
next i
values "jUiAngle1" get(nsp)
values "iJointType1" jointTypes

if not(bJointAngle1) then
	hideparameter	"jointAngle1"
	lock			"jointAngle1"
endif

if bOverrideJoint1 then
	hideparameter	"jointAngle1", "bJointAngle1"
	lock			"jointAngle1", "bJointAngle1"
endif

if	iJointType1 <> JOINT_SIDE_CORNER_1		&\
	iJointType1 <> JOINT_SIDE_CORNER_2		&\
	iJointType1 <> JOINT_SIDE_CORNER_T_1	&\
	iJointType1 <> JOINT_SIDE_CORNER_T_2	\
then
	lock			"bCustomCsorba1", "csorbaW1"
	hideparameter	"bCustomCsorba1", "csorbaW1"
else
	if not(bCustomCsorba1) then
		lock			"csorbaW1"
		hideparameter	"csorbaW1"
	endif
endif
values "csorbaW1" range[minCsorbaWidth, maxCsorbaWidth]

if GLOB_MODPAR_NAME = "jUiAngle1" then
	iJointType1 = jointTypes[1]
	for i = 2 to nJointTypes
		if abs(jUiAngle1 - (i-1)*dAng) < EPS then
			iJointType1 = jointTypes[i]
			i			= nJointTypes
		endif
	next i
	parameters iJointType1 = iJointType1
else
	ang = 0
	for i = 1 to nJointTypes
		if jointTypes[i] = iJointType1 then
			ang = (i-1)*dAng
			i	= nJointTypes
		endif
	next i
	parameters jUiAngle1 = ang
endif


! ----- Side 2 -----
for i = 1 to nJointTypes
	put (i-1)*dAng
next i
values "jUiAngle2" get(nsp)
values "iJointType2" jointTypes

if not(bJointAngle2) then
	hideparameter	"jointAngle2"
	lock			"jointAngle2"
endif

if bOverrideJoint2 then
	hideparameter	"jointAngle2", "bJointAngle2"
	lock			"jointAngle2", "bJointAngle2"
endif

if	iJointType2 <> JOINT_SIDE_CORNER_1		&\
	iJointType2 <> JOINT_SIDE_CORNER_2		&\
	iJointType2 <> JOINT_SIDE_CORNER_T_1	&\
	iJointType2 <> JOINT_SIDE_CORNER_T_2	\
then
	lock			"bCustomCsorba2", "csorbaW2"
	hideparameter	"bCustomCsorba2", "csorbaW2"
else
	if not(bCustomCsorba2) then
		lock			"csorbaW2"
		hideparameter	"csorbaW2"
	endif
endif
values "csorbaW2" range[minCsorbaWidth, maxCsorbaWidth]

if GLOB_MODPAR_NAME = "jUiAngle2" then
	iJointType2 = jointTypes[1]
	for i = 2 to nJointTypes
		if abs(jUiAngle2 - (i-1)*dAng) < EPS then
			iJointType2 = jointTypes[i]
			i			= nJointTypes
		endif
	next i
	parameters iJointType2 = iJointType2
else
	ang = 0
	for i = 1 to nJointTypes
		if jointTypes[i] = iJointType2 then
			ang = (i-1)*dAng
			i	= nJointTypes
		endif
	next i
	parameters jUiAngle2 = ang
endif



! ==============================================================================
! Ui and controller params
! ==============================================================================
! ----- T wall connections -----
for i=1 to vardim1(tConnWallDir)
	if tConnWallDir[i] > brickThk/2 then parameters tConnWallDir[i] = brickThk
	if tConnWallDir[i] < brickThk/2 then parameters tConnWallDir[i] = 0
next i
values "tConnWallDir" 0, brickThk
values "tConnWallPos" range [surfaceXmin, surfaceXmax], tDefPosOut
for i = 1 to vardim1(tConnWallAngle)
	if tConnWallAngle[i] < 5 then parameters tConnWallAngle[i] = 5
	if tConnWallAngle[i] > 175 then parameters tConnWallAngle[i] = 175
next i


if isFirstRun then
	if GLOB_UI_BUTTON_ID = BUTTON_UI_T_START	then nUiStart_T = 1
	if GLOB_UI_BUTTON_ID = BUTTON_UI_T_UP		then nUiStart_T = max(nUiStart_T-1, 1)
	if GLOB_UI_BUTTON_ID = BUTTON_UI_T_DOWN		then nUiStart_T = min(nUiStart_T+1, nTwallConn -(nUiRows_T-1))
	if GLOB_UI_BUTTON_ID = BUTTON_UI_T_END		then nUiStart_T = nTwallConn -(nUiRows_T-1)

	nUiStart_T = max (1, nUiStart_T)

	parameters nUiStart_T = nUiStart_T

	if GLOB_UI_BUTTON_ID = BUTTON_UI_T_PLUS then
		parameters tConnWallPos[firstFreePosT] = tDefPos
	endif

	for i = 1 to nConnTParam
		if GLOB_UI_BUTTON_ID = BUTTON_UI_T_MINUS + i then
			dim _tConnWallDir[], _tConnWallPos[], _tConnWallThk[], _tConnWallHmin[], _tConnWallHmax[], _tConnWallAngle[]

			idx = 0
			for j = 1 to nConnTParam
				if i <> j then
					idx						= idx + 1
					_tConnWallDir[idx]		= tConnWallDir[j]
					_tConnWallPos[idx]		= tConnWallPos[j]
					_tConnWallThk[idx]		= tConnWallThk[j]
					_tConnWallHmin[idx]		= tConnWallHmin[j]
					_tConnWallHmax[idx]		= tConnWallHmax[j]
					_tConnWallAngle[idx]	= tConnWallAngle[j]
				endif
			next j

			tConnWallDir	= _tConnWallDir
			tConnWallPos	= _tConnWallPos
			tConnWallThk	= _tConnWallThk
			tConnWallHmin	= _tConnWallHmin
			tConnWallHmax	= _tConnWallHmax
			tConnWallAngle	= _tConnWallAngle

			parameters	tConnWallDir	= tConnWallDir,
						tConnWallPos	= tConnWallPos,
						tConnWallThk	= tConnWallThk,
						tConnWallHmin	= tConnWallHmin,
						tConnWallHmax	= tConnWallHmax,
						tConnWallAngle	= tConnWallAngle
		endif
	next i
endif


! ----- Columns -----
values "colPosX" range [surfaceXmin, surfaceXmax], cDefPosOut

if isFirstRun then
	if GLOB_UI_BUTTON_ID = BUTTON_UI_C_START	then nUiStart_C = 1
	if GLOB_UI_BUTTON_ID = BUTTON_UI_C_UP		then nUiStart_C = max(nUiStart_C-1, 1)
	if GLOB_UI_BUTTON_ID = BUTTON_UI_C_DOWN		then nUiStart_C = min(nUiStart_C+1, nColConn - (nUiRows_C-1))
	if GLOB_UI_BUTTON_ID = BUTTON_UI_C_END		then nUiStart_C = nColConn - (nUiRows_C-1)

	nUiStart_C = max (1, nUiStart_C)

	parameters nUiStart_C = nUiStart_C

	if GLOB_UI_BUTTON_ID = BUTTON_UI_C_PLUS then
		parameters colPosX[firstFreePosC] = cDefPos
	endif

	for i = 1 to nColumnParam
		if GLOB_UI_BUTTON_ID = BUTTON_UI_C_MINUS + i then
			dim _colPosX[]

			idx = 0
			for j = 1 to nColumnParam
				if i <> j then
					idx				= idx + 1
					_colPosX[idx]	= colPosX[j]
				endif
			next j

			colPosX = _colPosX

			parameters	colPosX = colPosX
		endif
	next i
endif



! ==============================================================================
! Settings
! ==============================================================================
!if GLOB_CONTEXT = 1 | GLOB_CONTEXT = 5 then
	if elemColumnIdx > 0 then
		values "gs_ui_current_page" 1,2,3,4,5,6
	else
		values "gs_ui_current_page" 1,2,3,4,5
	endif

	! ------------------------------------------------------------------------------
	! 2D Pens
	! ------------------------------------------------------------------------------
	! ----- 2D Detlevel -----
	values "gs_detlevel_2D" stDetlevel2D[3], stDetlevel2D[1]
	values "iDetlevel2D" DETLEVEL_2D_DETAILED, DETLEVEL_2D_BLOCK
	if GLOB_MODPAR_NAME = "gs_detlevel_2D" then
		iDetlevel2D = DETLEVEL_2D_BLOCK
		for i = 2 to vardim1(stDetlevel2D)
			if gs_detlevel_2D = stDetlevel2D[i] then	iDetlevel2D = i
		next i
		parameters iDetlevel2D = iDetlevel2D
	else
		iDetlevel2D = max(min(iDetlevel2D,3),1)
		parameters gs_detlevel_2D= stDetlevel2D[iDetlevel2D]
	endif

	! -------Contour--------------------
	if GLOB_MODPAR_NAME = "iContPen" then
		iContPen	= min(max(iContPen, 1), 255)
		gs_cont_pen	= iContPen
		parameters iContPen = iContPen, gs_cont_pen = gs_cont_pen
	else
		gs_cont_pen	= max(gs_cont_pen, 1)
		iContPen	= gs_cont_pen
		parameters iContPen = iContPen, gs_cont_pen = gs_cont_pen
	endif
	
	! -------Fill Pen--------------------
	if GLOB_MODPAR_NAME = "iFillPen" then
		iFillPen	= min(max(iFillPen, 1), 255)
		gs_fill_pen	= iFillPen
		parameters iFillPen = iFillPen, gs_fill_pen = gs_fill_pen
	else
		gs_fill_pen	= max(gs_fill_pen, 1)
		iFillPen	= gs_fill_pen
		parameters iFillPen = iFillPen, gs_fill_pen = gs_fill_pen
	endif
	
	! -------Fill Back Pen--------------------
	if GLOB_MODPAR_NAME = "iBackPen" then
		iBackPen	= min(max(iBackPen, -1), 255)
		gs_back_pen	= iBackPen
		parameters iBackPen = iBackPen, gs_back_pen = gs_back_pen
	else
		gs_back_pen	= max(gs_back_pen, -1)
		iBackPen	= gs_back_pen
		parameters iBackPen = iBackPen, gs_back_pen = gs_back_pen
	endif
	
	!!! -------Cut Pen--------------------
	!!if GLOB_MODPAR_NAME = "iCutPen" then
	!!	iCutPen		= min(max(iCutPen, 1), 255)
	!!	gs_cut_pen	= iCutPen
	!!	parameters iCutPen = iCutPen, gs_cut_pen = gs_cut_pen
	!!else
	!!	gs_cut_pen	= max(gs_cut_pen, 1)
	!!	iCutPen		= gs_cut_pen
	!!	parameters iCutPen = iCutPen, gs_cut_pen = gs_cut_pen
	!!endif
	!!
	!!! -------Overhead Pen--------------------
	!!if GLOB_MODPAR_NAME = "iOverHeadPen" then
	!!	iOverHeadPen	= min(max(iOverHeadPen, 1), 255)
	!!	AC_overhead_pen	= iOverHeadPen
	!!	parameters iOverHeadPen = iOverHeadPen, AC_overhead_pen = AC_overhead_pen
	!!else
	!!	AC_overhead_pen	= max(AC_overhead_pen, 1)
	!!	iOverHeadPen	= AC_overhead_pen
	!!	parameters iOverHeadPen = iOverHeadPen, AC_overhead_pen = AC_overhead_pen
	!!endif
	!!
	!!! ------------------------------------------------------------------------------
	!!! 2D Display Options
	!!! ------------------------------------------------------------------------------
	!!if GLOB_MODPAR_NAME = "gs_symb_display_option" | AC_symb_display_option = 0 then
	!!	AC_symb_display_option = DISPLAY_PROJECTED
	!!	if gs_symb_display_option = stDisplayOptions[2] then AC_symb_display_option = DISPLAY_OVERHEAD_PROJ
	!!	if gs_symb_display_option = stDisplayOptions[3] then AC_symb_display_option = DISPLAY_SYMBOLIC
	!!	if gs_symb_display_option = stDisplayOptions[4] then AC_symb_display_option = DISPLAY_OUTLINES
	!!	if gs_symb_display_option = stDisplayOptions[5] then AC_symb_display_option = DISPLAY_OVERHEAD_ALL
	!!	parameters AC_symb_display_option = AC_symb_display_option
	!!else
	!!	gs_symb_display_option = stDisplayOptions[min(max(1, AC_symb_display_option), vardim1(stDisplayOptions))]
	!!	parameters gs_symb_display_option = gs_symb_display_option
	!!endif
	!!
	!!if GLOB_MODPAR_NAME = "gs_symb_show_projection_to" | AC_symb_show_projection_to = 0 then
	!!	AC_symb_show_projection_to = PROJECTION_FLOOR_PLAN_RANGE
	!!	if gs_symb_show_projection_to = stProjectionTypes[2] then AC_symb_show_projection_to = PROJECTION_DISPLAY_LIMIT
	!!	if gs_symb_show_projection_to = stProjectionTypes[3] then AC_symb_show_projection_to = PROJECTION_ENTIRE_ELEMENT
	!!	parameters AC_symb_show_projection_to = AC_symb_show_projection_to
	!!else
	!!	gs_symb_show_projection_to = stProjectionTypes[min(max(1, AC_symb_show_projection_to), vardim1(stProjectionTypes))]
	!!	parameters gs_symb_show_projection_to = gs_symb_show_projection_to
	!!endif
	!!
	!!values "gs_symb_display_option" stDisplayOptions
	!!values "gs_symb_show_projection_to" stProjectionTypes
	!!
	!!if AC_symb_display_option = DISPLAY_SYMBOLIC | AC_symb_display_option = DISPLAY_OVERHEAD_ALL then
	!!	hideparameter	"gs_use_3D_view_attributes"
	!!	lock			"gs_use_3D_view_attributes"
	!!endif
	!!
	!!if AC_symb_display_option <> DISPLAY_SYMBOLIC then
	!!	hideparameter	"gs_detlevel_2D",
	!!					"iDetlevel2D"
	!!
	!!	lock			"gs_detlevel_2D",
	!!					"iDetlevel2D"
	!!endif
	!!
	!!if gs_use_3D_view_attributes then
	!!	hideparameter	"gs_cont_pen", "iContPen"
	!!	lock			"gs_cont_pen", "iContPen"
	!!endif
	!!
	!!if not(AC_symb_display_option = DISPLAY_PROJECTED | AC_symb_display_option = DISPLAY_OVERHEAD_PROJ) then
	!!	hideparameter	"gs_sect_pen",
	!!					"gs_cut_fill_type",
	!!					"gs_cut_fill_fg",
	!!					"gs_cut_fill_bg"
	!!endif
	!!
	!!if AC_symb_display_option = DISPLAY_SYMBOLIC | AC_symb_display_option = DISPLAY_OUTLINES | AC_symb_display_option = DISPLAY_OVERHEAD_ALL then
	!!	hideparameter	"gs_symb_show_projection_to"
	!!	lock			"gs_symb_show_projection_to"
	!!
	!!	hideparameter	"AC_cut_linetype", "gs_cut_pen", "iCutPen"
	!!	lock			"AC_cut_linetype", "gs_cut_pen", "iCutPen"
	!!endif
	!!
	!!if AC_symb_display_option = DISPLAY_PROJECTED | AC_symb_display_option = DISPLAY_SYMBOLIC | AC_symb_display_option = DISPLAY_OUTLINES then
	!!	hideparameter	"AC_overhead_linetype", "AC_overhead_pen", "iOverHeadPen"
	!!	lock			"AC_overhead_linetype", "AC_overhead_pen", "iOverHeadPen"
	!!endif
	!!
	!!if AC_symb_display_option = DISPLAY_OVERHEAD_ALL then
	!!	hideparameter	"gs_fill_type", "gs_fill_pen", "gs_back_pen", "gs_cont_pen", "iContPen", "gs_cont_line", "iFillPen", "iBackPen"
	!!	lock			"gs_fill_type", "gs_fill_pen", "gs_back_pen", "gs_cont_pen", "iContPen", "gs_cont_line", "iFillPen", "iBackPen"
	!!endif


	! ------------------------------------------------------------------------------
	! 3D
	! ------------------------------------------------------------------------------
	! ----- 3D Detlevel -----
	values "gs_detlevel_3D" stDetlevel3D[3], stDetlevel3D[2], stDetlevel3D[4], stDetlevel3D[1]
	values "iDetlevel3D" DETLEVEL_3D_DETAILED, DETLEVEL_3D_SIMPLE, DETLEVEL_3D_BLOCK, DETLEVEL_3D_NONE
	if GLOB_MODPAR_NAME = "gs_detlevel_3D" then
		iDetlevel3D = DETLEVEL_3D_NONE
		for i = 2 to vardim1(stDetlevel3D)
			if gs_detlevel_3D = stDetlevel3D[i] then	iDetlevel3D = i-1
		next i
		parameters iDetlevel3D = iDetlevel3D
	else
		iDetlevel3D = max(min(iDetlevel3D,3),0)
		parameters gs_detlevel_3D= stDetlevel3D[iDetlevel3D+1]
	endif

	if GLOB_MODPAR_NAME = "iPen3D" then
		iPen3D 	= min(max(iPen3D, 1), 255)
		pen3D	= iPen3D
		parameters iPen3D = iPen3D, pen3D = pen3D
	else
		pen3D	= max(pen3D, 1)
		iPen3D	= pen3D
		parameters iPen3D = iPen3D, pen3D = pen3D
	endif

	values "gs_resol" range [12, ]

	if iDetlevel3D = DETLEVEL_3D_NONE then
		hideparameter	"pen3D",
						"iPen3D",
						"gs_resol",
						"bShowGrout"

		lock			"pen3D",
						"iPen3D",
						"gs_resol",
						"bShowGrout"
	endif

	if iDetlevel3D = DETLEVEL_3D_WIRE then
		hideparameter	"bShowGrout"
		lock			"bShowGrout"
	endif

!endif


! ==============================================================================
! Bounding Box
! ==============================================================================
parameters A		= surfaceXmax-surfaceXmin
parameters B		= brickThk
parameters ZZYZX	= surfaceYmax-surfaceYmin
lock "A", "B", "ZZYZX"
parameters iVersionNumber = iVersionNumber


! ==============================================================================
! Levels
! ==============================================================================
parameters ac_toplevel		= surfaceYmax
parameters ac_bottomlevel	= surfaceYmin

! ==============================================================================
! ========== BO-parameters
! ==============================================================================
actID		= 0
prodatURL	= ""
if iFamily = BRICK_DE_KSQ_12_18_DM then
	actID		= 1
	prodatURL	= "bimobject.com/ks-quadro/product/ks_quadro_12_1-8_dm"
endif
if iFamily = BRICK_DE_KSQ_16_18_DM then
	actID		= 2
	prodatURL	= "bimobject.com/ks-quadro/product/ks_quadro_16_1-8_dm"
endif
if iFamily = BRICK_DE_KSQ_20_18_DM then
	actID		= 3
	prodatURL	= "bimobject.com/ks-quadro/product/ks_quadro_20_1-8_dm"
endif
if iFamily = BRICK_DE_KSQ_20_20_DM then
	actID		= 4
	prodatURL	= "bimobject.com/ks-quadro/product/ks_quadro_20_2-0_dm"
endif
if iFamily = BRICK_DE_KSQ_20_22_DM then
	actID		= 5
	prodatURL	= "bimobject.com/ks-quadro/product/ks_quadro_20_2-2_dm"
endif
if iFamily = BRICK_DE_KSQE_12_18_DM then
	actID		= 6
	prodatURL	= "bimobject.com/ks-quadro/product/ks_quadro_e_12_1-8_dm"
endif
if iFamily = BRICK_DE_KSQE_20_18_DM then
	actID		= 7
	prodatURL	= "bimobject.com/ks-quadro/product/ks_quadro_e_20_1-8_dm"
endif
if iFamily = BRICK_DE_KSQE_12_20_DM then
	actID		= 8
	prodatURL	= "bimobject.com/ks-quadro/product/ks_quadro_e_12_2-0_dm"
endif
if iFamily = BRICK_DE_KSQE_20_20_DM then
	actID		= 9
	prodatURL	= "bimobject.com/ks-quadro/product/ks_quadro_e_20_2-0_dm"
endif

maxActID	= 9

for w = vardim2 (sSaved_BO_params) + 1 to maxActID
	for q = 1 to vardim1 (sSaved_BO_params)
		parameters sSaved_BO_params[q][w] = ""
	next q
	for q = 1 to vardim1 (iSaved_BO_params)
		parameters iSaved_BO_params[q][w] = 0
	next q
	for q = 1 to vardim1 (rSaved_BO_params)
		parameters rSaved_BO_params[q][w] = 0
	next q
next w

!!! --- only temporarily !!! ------------------
!!if	GLOB_MODPAR_NAME = "iFamily" then
!!	parameters BO_prodaturl = prodatURL
!!!	if glob_context = 1 then
!!			parameters BO_ediNum	= -1
!!			parameters BO_productguid	= ""
!!!	endif
!!endif
!!! -------------------------------------------

if iPrevFamily <> iFamily and vardim1 (sSaved_BO_params) > 1 then			! or not(BO_productguid	= sSaved_BO_params[ 9][actID]) then
	BO_prodinfo		= sSaved_BO_params[ 1][actID]
	BO_prodsku		= sSaved_BO_params[ 2][actID]
	BO_Manufac		= sSaved_BO_params[ 3][actID]
	BO_prodfam		= sSaved_BO_params[ 4][actID]
	BO_prodgroup	= sSaved_BO_params[ 5][actID]
	BO_mancont		= sSaved_BO_params[ 6][actID]
	BO_designcont	= sSaved_BO_params[ 7][actID]
	BO_publisdat	= sSaved_BO_params[ 8][actID]
	BO_edinum 		= iSaved_BO_params[ 1][actID]
	BO_width		= rSaved_BO_params[ 1][actID]
	BO_height		= rSaved_BO_params[ 2][actID]
	BO_depth		= rSaved_BO_params[ 3][actID]
	BO_weight		= rSaved_BO_params[ 4][actID]
	BO_productguid	= sSaved_BO_params[ 9][actID]

	BO_boqrurl		= sSaved_BO_params[10][actID]
	BO_prodaturl	= sSaved_BO_params[11][actID]
	BO_montins		= sSaved_BO_params[12][actID]
	BO_prodcert		= sSaved_BO_params[13][actID]
	BO_techcert		= sSaved_BO_params[14][actID]
	BO_youtube		= sSaved_BO_params[15][actID]
	BO_ean			= sSaved_BO_params[16][actID]

	BO_mainmat		= sSaved_BO_params[17][actID]
	BO_secmat		= sSaved_BO_params[18][actID]

	BO_bocat				= sSaved_BO_params[19][actID]
	BO_ifcclas				= sSaved_BO_params[20][actID]
	BO_unspc				= sSaved_BO_params[21][actID]
	BO_uniclass_1_4_code	= sSaved_BO_params[22][actID]
	BO_uniclass_1_4_desc	= sSaved_BO_params[23][actID]
	BO_uniclass_2_0_code	= sSaved_BO_params[24][actID]
	BO_uniclass_2_0_desc	= sSaved_BO_params[25][actID]
	BO_uniclass2015_code	= sSaved_BO_params[26][actID]
	BO_uniclass2015_desc	= sSaved_BO_params[27][actID]
	BO_nbs_ref				= sSaved_BO_params[28][actID]
	BO_nbs_desc				= sSaved_BO_params[29][actID]
	BO_omniclass_code		= sSaved_BO_params[30][actID]
	BO_omniclass_name		= sSaved_BO_params[31][actID]
	BO_masterformat2014_code	= sSaved_BO_params[32][actID]
	BO_masterformat2014_name	= sSaved_BO_params[33][actID]
	BO_uniformat2_code			= sSaved_BO_params[34][actID]
	BO_uniformat2_name			= sSaved_BO_params[35][actID]
	BO_cobie_type_cat		= sSaved_BO_params[36][actID]

	BO_europe		= sSaved_BO_params[37][actID]
	BO_northamerica	= sSaved_BO_params[38][actID]
	BO_southamerica	= sSaved_BO_params[39][actID]
	BO_middleeast	= sSaved_BO_params[40][actID]
	BO_asia			= sSaved_BO_params[41][actID]
	BO_oceania		= sSaved_BO_params[42][actID]
	BO_africa		= sSaved_BO_params[43][actID]
	BO_antarctica	= sSaved_BO_params[44][actID]
	
	parameters	BO_prodinfo		= BO_prodinfo,
				BO_prodsku		= BO_prodsku,
				BO_Manufac		= BO_Manufac,
				BO_prodfam		= BO_prodfam,
				BO_prodgroup	= BO_prodgroup,
				BO_mancont		= BO_mancont,
				BO_designcont	= BO_designcont,
				BO_publisdat	= BO_publisdat,
				BO_edinum 		= BO_edinum,
				BO_width		= BO_width,
				BO_height		= BO_height,
				BO_depth		= BO_depth,
				BO_weight		= BO_weight,
				BO_productguid	= BO_productguid

	parameters	BO_boqrurl		= BO_boqrurl,
				BO_prodaturl	= BO_prodaturl,
				BO_montins		= BO_montins,
				BO_prodcert		= BO_prodcert,
				BO_techcert		= BO_techcert,
				BO_youtube		= BO_youtube,
				BO_ean			= BO_ean

	parameters	BO_mainmat		= BO_mainmat,
				BO_secmat		= BO_secmat

	parameters	BO_bocat				= BO_bocat,
				BO_ifcclas				= BO_ifcclas,
				BO_unspc				= BO_unspc,
				BO_uniclass_1_4_code	= BO_uniclass_1_4_code,
				BO_uniclass_1_4_desc	= BO_uniclass_1_4_desc,
				BO_uniclass_2_0_code	= BO_uniclass_2_0_code,
				BO_uniclass_2_0_desc	= BO_uniclass_2_0_desc,
				BO_uniclass2015_code	= BO_uniclass2015_code,
				BO_uniclass2015_desc	= BO_uniclass2015_desc,
				BO_nbs_ref				= BO_nbs_ref,
				BO_nbs_desc				= BO_nbs_desc,
				BO_omniclass_code		= BO_omniclass_code,
				BO_omniclass_name		= BO_omniclass_name,
				BO_masterformat2014_code	= BO_masterformat2014_code,
				BO_masterformat2014_name	= BO_masterformat2014_name,
				BO_uniformat2_code			= BO_uniformat2_code,
				BO_uniformat2_name			= BO_uniformat2_name,
				BO_cobie_type_cat		= BO_cobie_type_cat

	parameters	BO_europe		= BO_europe,
				BO_northamerica	= BO_northamerica,
				BO_southamerica	= BO_southamerica,
				BO_middleeast	= BO_middleeast,
				BO_asia			= BO_asia,
				BO_oceania		= BO_oceania,
				BO_africa		= BO_africa,
				BO_antarctica	= BO_antarctica

	! -----------------------------------------
	parameters	iPrevFamily	= iFamily
else
	if iSaved_BO_params[ 1][actID] < BO_edinum then idLastSavedBO = 0		! change control (after the BO-update)
endif

if idLastSavedBO < 0.5 and actID > 0 then
	sSaved_BO_params[ 1][actID]	= BO_prodinfo
	sSaved_BO_params[ 2][actID]	= BO_prodsku
	sSaved_BO_params[ 3][actID]	= BO_Manufac
	sSaved_BO_params[ 4][actID]	= BO_prodfam
	sSaved_BO_params[ 5][actID]	= BO_prodgroup
	sSaved_BO_params[ 6][actID]	= BO_mancont
	sSaved_BO_params[ 7][actID]	= BO_designcont
	sSaved_BO_params[ 8][actID]	= BO_publisdat
	iSaved_BO_params[ 1][actID]	= BO_edinum
	rSaved_BO_params[ 1][actID]	= BO_width
	rSaved_BO_params[ 2][actID]	= BO_height
	rSaved_BO_params[ 3][actID]	= BO_depth
	rSaved_BO_params[ 4][actID]	= BO_weight
	sSaved_BO_params[ 9][actID]	= BO_productguid

	sSaved_BO_params[10][actID]	= BO_boqrurl
	sSaved_BO_params[11][actID]	= BO_prodaturl
	sSaved_BO_params[12][actID]	= BO_montins
	sSaved_BO_params[13][actID]	= BO_prodcert
	sSaved_BO_params[14][actID]	= BO_techcert
	sSaved_BO_params[15][actID]	= BO_youtube
	sSaved_BO_params[16][actID]	= BO_ean

	sSaved_BO_params[17][actID]	= BO_mainmat
	sSaved_BO_params[18][actID]	= BO_secmat

	sSaved_BO_params[37][actID]	= BO_europe
	sSaved_BO_params[38][actID]	= BO_northamerica
	sSaved_BO_params[39][actID]	= BO_southamerica
	sSaved_BO_params[40][actID]	= BO_middleeast
	sSaved_BO_params[41][actID]	= BO_asia
	sSaved_BO_params[42][actID]	= BO_oceania
	sSaved_BO_params[43][actID]	= BO_africa
	sSaved_BO_params[44][actID]	= BO_antarctica

	sSaved_BO_params[19][actID]	= BO_bocat
	sSaved_BO_params[20][actID]	= BO_ifcclas
	sSaved_BO_params[21][actID]	= BO_unspc
	sSaved_BO_params[22][actID]	= BO_uniclass_1_4_code
	sSaved_BO_params[23][actID]	= BO_uniclass_1_4_desc
	sSaved_BO_params[24][actID]	= BO_uniclass_2_0_code
	sSaved_BO_params[25][actID]	= BO_uniclass_2_0_desc
	sSaved_BO_params[26][actID]	= BO_uniclass2015_code
	sSaved_BO_params[27][actID]	= BO_uniclass2015_desc
	sSaved_BO_params[28][actID]	= BO_nbs_ref
	sSaved_BO_params[29][actID]	= BO_nbs_desc
	sSaved_BO_params[30][actID]	= BO_omniclass_code
	sSaved_BO_params[31][actID]	= BO_omniclass_name
	sSaved_BO_params[32][actID]	= BO_masterformat2014_code
	sSaved_BO_params[33][actID]	= BO_masterformat2014_name
	sSaved_BO_params[34][actID]	= BO_uniformat2_code
	sSaved_BO_params[35][actID]	= BO_uniformat2_name
	sSaved_BO_params[36][actID]	= BO_cobie_type_cat

	parameters	sSaved_BO_params	= sSaved_BO_params,
				iSaved_BO_params	= iSaved_BO_params,
				rSaved_BO_params	= rSaved_BO_params

	! -----------------------------------------
	parameters	idLastSavedBO	= actID
endif

]]>
</Script_VL>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Comment SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Comment>

<ParamSection SectVersion="22" SectionFlags="0" SubIdent="0">
	<ParamSectHeader>
		<Version>22</Version>
		<AutoHotspots>no</AutoHotspots>
		<StatBits>
			<STBit_UIDefault/>
			<STBit_FixSize/>
			<STBit_UIUseHierarchicalPages/>
		</StatBits>
		<WDLeftFrame>0</WDLeftFrame>
		<WDRightFrame>0</WDRightFrame>
		<WDTopFrame>0</WDTopFrame>
		<WDBotFrame>0</WDBotFrame>
		<LayFlags>43263</LayFlags>
		<WDMirrorThickness>0</WDMirrorThickness>
		<WDWallInset>0</WDWallInset>
		<SymbolColor>0</SymbolColor>
	</ParamSectHeader>
	<Parameters>
		<Length Name="A">
			<Description><![CDATA["Length"]]></Description>
			<Value>4.5</Value>
		</Length>
		<Length Name="B">
			<Description><![CDATA["Thickness"]]></Description>
			<Value>0.175</Value>
		</Length>
		<Length Name="ZZYZX">
			<Description><![CDATA["Height"]]></Description>
			<Value>2.7</Value>
		</Length>
		<Boolean Name="AC_show2DHotspotsIn3D">
			<Description><![CDATA["Show 2D Hotspots in 3D"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="ac_bottomlevel">
			<Description><![CDATA["Bottom Level"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="ac_toplevel">
			<Description><![CDATA["Top Level"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2.7</Value>
		</Length>
		<Integer Name="iLang">
			<Description><![CDATA["Language"]]></Description>
			<Value>1</Value>
		</Integer>

		<!-- iFamily: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Integer Name="iFamily">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>10000</Value>
		</Integer>
		<Integer Name="iThickness">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Integer Name="iProductType">
			<Description><![CDATA["Block Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>10003</Value>
		</Integer>
		<Boolean Name="bShowEdit">
			<Description><![CDATA["Show Editing Hotspots"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bUseBottomContour">
			<Description><![CDATA["Use Bottom Contour"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bUseTopContour">
			<Description><![CDATA["Use Top Contour"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bTopWallConnection">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bBotWallConnection">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="brickDir">
			<Description><![CDATA["Mirror Block Direction"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="startRow">
			<Description><![CDATA["Flip Rows"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bHalfStone">
			<Description><![CDATA["Half Block Joints"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="baseMortarThk">
			<Description><![CDATA["Base Mortar Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.02</Value>
		</Length>
		<Length Name="mortarThk">
			<Description><![CDATA["Mortar Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.001</Value>
		</Length>
		<Boolean Name="bAutoStartBrick">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Integer Name="iStartBrickHeight">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="iWindowBrick">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>793</Value>
		</Integer>

		<!-- beamParams: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="beamParams">
			<Description><![CDATA["Beams"]]></Description>
		</Title>
		<Integer Name="iBeamFamily">
			<Description><![CDATA["Beam type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Integer Name="iPrevBeamFamily">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="defBeamOverlap">
			<Description><![CDATA["Beam Overlap"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.25</Value>
		</Length>
		<Length Name="defBeamHeight">
			<Description><![CDATA["Beam Height"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.2</Value>
		</Length>
		<String Name="beamStrings">
			<Description><![CDATA["Beam Types:"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1"><![CDATA["Auto"]]></AVal>
				<AVal Row="2"><![CDATA["Auto"]]></AVal>
			</ArrayValues>
		</String>
		<Angle Name="beamAngles">
			<Description><![CDATA["Beam Types:"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
			</ArrayValues>
		</Angle>
		<Integer Name="iBeamFamilys">
			<Description><![CDATA["Beam Types:"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">1</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="customBeamOverlaps">
			<Description><![CDATA["Beam Overlap"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1">0.25</AVal>
				<AVal Row="2">0.25</AVal>
			</ArrayValues>
		</Length>
		<Length Name="customBeamHeights">
			<Description><![CDATA["Beam Height"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1">0.1</AVal>
				<AVal Row="2">0.1</AVal>
			</ArrayValues>
		</Length>

		<!-- joints: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="joints">
			<Description><![CDATA["Joints"]]></Description>
		</Title>
		<Integer Name="iJointType1">
			<Description><![CDATA["Joint Type 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Angle Name="jUiAngle1">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>154.285714286</Value>
		</Angle>
		<Boolean Name="bJointAngle1">
			<Description><![CDATA["Override Joint 1 Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Angle Name="jointAngle1">
			<Description><![CDATA["Joint 1 Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>90</Value>
		</Angle>
		<Boolean Name="bCustomCsorba1">
			<Description><![CDATA["Custom Overlapping 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="csorbaW1">
			<Description><![CDATA["Overlapping Size 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.1</Value>
		</Length>
		<Integer Name="iJointType2">
			<Description><![CDATA["Joint Type 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Angle Name="jUiAngle2">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>154.285714286</Value>
		</Angle>
		<Boolean Name="bJointAngle2">
			<Description><![CDATA["Override Joint 2 Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Angle Name="jointAngle2">
			<Description><![CDATA["Joint 2 Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>90</Value>
		</Angle>
		<Boolean Name="bCustomCsorba2">
			<Description><![CDATA["Custom Overlapping 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="csorbaW2">
			<Description><![CDATA["Overlapping Size 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.1</Value>
		</Length>

		<!-- manual: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="manual">
			<Description><![CDATA["Hotspot Editing only"]]></Description>
		</Title>
		<Boolean Name="bColPos">
			<Description><![CDATA["Set Up Columns"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="colPosX">
			<Description><![CDATA["Columns Position"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="3" SecondDimension="0">
				<AVal Row="1">0.1</AVal>
				<AVal Row="2">4.4</AVal>
				<AVal Row="3">-1</AVal>
			</ArrayValues>
		</Length>
		<Boolean Name="tConnections">
			<Description><![CDATA["Set Up T Connections"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="tConnWallDir">
			<Description><![CDATA["Connection Walls Direction"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="tConnWallPos">
			<Description><![CDATA["Connection Walls Position"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">-0.7</AVal>
			</ArrayValues>
		</Length>
		<Length Name="tConnWallThk">
			<Description><![CDATA["Connection Walls Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0.24</AVal>
			</ArrayValues>
		</Length>
		<Length Name="tConnWallHmin">
			<Description><![CDATA["Connection Walls Bottom"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="tConnWallHmax">
			<Description><![CDATA["Connection Walls Top"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">2.7</AVal>
			</ArrayValues>
		</Length>
		<Angle Name="tConnWallAngle">
			<Description><![CDATA["Connection Walls Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">90</AVal>
			</ArrayValues>
		</Angle>
		<Length Name="topProfilesOverhead">
			<Description><![CDATA["Top Profiles Overhead"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Boolean Name="bUpdateDatas">
			<Description><![CDATA["Update Datas"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Separator Name="data_family">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
		</Separator>
		<Integer Name="datProdLang">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="9" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">1</AVal>
				<AVal Row="3">1</AVal>
				<AVal Row="4">1</AVal>
				<AVal Row="5">1</AVal>
				<AVal Row="6">1</AVal>
				<AVal Row="7">1</AVal>
				<AVal Row="8">1</AVal>
				<AVal Row="9">1</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="datProdIdx">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="9" SecondDimension="0">
				<AVal Row="1">10000</AVal>
				<AVal Row="2">10100</AVal>
				<AVal Row="3">10200</AVal>
				<AVal Row="4">10300</AVal>
				<AVal Row="5">10400</AVal>
				<AVal Row="6">10500</AVal>
				<AVal Row="7">10600</AVal>
				<AVal Row="8">10700</AVal>
				<AVal Row="9">10800</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="datProdType">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="9" SecondDimension="0">
				<AVal Row="1">10</AVal>
				<AVal Row="2">10</AVal>
				<AVal Row="3">10</AVal>
				<AVal Row="4">10</AVal>
				<AVal Row="5">10</AVal>
				<AVal Row="6">10</AVal>
				<AVal Row="7">10</AVal>
				<AVal Row="8">10</AVal>
				<AVal Row="9">10</AVal>
			</ArrayValues>
		</Integer>
		<String Name="datProdName">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="9" SecondDimension="0">
				<AVal Row="1"><![CDATA["KS Quadro 12-1,8-DM"]]></AVal>
				<AVal Row="2"><![CDATA["KS Quadro 16-1,8-DM"]]></AVal>
				<AVal Row="3"><![CDATA["KS Quadro 20-1,8-DM"]]></AVal>
				<AVal Row="4"><![CDATA["KS Quadro 20-2,0-DM"]]></AVal>
				<AVal Row="5"><![CDATA["KS Quadro 20-2,2-DM"]]></AVal>
				<AVal Row="6"><![CDATA["KS Quadro E 12-1,8-DM"]]></AVal>
				<AVal Row="7"><![CDATA["KS Quadro E 20-1,8-DM"]]></AVal>
				<AVal Row="8"><![CDATA["KS Quadro E 12-2,0-DM"]]></AVal>
				<AVal Row="9"><![CDATA["KS Quadro E 20-2,0-DM"]]></AVal>
			</ArrayValues>
		</String>
		<Length Name="datProdMinbrickSize">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="9" SecondDimension="0">
				<AVal Row="1">0.16</AVal>
				<AVal Row="2">0.16</AVal>
				<AVal Row="3">0.16</AVal>
				<AVal Row="4">0.16</AVal>
				<AVal Row="5">0.16</AVal>
				<AVal Row="6">0.16</AVal>
				<AVal Row="7">0.16</AVal>
				<AVal Row="8">0.16</AVal>
				<AVal Row="9">0.16</AVal>
			</ArrayValues>
		</Length>
		<Length Name="datProdMinBrickOverlap">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="9" SecondDimension="0">
				<AVal Row="1">0.1</AVal>
				<AVal Row="2">0.1</AVal>
				<AVal Row="3">0.1</AVal>
				<AVal Row="4">0.1</AVal>
				<AVal Row="5">0.1</AVal>
				<AVal Row="6">0.1</AVal>
				<AVal Row="7">0.1</AVal>
				<AVal Row="8">0.1</AVal>
				<AVal Row="9">0.1</AVal>
			</ArrayValues>
		</Length>
		<Boolean Name="datProdDisableJoint">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="9" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
			</ArrayValues>
		</Boolean>
		<Boolean Name="datProdDisableFlipRow">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="9" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
			</ArrayValues>
		</Boolean>
		<Boolean Name="datProdDisableBrickDir">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="9" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">1</AVal>
				<AVal Row="3">1</AVal>
				<AVal Row="4">1</AVal>
				<AVal Row="5">1</AVal>
				<AVal Row="6">1</AVal>
				<AVal Row="7">1</AVal>
				<AVal Row="8">1</AVal>
				<AVal Row="9">1</AVal>
			</ArrayValues>
		</Boolean>
		<Separator Name="data_bricks">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
		</Separator>
		<Integer Name="datBrickLang">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">1</AVal>
				<AVal Row="3">1</AVal>
				<AVal Row="4">1</AVal>
				<AVal Row="5">1</AVal>
				<AVal Row="6">1</AVal>
				<AVal Row="7">1</AVal>
				<AVal Row="8">1</AVal>
				<AVal Row="9">1</AVal>
				<AVal Row="10">1</AVal>
				<AVal Row="11">1</AVal>
				<AVal Row="12">1</AVal>
				<AVal Row="13">1</AVal>
				<AVal Row="14">1</AVal>
				<AVal Row="15">1</AVal>
				<AVal Row="16">1</AVal>
				<AVal Row="17">1</AVal>
				<AVal Row="18">1</AVal>
				<AVal Row="19">1</AVal>
				<AVal Row="20">1</AVal>
				<AVal Row="21">1</AVal>
				<AVal Row="22">1</AVal>
				<AVal Row="23">1</AVal>
				<AVal Row="24">1</AVal>
				<AVal Row="25">1</AVal>
				<AVal Row="26">1</AVal>
				<AVal Row="27">1</AVal>
				<AVal Row="28">1</AVal>
				<AVal Row="29">1</AVal>
				<AVal Row="30">1</AVal>
				<AVal Row="31">1</AVal>
				<AVal Row="32">1</AVal>
				<AVal Row="33">1</AVal>
				<AVal Row="34">1</AVal>
				<AVal Row="35">1</AVal>
				<AVal Row="36">1</AVal>
				<AVal Row="37">1</AVal>
				<AVal Row="38">1</AVal>
				<AVal Row="39">1</AVal>
				<AVal Row="40">1</AVal>
				<AVal Row="41">1</AVal>
				<AVal Row="42">1</AVal>
				<AVal Row="43">1</AVal>
				<AVal Row="44">1</AVal>
				<AVal Row="45">1</AVal>
				<AVal Row="46">1</AVal>
				<AVal Row="47">1</AVal>
				<AVal Row="48">1</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="datBrickIdx">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">10001</AVal>
				<AVal Row="2">10002</AVal>
				<AVal Row="3">10003</AVal>
				<AVal Row="4">10004</AVal>
				<AVal Row="5">10005</AVal>
				<AVal Row="6">10006</AVal>
				<AVal Row="7">10007</AVal>
				<AVal Row="8">10008</AVal>
				<AVal Row="9">10009</AVal>
				<AVal Row="10">10010</AVal>
				<AVal Row="11">10011</AVal>
				<AVal Row="12">10012</AVal>
				<AVal Row="13">10013</AVal>
				<AVal Row="14">10014</AVal>
				<AVal Row="15">10015</AVal>
				<AVal Row="16">10016</AVal>
				<AVal Row="17">10017</AVal>
				<AVal Row="18">10018</AVal>
				<AVal Row="19">10019</AVal>
				<AVal Row="20">10020</AVal>
				<AVal Row="21">10021</AVal>
				<AVal Row="22">10022</AVal>
				<AVal Row="23">10023</AVal>
				<AVal Row="24">10024</AVal>
				<AVal Row="25">10025</AVal>
				<AVal Row="26">10026</AVal>
				<AVal Row="27">10027</AVal>
				<AVal Row="28">10028</AVal>
				<AVal Row="29">10029</AVal>
				<AVal Row="30">10030</AVal>
				<AVal Row="31">10031</AVal>
				<AVal Row="32">10032</AVal>
				<AVal Row="33">10501</AVal>
				<AVal Row="34">10502</AVal>
				<AVal Row="35">10503</AVal>
				<AVal Row="36">10504</AVal>
				<AVal Row="37">10505</AVal>
				<AVal Row="38">10506</AVal>
				<AVal Row="39">10507</AVal>
				<AVal Row="40">10508</AVal>
				<AVal Row="41">10509</AVal>
				<AVal Row="42">10510</AVal>
				<AVal Row="43">10511</AVal>
				<AVal Row="44">10512</AVal>
				<AVal Row="45">10513</AVal>
				<AVal Row="46">10514</AVal>
				<AVal Row="47">10515</AVal>
				<AVal Row="48">10516</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="datBrickFamily">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">10000</AVal>
				<AVal Row="2">10000</AVal>
				<AVal Row="3">10000</AVal>
				<AVal Row="4">10000</AVal>
				<AVal Row="5">10000</AVal>
				<AVal Row="6">10000</AVal>
				<AVal Row="7">10000</AVal>
				<AVal Row="8">10100</AVal>
				<AVal Row="9">10100</AVal>
				<AVal Row="10">10100</AVal>
				<AVal Row="11">10100</AVal>
				<AVal Row="12">10100</AVal>
				<AVal Row="13">10100</AVal>
				<AVal Row="14">10100</AVal>
				<AVal Row="15">10200</AVal>
				<AVal Row="16">10200</AVal>
				<AVal Row="17">10200</AVal>
				<AVal Row="18">10200</AVal>
				<AVal Row="19">10200</AVal>
				<AVal Row="20">10200</AVal>
				<AVal Row="21">10200</AVal>
				<AVal Row="22">10300</AVal>
				<AVal Row="23">10300</AVal>
				<AVal Row="24">10300</AVal>
				<AVal Row="25">10300</AVal>
				<AVal Row="26">10300</AVal>
				<AVal Row="27">10300</AVal>
				<AVal Row="28">10300</AVal>
				<AVal Row="29">10400</AVal>
				<AVal Row="30">10400</AVal>
				<AVal Row="31">10400</AVal>
				<AVal Row="32">10400</AVal>
				<AVal Row="33">10500</AVal>
				<AVal Row="34">10500</AVal>
				<AVal Row="35">10500</AVal>
				<AVal Row="36">10500</AVal>
				<AVal Row="37">10600</AVal>
				<AVal Row="38">10600</AVal>
				<AVal Row="39">10600</AVal>
				<AVal Row="40">10600</AVal>
				<AVal Row="41">10700</AVal>
				<AVal Row="42">10700</AVal>
				<AVal Row="43">10700</AVal>
				<AVal Row="44">10700</AVal>
				<AVal Row="45">10800</AVal>
				<AVal Row="46">10800</AVal>
				<AVal Row="47">10800</AVal>
				<AVal Row="48">10800</AVal>
			</ArrayValues>
		</Integer>
		<String Name="datBrickName">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1"><![CDATA["KS-Quadro 12-1,8-DM (115x498x498)"]]></AVal>
				<AVal Row="2"><![CDATA["KS-Quadro 12-1,8-DM (150x498x498)"]]></AVal>
				<AVal Row="3"><![CDATA["KS-Quadro 12-1,8-DM (175x498x498)"]]></AVal>
				<AVal Row="4"><![CDATA["KS-Quadro 12-1,8-DM (200x498x498)"]]></AVal>
				<AVal Row="5"><![CDATA["KS-Quadro 12-1,8-DM (240x498x498)"]]></AVal>
				<AVal Row="6"><![CDATA["KS-Quadro 12-1,8-DM (300x498x498)"]]></AVal>
				<AVal Row="7"><![CDATA["KS-Quadro 12-1,8-DM (365x498x498)"]]></AVal>
				<AVal Row="8"><![CDATA["KS-Quadro 16-1,8-DM (115x498x498)"]]></AVal>
				<AVal Row="9"><![CDATA["KS-Quadro 16-1,8-DM (150x498x498)"]]></AVal>
				<AVal Row="10"><![CDATA["KS-Quadro 16-1,8-DM (175x498x498)"]]></AVal>
				<AVal Row="11"><![CDATA["KS-Quadro 16-1,8-DM (200x498x498)"]]></AVal>
				<AVal Row="12"><![CDATA["KS-Quadro 16-1,8-DM (240x498x498)"]]></AVal>
				<AVal Row="13"><![CDATA["KS-Quadro 16-1,8-DM (300x498x498)"]]></AVal>
				<AVal Row="14"><![CDATA["KS-Quadro 16-1,8-DM (365x498x498)"]]></AVal>
				<AVal Row="15"><![CDATA["KS-Quadro 20-1,8-DM (115x498x498)"]]></AVal>
				<AVal Row="16"><![CDATA["KS-Quadro 20-1,8-DM (150x498x498)"]]></AVal>
				<AVal Row="17"><![CDATA["KS-Quadro 20-1,8-DM (175x498x498)"]]></AVal>
				<AVal Row="18"><![CDATA["KS-Quadro 20-1,8-DM (200x498x498)"]]></AVal>
				<AVal Row="19"><![CDATA["KS-Quadro 20-1,8-DM (240x498x498)"]]></AVal>
				<AVal Row="20"><![CDATA["KS-Quadro 20-1,8-DM (300x498x498)"]]></AVal>
				<AVal Row="21"><![CDATA["KS-Quadro 20-1,8-DM (365x498x498)"]]></AVal>
				<AVal Row="22"><![CDATA["KS-Quadro 20-2-DM (115x498x498)"]]></AVal>
				<AVal Row="23"><![CDATA["KS-Quadro 20-2-DM (150x498x498)"]]></AVal>
				<AVal Row="24"><![CDATA["KS-Quadro 20-2-DM (175x498x498)"]]></AVal>
				<AVal Row="25"><![CDATA["KS-Quadro 20-2-DM (200x498x498)"]]></AVal>
				<AVal Row="26"><![CDATA["KS-Quadro 20-2-DM (240x498x498)"]]></AVal>
				<AVal Row="27"><![CDATA["KS-Quadro 20-2-DM (300x498x498)"]]></AVal>
				<AVal Row="28"><![CDATA["KS-Quadro 20-2-DM (365x498x498)"]]></AVal>
				<AVal Row="29"><![CDATA["KS-Quadro 20-2,2-DM (150x498x498)"]]></AVal>
				<AVal Row="30"><![CDATA["KS-Quadro 20-2,2-DM (175x498x498)"]]></AVal>
				<AVal Row="31"><![CDATA["KS-Quadro 20-2,2-DM (200x498x498)"]]></AVal>
				<AVal Row="32"><![CDATA["KS-Quadro 20-2,2-DM (240x498x498)"]]></AVal>
				<AVal Row="33"><![CDATA["KS-Quadro E 12-1,8-DM (115x498x498)"]]></AVal>
				<AVal Row="34"><![CDATA["KS-Quadro E 12-1,8-DM (150x498x498)"]]></AVal>
				<AVal Row="35"><![CDATA["KS-Quadro E 12-1,8-DM (175x498x498)"]]></AVal>
				<AVal Row="36"><![CDATA["KS-Quadro E 12-1,8-DM (240x498x498)"]]></AVal>
				<AVal Row="37"><![CDATA["KS-Quadro E 20-1,8-DM (115x498x498)"]]></AVal>
				<AVal Row="38"><![CDATA["KS-Quadro E 20-1,8-DM (150x498x498)"]]></AVal>
				<AVal Row="39"><![CDATA["KS-Quadro E 20-1,8-DM (175x498x498)"]]></AVal>
				<AVal Row="40"><![CDATA["KS-Quadro E 20-1,8-DM (240x498x498)"]]></AVal>
				<AVal Row="41"><![CDATA["KS-Quadro E 12-2-DM (150x498x498)"]]></AVal>
				<AVal Row="42"><![CDATA["KS-Quadro E 12-2-DM (175x498x498)"]]></AVal>
				<AVal Row="43"><![CDATA["KS-Quadro E 12-2-DM (200x498x498)"]]></AVal>
				<AVal Row="44"><![CDATA["KS-Quadro E 12-2-DM (240x498x498)"]]></AVal>
				<AVal Row="45"><![CDATA["KS-Quadro E 20-2-DM (150x498x498)"]]></AVal>
				<AVal Row="46"><![CDATA["KS-Quadro E 20-2-DM (175x498x498)"]]></AVal>
				<AVal Row="47"><![CDATA["KS-Quadro E 20-2-DM (200x498x498)"]]></AVal>
				<AVal Row="48"><![CDATA["KS-Quadro E 20-2-DM (240x498x498)"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="datBrickObjectName">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1"><![CDATA["KS-Quadro12-18-DM-115-498-498"]]></AVal>
				<AVal Row="2"><![CDATA["KS-Quadro12-18-DM-150-498-498"]]></AVal>
				<AVal Row="3"><![CDATA["KS-Quadro12-18-DM-175-498-498"]]></AVal>
				<AVal Row="4"><![CDATA["KS-Quadro12-18-DM-200-498-498"]]></AVal>
				<AVal Row="5"><![CDATA["KS-Quadro12-18-DM-240-498-498"]]></AVal>
				<AVal Row="6"><![CDATA["KS-Quadro12-18-DM-300-498-498"]]></AVal>
				<AVal Row="7"><![CDATA["KS-Quadro12-18-DM-365-498-498"]]></AVal>
				<AVal Row="8"><![CDATA["KS-Quadro16-18-DM-115-498-498"]]></AVal>
				<AVal Row="9"><![CDATA["KS-Quadro16-18-DM-150-498-498"]]></AVal>
				<AVal Row="10"><![CDATA["KS-Quadro16-18-DM-175-498-498"]]></AVal>
				<AVal Row="11"><![CDATA["KS-Quadro16-18-DM-200-498-498"]]></AVal>
				<AVal Row="12"><![CDATA["KS-Quadro16-18-DM-240-498-498"]]></AVal>
				<AVal Row="13"><![CDATA["KS-Quadro16-18-DM-300-498-498"]]></AVal>
				<AVal Row="14"><![CDATA["KS-Quadro16-18-DM-365-498-498"]]></AVal>
				<AVal Row="15"><![CDATA["KS-Quadro20-18-DM-115-498-498"]]></AVal>
				<AVal Row="16"><![CDATA["KS-Quadro20-18-DM-150-498-498"]]></AVal>
				<AVal Row="17"><![CDATA["KS-Quadro20-18-DM-175-498-498"]]></AVal>
				<AVal Row="18"><![CDATA["KS-Quadro20-18-DM-200-498-498"]]></AVal>
				<AVal Row="19"><![CDATA["KS-Quadro20-18-DM-240-498-498"]]></AVal>
				<AVal Row="20"><![CDATA["KS-Quadro20-18-DM-300-498-498"]]></AVal>
				<AVal Row="21"><![CDATA["KS-Quadro20-18-DM-365-498-498"]]></AVal>
				<AVal Row="22"><![CDATA["KS-Quadro20-20-DM-115-498-498"]]></AVal>
				<AVal Row="23"><![CDATA["KS-Quadro20-20-DM-150-498-498"]]></AVal>
				<AVal Row="24"><![CDATA["KS-Quadro20-20-DM-175-498-498"]]></AVal>
				<AVal Row="25"><![CDATA["KS-Quadro20-20-DM-200-498-498"]]></AVal>
				<AVal Row="26"><![CDATA["KS-Quadro20-20-DM-240-498-498"]]></AVal>
				<AVal Row="27"><![CDATA["KS-Quadro20-20-DM-300-498-498"]]></AVal>
				<AVal Row="28"><![CDATA["KS-Quadro20-20-DM-365-498-498"]]></AVal>
				<AVal Row="29"><![CDATA["KS-Quadro20-22-DM-150-498-498"]]></AVal>
				<AVal Row="30"><![CDATA["KS-Quadro20-22-DM-175-498-498"]]></AVal>
				<AVal Row="31"><![CDATA["KS-Quadro20-22-DM-200-498-498"]]></AVal>
				<AVal Row="32"><![CDATA["KS-Quadro20-22-DM-240-498-498"]]></AVal>
				<AVal Row="33"><![CDATA["KS-Quadro12-18-DM-115-498-498"]]></AVal>
				<AVal Row="34"><![CDATA["KS-Quadro12-18-DM-150-498-498"]]></AVal>
				<AVal Row="35"><![CDATA["KS-Quadro12-18-DM-175-498-498"]]></AVal>
				<AVal Row="36"><![CDATA["KS-Quadro12-18-DM-240-498-498"]]></AVal>
				<AVal Row="37"><![CDATA["KS-Quadro20-18-DM-115-498-498"]]></AVal>
				<AVal Row="38"><![CDATA["KS-Quadro20-18-DM-150-498-498"]]></AVal>
				<AVal Row="39"><![CDATA["KS-Quadro20-18-DM-175-498-498"]]></AVal>
				<AVal Row="40"><![CDATA["KS-Quadro20-18-DM-240-498-498"]]></AVal>
				<AVal Row="41"><![CDATA["KS-Quadro12-20-DM-150-498-498"]]></AVal>
				<AVal Row="42"><![CDATA["KS-Quadro12-20-DM-175-498-498"]]></AVal>
				<AVal Row="43"><![CDATA["KS-Quadro12-20-DM-200-498-498"]]></AVal>
				<AVal Row="44"><![CDATA["KS-Quadro12-20-DM-240-498-498"]]></AVal>
				<AVal Row="45"><![CDATA["KS-Quadro20-20-DM-150-498-498"]]></AVal>
				<AVal Row="46"><![CDATA["KS-Quadro20-20-DM-175-498-498"]]></AVal>
				<AVal Row="47"><![CDATA["KS-Quadro20-20-DM-200-498-498"]]></AVal>
				<AVal Row="48"><![CDATA["KS-Quadro20-20-DM-240-498-498"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="datBrickArtNo">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
				<AVal Row="3"><![CDATA[""]]></AVal>
				<AVal Row="4"><![CDATA[""]]></AVal>
				<AVal Row="5"><![CDATA[""]]></AVal>
				<AVal Row="6"><![CDATA[""]]></AVal>
				<AVal Row="7"><![CDATA[""]]></AVal>
				<AVal Row="8"><![CDATA[""]]></AVal>
				<AVal Row="9"><![CDATA[""]]></AVal>
				<AVal Row="10"><![CDATA[""]]></AVal>
				<AVal Row="11"><![CDATA[""]]></AVal>
				<AVal Row="12"><![CDATA[""]]></AVal>
				<AVal Row="13"><![CDATA[""]]></AVal>
				<AVal Row="14"><![CDATA[""]]></AVal>
				<AVal Row="15"><![CDATA[""]]></AVal>
				<AVal Row="16"><![CDATA[""]]></AVal>
				<AVal Row="17"><![CDATA[""]]></AVal>
				<AVal Row="18"><![CDATA[""]]></AVal>
				<AVal Row="19"><![CDATA[""]]></AVal>
				<AVal Row="20"><![CDATA[""]]></AVal>
				<AVal Row="21"><![CDATA[""]]></AVal>
				<AVal Row="22"><![CDATA[""]]></AVal>
				<AVal Row="23"><![CDATA[""]]></AVal>
				<AVal Row="24"><![CDATA[""]]></AVal>
				<AVal Row="25"><![CDATA[""]]></AVal>
				<AVal Row="26"><![CDATA[""]]></AVal>
				<AVal Row="27"><![CDATA[""]]></AVal>
				<AVal Row="28"><![CDATA[""]]></AVal>
				<AVal Row="29"><![CDATA[""]]></AVal>
				<AVal Row="30"><![CDATA[""]]></AVal>
				<AVal Row="31"><![CDATA[""]]></AVal>
				<AVal Row="32"><![CDATA[""]]></AVal>
				<AVal Row="33"><![CDATA[""]]></AVal>
				<AVal Row="34"><![CDATA[""]]></AVal>
				<AVal Row="35"><![CDATA[""]]></AVal>
				<AVal Row="36"><![CDATA[""]]></AVal>
				<AVal Row="37"><![CDATA[""]]></AVal>
				<AVal Row="38"><![CDATA[""]]></AVal>
				<AVal Row="39"><![CDATA[""]]></AVal>
				<AVal Row="40"><![CDATA[""]]></AVal>
				<AVal Row="41"><![CDATA[""]]></AVal>
				<AVal Row="42"><![CDATA[""]]></AVal>
				<AVal Row="43"><![CDATA[""]]></AVal>
				<AVal Row="44"><![CDATA[""]]></AVal>
				<AVal Row="45"><![CDATA[""]]></AVal>
				<AVal Row="46"><![CDATA[""]]></AVal>
				<AVal Row="47"><![CDATA[""]]></AVal>
				<AVal Row="48"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<String Name="datBrickDbNo">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
				<AVal Row="3"><![CDATA[""]]></AVal>
				<AVal Row="4"><![CDATA[""]]></AVal>
				<AVal Row="5"><![CDATA[""]]></AVal>
				<AVal Row="6"><![CDATA[""]]></AVal>
				<AVal Row="7"><![CDATA[""]]></AVal>
				<AVal Row="8"><![CDATA[""]]></AVal>
				<AVal Row="9"><![CDATA[""]]></AVal>
				<AVal Row="10"><![CDATA[""]]></AVal>
				<AVal Row="11"><![CDATA[""]]></AVal>
				<AVal Row="12"><![CDATA[""]]></AVal>
				<AVal Row="13"><![CDATA[""]]></AVal>
				<AVal Row="14"><![CDATA[""]]></AVal>
				<AVal Row="15"><![CDATA[""]]></AVal>
				<AVal Row="16"><![CDATA[""]]></AVal>
				<AVal Row="17"><![CDATA[""]]></AVal>
				<AVal Row="18"><![CDATA[""]]></AVal>
				<AVal Row="19"><![CDATA[""]]></AVal>
				<AVal Row="20"><![CDATA[""]]></AVal>
				<AVal Row="21"><![CDATA[""]]></AVal>
				<AVal Row="22"><![CDATA[""]]></AVal>
				<AVal Row="23"><![CDATA[""]]></AVal>
				<AVal Row="24"><![CDATA[""]]></AVal>
				<AVal Row="25"><![CDATA[""]]></AVal>
				<AVal Row="26"><![CDATA[""]]></AVal>
				<AVal Row="27"><![CDATA[""]]></AVal>
				<AVal Row="28"><![CDATA[""]]></AVal>
				<AVal Row="29"><![CDATA[""]]></AVal>
				<AVal Row="30"><![CDATA[""]]></AVal>
				<AVal Row="31"><![CDATA[""]]></AVal>
				<AVal Row="32"><![CDATA[""]]></AVal>
				<AVal Row="33"><![CDATA[""]]></AVal>
				<AVal Row="34"><![CDATA[""]]></AVal>
				<AVal Row="35"><![CDATA[""]]></AVal>
				<AVal Row="36"><![CDATA[""]]></AVal>
				<AVal Row="37"><![CDATA[""]]></AVal>
				<AVal Row="38"><![CDATA[""]]></AVal>
				<AVal Row="39"><![CDATA[""]]></AVal>
				<AVal Row="40"><![CDATA[""]]></AVal>
				<AVal Row="41"><![CDATA[""]]></AVal>
				<AVal Row="42"><![CDATA[""]]></AVal>
				<AVal Row="43"><![CDATA[""]]></AVal>
				<AVal Row="44"><![CDATA[""]]></AVal>
				<AVal Row="45"><![CDATA[""]]></AVal>
				<AVal Row="46"><![CDATA[""]]></AVal>
				<AVal Row="47"><![CDATA[""]]></AVal>
				<AVal Row="48"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<String Name="datBrickEan">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
				<AVal Row="3"><![CDATA[""]]></AVal>
				<AVal Row="4"><![CDATA[""]]></AVal>
				<AVal Row="5"><![CDATA[""]]></AVal>
				<AVal Row="6"><![CDATA[""]]></AVal>
				<AVal Row="7"><![CDATA[""]]></AVal>
				<AVal Row="8"><![CDATA[""]]></AVal>
				<AVal Row="9"><![CDATA[""]]></AVal>
				<AVal Row="10"><![CDATA[""]]></AVal>
				<AVal Row="11"><![CDATA[""]]></AVal>
				<AVal Row="12"><![CDATA[""]]></AVal>
				<AVal Row="13"><![CDATA[""]]></AVal>
				<AVal Row="14"><![CDATA[""]]></AVal>
				<AVal Row="15"><![CDATA[""]]></AVal>
				<AVal Row="16"><![CDATA[""]]></AVal>
				<AVal Row="17"><![CDATA[""]]></AVal>
				<AVal Row="18"><![CDATA[""]]></AVal>
				<AVal Row="19"><![CDATA[""]]></AVal>
				<AVal Row="20"><![CDATA[""]]></AVal>
				<AVal Row="21"><![CDATA[""]]></AVal>
				<AVal Row="22"><![CDATA[""]]></AVal>
				<AVal Row="23"><![CDATA[""]]></AVal>
				<AVal Row="24"><![CDATA[""]]></AVal>
				<AVal Row="25"><![CDATA[""]]></AVal>
				<AVal Row="26"><![CDATA[""]]></AVal>
				<AVal Row="27"><![CDATA[""]]></AVal>
				<AVal Row="28"><![CDATA[""]]></AVal>
				<AVal Row="29"><![CDATA[""]]></AVal>
				<AVal Row="30"><![CDATA[""]]></AVal>
				<AVal Row="31"><![CDATA[""]]></AVal>
				<AVal Row="32"><![CDATA[""]]></AVal>
				<AVal Row="33"><![CDATA[""]]></AVal>
				<AVal Row="34"><![CDATA[""]]></AVal>
				<AVal Row="35"><![CDATA[""]]></AVal>
				<AVal Row="36"><![CDATA[""]]></AVal>
				<AVal Row="37"><![CDATA[""]]></AVal>
				<AVal Row="38"><![CDATA[""]]></AVal>
				<AVal Row="39"><![CDATA[""]]></AVal>
				<AVal Row="40"><![CDATA[""]]></AVal>
				<AVal Row="41"><![CDATA[""]]></AVal>
				<AVal Row="42"><![CDATA[""]]></AVal>
				<AVal Row="43"><![CDATA[""]]></AVal>
				<AVal Row="44"><![CDATA[""]]></AVal>
				<AVal Row="45"><![CDATA[""]]></AVal>
				<AVal Row="46"><![CDATA[""]]></AVal>
				<AVal Row="47"><![CDATA[""]]></AVal>
				<AVal Row="48"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<Boolean Name="datBrickCustomName">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
				<AVal Row="17">0</AVal>
				<AVal Row="18">0</AVal>
				<AVal Row="19">0</AVal>
				<AVal Row="20">0</AVal>
				<AVal Row="21">0</AVal>
				<AVal Row="22">0</AVal>
				<AVal Row="23">0</AVal>
				<AVal Row="24">0</AVal>
				<AVal Row="25">0</AVal>
				<AVal Row="26">0</AVal>
				<AVal Row="27">0</AVal>
				<AVal Row="28">0</AVal>
				<AVal Row="29">0</AVal>
				<AVal Row="30">0</AVal>
				<AVal Row="31">0</AVal>
				<AVal Row="32">0</AVal>
				<AVal Row="33">0</AVal>
				<AVal Row="34">0</AVal>
				<AVal Row="35">0</AVal>
				<AVal Row="36">0</AVal>
				<AVal Row="37">0</AVal>
				<AVal Row="38">0</AVal>
				<AVal Row="39">0</AVal>
				<AVal Row="40">0</AVal>
				<AVal Row="41">0</AVal>
				<AVal Row="42">0</AVal>
				<AVal Row="43">0</AVal>
				<AVal Row="44">0</AVal>
				<AVal Row="45">0</AVal>
				<AVal Row="46">0</AVal>
				<AVal Row="47">0</AVal>
				<AVal Row="48">0</AVal>
			</ArrayValues>
		</Boolean>
		<String Name="datBrickNutProf">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
				<AVal Row="3"><![CDATA[""]]></AVal>
				<AVal Row="4"><![CDATA[""]]></AVal>
				<AVal Row="5"><![CDATA[""]]></AVal>
				<AVal Row="6"><![CDATA[""]]></AVal>
				<AVal Row="7"><![CDATA[""]]></AVal>
				<AVal Row="8"><![CDATA[""]]></AVal>
				<AVal Row="9"><![CDATA[""]]></AVal>
				<AVal Row="10"><![CDATA[""]]></AVal>
				<AVal Row="11"><![CDATA[""]]></AVal>
				<AVal Row="12"><![CDATA[""]]></AVal>
				<AVal Row="13"><![CDATA[""]]></AVal>
				<AVal Row="14"><![CDATA[""]]></AVal>
				<AVal Row="15"><![CDATA[""]]></AVal>
				<AVal Row="16"><![CDATA[""]]></AVal>
				<AVal Row="17"><![CDATA[""]]></AVal>
				<AVal Row="18"><![CDATA[""]]></AVal>
				<AVal Row="19"><![CDATA[""]]></AVal>
				<AVal Row="20"><![CDATA[""]]></AVal>
				<AVal Row="21"><![CDATA[""]]></AVal>
				<AVal Row="22"><![CDATA[""]]></AVal>
				<AVal Row="23"><![CDATA[""]]></AVal>
				<AVal Row="24"><![CDATA[""]]></AVal>
				<AVal Row="25"><![CDATA[""]]></AVal>
				<AVal Row="26"><![CDATA[""]]></AVal>
				<AVal Row="27"><![CDATA[""]]></AVal>
				<AVal Row="28"><![CDATA[""]]></AVal>
				<AVal Row="29"><![CDATA[""]]></AVal>
				<AVal Row="30"><![CDATA[""]]></AVal>
				<AVal Row="31"><![CDATA[""]]></AVal>
				<AVal Row="32"><![CDATA[""]]></AVal>
				<AVal Row="33"><![CDATA[""]]></AVal>
				<AVal Row="34"><![CDATA[""]]></AVal>
				<AVal Row="35"><![CDATA[""]]></AVal>
				<AVal Row="36"><![CDATA[""]]></AVal>
				<AVal Row="37"><![CDATA[""]]></AVal>
				<AVal Row="38"><![CDATA[""]]></AVal>
				<AVal Row="39"><![CDATA[""]]></AVal>
				<AVal Row="40"><![CDATA[""]]></AVal>
				<AVal Row="41"><![CDATA[""]]></AVal>
				<AVal Row="42"><![CDATA[""]]></AVal>
				<AVal Row="43"><![CDATA[""]]></AVal>
				<AVal Row="44"><![CDATA[""]]></AVal>
				<AVal Row="45"><![CDATA[""]]></AVal>
				<AVal Row="46"><![CDATA[""]]></AVal>
				<AVal Row="47"><![CDATA[""]]></AVal>
				<AVal Row="48"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<Length Name="datBrickSize">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="3">
				<AVal Column="1" Row="1">0.115</AVal>
				<AVal Column="2" Row="1">0.498</AVal>
				<AVal Column="3" Row="1">0.498</AVal>
				<AVal Column="1" Row="2">0.15</AVal>
				<AVal Column="2" Row="2">0.498</AVal>
				<AVal Column="3" Row="2">0.498</AVal>
				<AVal Column="1" Row="3">0.175</AVal>
				<AVal Column="2" Row="3">0.498</AVal>
				<AVal Column="3" Row="3">0.498</AVal>
				<AVal Column="1" Row="4">0.2</AVal>
				<AVal Column="2" Row="4">0.498</AVal>
				<AVal Column="3" Row="4">0.498</AVal>
				<AVal Column="1" Row="5">0.24</AVal>
				<AVal Column="2" Row="5">0.498</AVal>
				<AVal Column="3" Row="5">0.498</AVal>
				<AVal Column="1" Row="6">0.3</AVal>
				<AVal Column="2" Row="6">0.498</AVal>
				<AVal Column="3" Row="6">0.498</AVal>
				<AVal Column="1" Row="7">0.365</AVal>
				<AVal Column="2" Row="7">0.498</AVal>
				<AVal Column="3" Row="7">0.498</AVal>
				<AVal Column="1" Row="8">0.115</AVal>
				<AVal Column="2" Row="8">0.498</AVal>
				<AVal Column="3" Row="8">0.498</AVal>
				<AVal Column="1" Row="9">0.15</AVal>
				<AVal Column="2" Row="9">0.498</AVal>
				<AVal Column="3" Row="9">0.498</AVal>
				<AVal Column="1" Row="10">0.175</AVal>
				<AVal Column="2" Row="10">0.498</AVal>
				<AVal Column="3" Row="10">0.498</AVal>
				<AVal Column="1" Row="11">0.2</AVal>
				<AVal Column="2" Row="11">0.498</AVal>
				<AVal Column="3" Row="11">0.498</AVal>
				<AVal Column="1" Row="12">0.24</AVal>
				<AVal Column="2" Row="12">0.498</AVal>
				<AVal Column="3" Row="12">0.498</AVal>
				<AVal Column="1" Row="13">0.3</AVal>
				<AVal Column="2" Row="13">0.498</AVal>
				<AVal Column="3" Row="13">0.498</AVal>
				<AVal Column="1" Row="14">0.365</AVal>
				<AVal Column="2" Row="14">0.498</AVal>
				<AVal Column="3" Row="14">0.498</AVal>
				<AVal Column="1" Row="15">0.115</AVal>
				<AVal Column="2" Row="15">0.498</AVal>
				<AVal Column="3" Row="15">0.498</AVal>
				<AVal Column="1" Row="16">0.15</AVal>
				<AVal Column="2" Row="16">0.498</AVal>
				<AVal Column="3" Row="16">0.498</AVal>
				<AVal Column="1" Row="17">0.175</AVal>
				<AVal Column="2" Row="17">0.498</AVal>
				<AVal Column="3" Row="17">0.498</AVal>
				<AVal Column="1" Row="18">0.2</AVal>
				<AVal Column="2" Row="18">0.498</AVal>
				<AVal Column="3" Row="18">0.498</AVal>
				<AVal Column="1" Row="19">0.24</AVal>
				<AVal Column="2" Row="19">0.498</AVal>
				<AVal Column="3" Row="19">0.498</AVal>
				<AVal Column="1" Row="20">0.3</AVal>
				<AVal Column="2" Row="20">0.498</AVal>
				<AVal Column="3" Row="20">0.498</AVal>
				<AVal Column="1" Row="21">0.365</AVal>
				<AVal Column="2" Row="21">0.498</AVal>
				<AVal Column="3" Row="21">0.498</AVal>
				<AVal Column="1" Row="22">0.115</AVal>
				<AVal Column="2" Row="22">0.498</AVal>
				<AVal Column="3" Row="22">0.498</AVal>
				<AVal Column="1" Row="23">0.15</AVal>
				<AVal Column="2" Row="23">0.498</AVal>
				<AVal Column="3" Row="23">0.498</AVal>
				<AVal Column="1" Row="24">0.175</AVal>
				<AVal Column="2" Row="24">0.498</AVal>
				<AVal Column="3" Row="24">0.498</AVal>
				<AVal Column="1" Row="25">0.2</AVal>
				<AVal Column="2" Row="25">0.498</AVal>
				<AVal Column="3" Row="25">0.498</AVal>
				<AVal Column="1" Row="26">0.24</AVal>
				<AVal Column="2" Row="26">0.498</AVal>
				<AVal Column="3" Row="26">0.498</AVal>
				<AVal Column="1" Row="27">0.3</AVal>
				<AVal Column="2" Row="27">0.498</AVal>
				<AVal Column="3" Row="27">0.498</AVal>
				<AVal Column="1" Row="28">0.365</AVal>
				<AVal Column="2" Row="28">0.498</AVal>
				<AVal Column="3" Row="28">0.498</AVal>
				<AVal Column="1" Row="29">0.15</AVal>
				<AVal Column="2" Row="29">0.498</AVal>
				<AVal Column="3" Row="29">0.498</AVal>
				<AVal Column="1" Row="30">0.175</AVal>
				<AVal Column="2" Row="30">0.498</AVal>
				<AVal Column="3" Row="30">0.498</AVal>
				<AVal Column="1" Row="31">0.2</AVal>
				<AVal Column="2" Row="31">0.498</AVal>
				<AVal Column="3" Row="31">0.498</AVal>
				<AVal Column="1" Row="32">0.24</AVal>
				<AVal Column="2" Row="32">0.498</AVal>
				<AVal Column="3" Row="32">0.498</AVal>
				<AVal Column="1" Row="33">0.115</AVal>
				<AVal Column="2" Row="33">0.498</AVal>
				<AVal Column="3" Row="33">0.498</AVal>
				<AVal Column="1" Row="34">0.15</AVal>
				<AVal Column="2" Row="34">0.498</AVal>
				<AVal Column="3" Row="34">0.498</AVal>
				<AVal Column="1" Row="35">0.175</AVal>
				<AVal Column="2" Row="35">0.498</AVal>
				<AVal Column="3" Row="35">0.498</AVal>
				<AVal Column="1" Row="36">0.24</AVal>
				<AVal Column="2" Row="36">0.498</AVal>
				<AVal Column="3" Row="36">0.498</AVal>
				<AVal Column="1" Row="37">0.115</AVal>
				<AVal Column="2" Row="37">0.498</AVal>
				<AVal Column="3" Row="37">0.498</AVal>
				<AVal Column="1" Row="38">0.15</AVal>
				<AVal Column="2" Row="38">0.498</AVal>
				<AVal Column="3" Row="38">0.498</AVal>
				<AVal Column="1" Row="39">0.175</AVal>
				<AVal Column="2" Row="39">0.498</AVal>
				<AVal Column="3" Row="39">0.498</AVal>
				<AVal Column="1" Row="40">0.24</AVal>
				<AVal Column="2" Row="40">0.498</AVal>
				<AVal Column="3" Row="40">0.498</AVal>
				<AVal Column="1" Row="41">0.15</AVal>
				<AVal Column="2" Row="41">0.498</AVal>
				<AVal Column="3" Row="41">0.498</AVal>
				<AVal Column="1" Row="42">0.175</AVal>
				<AVal Column="2" Row="42">0.498</AVal>
				<AVal Column="3" Row="42">0.498</AVal>
				<AVal Column="1" Row="43">0.2</AVal>
				<AVal Column="2" Row="43">0.498</AVal>
				<AVal Column="3" Row="43">0.498</AVal>
				<AVal Column="1" Row="44">0.24</AVal>
				<AVal Column="2" Row="44">0.498</AVal>
				<AVal Column="3" Row="44">0.498</AVal>
				<AVal Column="1" Row="45">0.15</AVal>
				<AVal Column="2" Row="45">0.498</AVal>
				<AVal Column="3" Row="45">0.498</AVal>
				<AVal Column="1" Row="46">0.175</AVal>
				<AVal Column="2" Row="46">0.498</AVal>
				<AVal Column="3" Row="46">0.498</AVal>
				<AVal Column="1" Row="47">0.2</AVal>
				<AVal Column="2" Row="47">0.498</AVal>
				<AVal Column="3" Row="47">0.498</AVal>
				<AVal Column="1" Row="48">0.24</AVal>
				<AVal Column="2" Row="48">0.498</AVal>
				<AVal Column="3" Row="48">0.498</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="datBrickWallType">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">2</AVal>
				<AVal Row="3">2</AVal>
				<AVal Row="4">2</AVal>
				<AVal Row="5">2</AVal>
				<AVal Row="6">2</AVal>
				<AVal Row="7">2</AVal>
				<AVal Row="8">1</AVal>
				<AVal Row="9">2</AVal>
				<AVal Row="10">2</AVal>
				<AVal Row="11">2</AVal>
				<AVal Row="12">2</AVal>
				<AVal Row="13">2</AVal>
				<AVal Row="14">2</AVal>
				<AVal Row="15">1</AVal>
				<AVal Row="16">2</AVal>
				<AVal Row="17">2</AVal>
				<AVal Row="18">2</AVal>
				<AVal Row="19">2</AVal>
				<AVal Row="20">2</AVal>
				<AVal Row="21">2</AVal>
				<AVal Row="22">1</AVal>
				<AVal Row="23">2</AVal>
				<AVal Row="24">2</AVal>
				<AVal Row="25">2</AVal>
				<AVal Row="26">2</AVal>
				<AVal Row="27">2</AVal>
				<AVal Row="28">2</AVal>
				<AVal Row="29">2</AVal>
				<AVal Row="30">2</AVal>
				<AVal Row="31">2</AVal>
				<AVal Row="32">2</AVal>
				<AVal Row="33">1</AVal>
				<AVal Row="34">2</AVal>
				<AVal Row="35">2</AVal>
				<AVal Row="36">2</AVal>
				<AVal Row="37">1</AVal>
				<AVal Row="38">2</AVal>
				<AVal Row="39">2</AVal>
				<AVal Row="40">2</AVal>
				<AVal Row="41">2</AVal>
				<AVal Row="42">2</AVal>
				<AVal Row="43">2</AVal>
				<AVal Row="44">2</AVal>
				<AVal Row="45">2</AVal>
				<AVal Row="46">2</AVal>
				<AVal Row="47">2</AVal>
				<AVal Row="48">2</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="datBrickHasEndElem">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
				<AVal Row="17">0</AVal>
				<AVal Row="18">0</AVal>
				<AVal Row="19">0</AVal>
				<AVal Row="20">0</AVal>
				<AVal Row="21">0</AVal>
				<AVal Row="22">0</AVal>
				<AVal Row="23">0</AVal>
				<AVal Row="24">0</AVal>
				<AVal Row="25">0</AVal>
				<AVal Row="26">0</AVal>
				<AVal Row="27">0</AVal>
				<AVal Row="28">0</AVal>
				<AVal Row="29">0</AVal>
				<AVal Row="30">0</AVal>
				<AVal Row="31">0</AVal>
				<AVal Row="32">0</AVal>
				<AVal Row="33">0</AVal>
				<AVal Row="34">0</AVal>
				<AVal Row="35">0</AVal>
				<AVal Row="36">0</AVal>
				<AVal Row="37">0</AVal>
				<AVal Row="38">0</AVal>
				<AVal Row="39">0</AVal>
				<AVal Row="40">0</AVal>
				<AVal Row="41">0</AVal>
				<AVal Row="42">0</AVal>
				<AVal Row="43">0</AVal>
				<AVal Row="44">0</AVal>
				<AVal Row="45">0</AVal>
				<AVal Row="46">0</AVal>
				<AVal Row="47">0</AVal>
				<AVal Row="48">0</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="datBrickEndElemIdx">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
				<AVal Row="17">0</AVal>
				<AVal Row="18">0</AVal>
				<AVal Row="19">0</AVal>
				<AVal Row="20">0</AVal>
				<AVal Row="21">0</AVal>
				<AVal Row="22">0</AVal>
				<AVal Row="23">0</AVal>
				<AVal Row="24">0</AVal>
				<AVal Row="25">0</AVal>
				<AVal Row="26">0</AVal>
				<AVal Row="27">0</AVal>
				<AVal Row="28">0</AVal>
				<AVal Row="29">0</AVal>
				<AVal Row="30">0</AVal>
				<AVal Row="31">0</AVal>
				<AVal Row="32">0</AVal>
				<AVal Row="33">0</AVal>
				<AVal Row="34">0</AVal>
				<AVal Row="35">0</AVal>
				<AVal Row="36">0</AVal>
				<AVal Row="37">0</AVal>
				<AVal Row="38">0</AVal>
				<AVal Row="39">0</AVal>
				<AVal Row="40">0</AVal>
				<AVal Row="41">0</AVal>
				<AVal Row="42">0</AVal>
				<AVal Row="43">0</AVal>
				<AVal Row="44">0</AVal>
				<AVal Row="45">0</AVal>
				<AVal Row="46">0</AVal>
				<AVal Row="47">0</AVal>
				<AVal Row="48">0</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="datBrickWindowIdx">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
				<AVal Row="17">0</AVal>
				<AVal Row="18">0</AVal>
				<AVal Row="19">0</AVal>
				<AVal Row="20">0</AVal>
				<AVal Row="21">0</AVal>
				<AVal Row="22">0</AVal>
				<AVal Row="23">0</AVal>
				<AVal Row="24">0</AVal>
				<AVal Row="25">0</AVal>
				<AVal Row="26">0</AVal>
				<AVal Row="27">0</AVal>
				<AVal Row="28">0</AVal>
				<AVal Row="29">0</AVal>
				<AVal Row="30">0</AVal>
				<AVal Row="31">0</AVal>
				<AVal Row="32">0</AVal>
				<AVal Row="33">0</AVal>
				<AVal Row="34">0</AVal>
				<AVal Row="35">0</AVal>
				<AVal Row="36">0</AVal>
				<AVal Row="37">0</AVal>
				<AVal Row="38">0</AVal>
				<AVal Row="39">0</AVal>
				<AVal Row="40">0</AVal>
				<AVal Row="41">0</AVal>
				<AVal Row="42">0</AVal>
				<AVal Row="43">0</AVal>
				<AVal Row="44">0</AVal>
				<AVal Row="45">0</AVal>
				<AVal Row="46">0</AVal>
				<AVal Row="47">0</AVal>
				<AVal Row="48">0</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="datBrickHalfIdx">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
				<AVal Row="17">0</AVal>
				<AVal Row="18">0</AVal>
				<AVal Row="19">0</AVal>
				<AVal Row="20">0</AVal>
				<AVal Row="21">0</AVal>
				<AVal Row="22">0</AVal>
				<AVal Row="23">0</AVal>
				<AVal Row="24">0</AVal>
				<AVal Row="25">0</AVal>
				<AVal Row="26">0</AVal>
				<AVal Row="27">0</AVal>
				<AVal Row="28">0</AVal>
				<AVal Row="29">0</AVal>
				<AVal Row="30">0</AVal>
				<AVal Row="31">0</AVal>
				<AVal Row="32">0</AVal>
				<AVal Row="33">0</AVal>
				<AVal Row="34">0</AVal>
				<AVal Row="35">0</AVal>
				<AVal Row="36">0</AVal>
				<AVal Row="37">0</AVal>
				<AVal Row="38">0</AVal>
				<AVal Row="39">0</AVal>
				<AVal Row="40">0</AVal>
				<AVal Row="41">0</AVal>
				<AVal Row="42">0</AVal>
				<AVal Row="43">0</AVal>
				<AVal Row="44">0</AVal>
				<AVal Row="45">0</AVal>
				<AVal Row="46">0</AVal>
				<AVal Row="47">0</AVal>
				<AVal Row="48">0</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="datBrickHasProfile">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
				<AVal Row="17">0</AVal>
				<AVal Row="18">0</AVal>
				<AVal Row="19">0</AVal>
				<AVal Row="20">0</AVal>
				<AVal Row="21">0</AVal>
				<AVal Row="22">0</AVal>
				<AVal Row="23">0</AVal>
				<AVal Row="24">0</AVal>
				<AVal Row="25">0</AVal>
				<AVal Row="26">0</AVal>
				<AVal Row="27">0</AVal>
				<AVal Row="28">0</AVal>
				<AVal Row="29">0</AVal>
				<AVal Row="30">0</AVal>
				<AVal Row="31">0</AVal>
				<AVal Row="32">0</AVal>
				<AVal Row="33">0</AVal>
				<AVal Row="34">0</AVal>
				<AVal Row="35">0</AVal>
				<AVal Row="36">0</AVal>
				<AVal Row="37">0</AVal>
				<AVal Row="38">0</AVal>
				<AVal Row="39">0</AVal>
				<AVal Row="40">0</AVal>
				<AVal Row="41">0</AVal>
				<AVal Row="42">0</AVal>
				<AVal Row="43">0</AVal>
				<AVal Row="44">0</AVal>
				<AVal Row="45">0</AVal>
				<AVal Row="46">0</AVal>
				<AVal Row="47">0</AVal>
				<AVal Row="48">0</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="datBrickColumn">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
				<AVal Row="17">0</AVal>
				<AVal Row="18">0</AVal>
				<AVal Row="19">0</AVal>
				<AVal Row="20">0</AVal>
				<AVal Row="21">0</AVal>
				<AVal Row="22">0</AVal>
				<AVal Row="23">0</AVal>
				<AVal Row="24">0</AVal>
				<AVal Row="25">0</AVal>
				<AVal Row="26">0</AVal>
				<AVal Row="27">0</AVal>
				<AVal Row="28">0</AVal>
				<AVal Row="29">0</AVal>
				<AVal Row="30">0</AVal>
				<AVal Row="31">0</AVal>
				<AVal Row="32">0</AVal>
				<AVal Row="33">0</AVal>
				<AVal Row="34">0</AVal>
				<AVal Row="35">0</AVal>
				<AVal Row="36">0</AVal>
				<AVal Row="37">0</AVal>
				<AVal Row="38">0</AVal>
				<AVal Row="39">0</AVal>
				<AVal Row="40">0</AVal>
				<AVal Row="41">0</AVal>
				<AVal Row="42">0</AVal>
				<AVal Row="43">0</AVal>
				<AVal Row="44">0</AVal>
				<AVal Row="45">0</AVal>
				<AVal Row="46">0</AVal>
				<AVal Row="47">0</AVal>
				<AVal Row="48">0</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="datBrickEndElemWith">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0.498</AVal>
				<AVal Row="2">0.498</AVal>
				<AVal Row="3">0.498</AVal>
				<AVal Row="4">0.498</AVal>
				<AVal Row="5">0.498</AVal>
				<AVal Row="6">0.498</AVal>
				<AVal Row="7">0.498</AVal>
				<AVal Row="8">0.498</AVal>
				<AVal Row="9">0.498</AVal>
				<AVal Row="10">0.498</AVal>
				<AVal Row="11">0.498</AVal>
				<AVal Row="12">0.498</AVal>
				<AVal Row="13">0.498</AVal>
				<AVal Row="14">0.498</AVal>
				<AVal Row="15">0.498</AVal>
				<AVal Row="16">0.498</AVal>
				<AVal Row="17">0.498</AVal>
				<AVal Row="18">0.498</AVal>
				<AVal Row="19">0.498</AVal>
				<AVal Row="20">0.498</AVal>
				<AVal Row="21">0.498</AVal>
				<AVal Row="22">0.498</AVal>
				<AVal Row="23">0.498</AVal>
				<AVal Row="24">0.498</AVal>
				<AVal Row="25">0.498</AVal>
				<AVal Row="26">0.498</AVal>
				<AVal Row="27">0.498</AVal>
				<AVal Row="28">0.498</AVal>
				<AVal Row="29">0.498</AVal>
				<AVal Row="30">0.498</AVal>
				<AVal Row="31">0.498</AVal>
				<AVal Row="32">0.498</AVal>
				<AVal Row="33">0.498</AVal>
				<AVal Row="34">0.498</AVal>
				<AVal Row="35">0.498</AVal>
				<AVal Row="36">0.498</AVal>
				<AVal Row="37">0.498</AVal>
				<AVal Row="38">0.498</AVal>
				<AVal Row="39">0.498</AVal>
				<AVal Row="40">0.498</AVal>
				<AVal Row="41">0.498</AVal>
				<AVal Row="42">0.498</AVal>
				<AVal Row="43">0.498</AVal>
				<AVal Row="44">0.498</AVal>
				<AVal Row="45">0.498</AVal>
				<AVal Row="46">0.498</AVal>
				<AVal Row="47">0.498</AVal>
				<AVal Row="48">0.498</AVal>
			</ArrayValues>
		</Length>
		<Length Name="datBrickHalfElemHeight">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
				<AVal Row="17">0</AVal>
				<AVal Row="18">0</AVal>
				<AVal Row="19">0</AVal>
				<AVal Row="20">0</AVal>
				<AVal Row="21">0</AVal>
				<AVal Row="22">0</AVal>
				<AVal Row="23">0</AVal>
				<AVal Row="24">0</AVal>
				<AVal Row="25">0</AVal>
				<AVal Row="26">0</AVal>
				<AVal Row="27">0</AVal>
				<AVal Row="28">0</AVal>
				<AVal Row="29">0</AVal>
				<AVal Row="30">0</AVal>
				<AVal Row="31">0</AVal>
				<AVal Row="32">0</AVal>
				<AVal Row="33">0</AVal>
				<AVal Row="34">0</AVal>
				<AVal Row="35">0</AVal>
				<AVal Row="36">0</AVal>
				<AVal Row="37">0</AVal>
				<AVal Row="38">0</AVal>
				<AVal Row="39">0</AVal>
				<AVal Row="40">0</AVal>
				<AVal Row="41">0</AVal>
				<AVal Row="42">0</AVal>
				<AVal Row="43">0</AVal>
				<AVal Row="44">0</AVal>
				<AVal Row="45">0</AVal>
				<AVal Row="46">0</AVal>
				<AVal Row="47">0</AVal>
				<AVal Row="48">0</AVal>
			</ArrayValues>
		</Length>
		<RealNum Name="datBrickLambdaDry">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
				<AVal Row="17">0</AVal>
				<AVal Row="18">0</AVal>
				<AVal Row="19">0</AVal>
				<AVal Row="20">0</AVal>
				<AVal Row="21">0</AVal>
				<AVal Row="22">0</AVal>
				<AVal Row="23">0</AVal>
				<AVal Row="24">0</AVal>
				<AVal Row="25">0</AVal>
				<AVal Row="26">0</AVal>
				<AVal Row="27">0</AVal>
				<AVal Row="28">0</AVal>
				<AVal Row="29">0</AVal>
				<AVal Row="30">0</AVal>
				<AVal Row="31">0</AVal>
				<AVal Row="32">0</AVal>
				<AVal Row="33">0</AVal>
				<AVal Row="34">0</AVal>
				<AVal Row="35">0</AVal>
				<AVal Row="36">0</AVal>
				<AVal Row="37">0</AVal>
				<AVal Row="38">0</AVal>
				<AVal Row="39">0</AVal>
				<AVal Row="40">0</AVal>
				<AVal Row="41">0</AVal>
				<AVal Row="42">0</AVal>
				<AVal Row="43">0</AVal>
				<AVal Row="44">0</AVal>
				<AVal Row="45">0</AVal>
				<AVal Row="46">0</AVal>
				<AVal Row="47">0</AVal>
				<AVal Row="48">0</AVal>
			</ArrayValues>
		</RealNum>
		<RealNum Name="datBrickLambdaNormal">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
				<AVal Row="17">0</AVal>
				<AVal Row="18">0</AVal>
				<AVal Row="19">0</AVal>
				<AVal Row="20">0</AVal>
				<AVal Row="21">0</AVal>
				<AVal Row="22">0</AVal>
				<AVal Row="23">0</AVal>
				<AVal Row="24">0</AVal>
				<AVal Row="25">0</AVal>
				<AVal Row="26">0</AVal>
				<AVal Row="27">0</AVal>
				<AVal Row="28">0</AVal>
				<AVal Row="29">0</AVal>
				<AVal Row="30">0</AVal>
				<AVal Row="31">0</AVal>
				<AVal Row="32">0</AVal>
				<AVal Row="33">0</AVal>
				<AVal Row="34">0</AVal>
				<AVal Row="35">0</AVal>
				<AVal Row="36">0</AVal>
				<AVal Row="37">0</AVal>
				<AVal Row="38">0</AVal>
				<AVal Row="39">0</AVal>
				<AVal Row="40">0</AVal>
				<AVal Row="41">0</AVal>
				<AVal Row="42">0</AVal>
				<AVal Row="43">0</AVal>
				<AVal Row="44">0</AVal>
				<AVal Row="45">0</AVal>
				<AVal Row="46">0</AVal>
				<AVal Row="47">0</AVal>
				<AVal Row="48">0</AVal>
			</ArrayValues>
		</RealNum>
		<String Name="datBrickCert">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
				<AVal Row="3"><![CDATA[""]]></AVal>
				<AVal Row="4"><![CDATA[""]]></AVal>
				<AVal Row="5"><![CDATA[""]]></AVal>
				<AVal Row="6"><![CDATA[""]]></AVal>
				<AVal Row="7"><![CDATA[""]]></AVal>
				<AVal Row="8"><![CDATA[""]]></AVal>
				<AVal Row="9"><![CDATA[""]]></AVal>
				<AVal Row="10"><![CDATA[""]]></AVal>
				<AVal Row="11"><![CDATA[""]]></AVal>
				<AVal Row="12"><![CDATA[""]]></AVal>
				<AVal Row="13"><![CDATA[""]]></AVal>
				<AVal Row="14"><![CDATA[""]]></AVal>
				<AVal Row="15"><![CDATA[""]]></AVal>
				<AVal Row="16"><![CDATA[""]]></AVal>
				<AVal Row="17"><![CDATA[""]]></AVal>
				<AVal Row="18"><![CDATA[""]]></AVal>
				<AVal Row="19"><![CDATA[""]]></AVal>
				<AVal Row="20"><![CDATA[""]]></AVal>
				<AVal Row="21"><![CDATA[""]]></AVal>
				<AVal Row="22"><![CDATA[""]]></AVal>
				<AVal Row="23"><![CDATA[""]]></AVal>
				<AVal Row="24"><![CDATA[""]]></AVal>
				<AVal Row="25"><![CDATA[""]]></AVal>
				<AVal Row="26"><![CDATA[""]]></AVal>
				<AVal Row="27"><![CDATA[""]]></AVal>
				<AVal Row="28"><![CDATA[""]]></AVal>
				<AVal Row="29"><![CDATA[""]]></AVal>
				<AVal Row="30"><![CDATA[""]]></AVal>
				<AVal Row="31"><![CDATA[""]]></AVal>
				<AVal Row="32"><![CDATA[""]]></AVal>
				<AVal Row="33"><![CDATA[""]]></AVal>
				<AVal Row="34"><![CDATA[""]]></AVal>
				<AVal Row="35"><![CDATA[""]]></AVal>
				<AVal Row="36"><![CDATA[""]]></AVal>
				<AVal Row="37"><![CDATA[""]]></AVal>
				<AVal Row="38"><![CDATA[""]]></AVal>
				<AVal Row="39"><![CDATA[""]]></AVal>
				<AVal Row="40"><![CDATA[""]]></AVal>
				<AVal Row="41"><![CDATA[""]]></AVal>
				<AVal Row="42"><![CDATA[""]]></AVal>
				<AVal Row="43"><![CDATA[""]]></AVal>
				<AVal Row="44"><![CDATA[""]]></AVal>
				<AVal Row="45"><![CDATA[""]]></AVal>
				<AVal Row="46"><![CDATA[""]]></AVal>
				<AVal Row="47"><![CDATA[""]]></AVal>
				<AVal Row="48"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<RealNum Name="datBrickNperMm2">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">9.4</AVal>
				<AVal Row="2">9.4</AVal>
				<AVal Row="3">9.4</AVal>
				<AVal Row="4">9.4</AVal>
				<AVal Row="5">9.4</AVal>
				<AVal Row="6">9.4</AVal>
				<AVal Row="7">9.4</AVal>
				<AVal Row="8">11.2</AVal>
				<AVal Row="9">11.2</AVal>
				<AVal Row="10">11.2</AVal>
				<AVal Row="11">11.2</AVal>
				<AVal Row="12">11.2</AVal>
				<AVal Row="13">11.2</AVal>
				<AVal Row="14">11.2</AVal>
				<AVal Row="15">12.9</AVal>
				<AVal Row="16">12.9</AVal>
				<AVal Row="17">12.9</AVal>
				<AVal Row="18">12.9</AVal>
				<AVal Row="19">12.9</AVal>
				<AVal Row="20">12.9</AVal>
				<AVal Row="21">12.9</AVal>
				<AVal Row="22">12.9</AVal>
				<AVal Row="23">12.9</AVal>
				<AVal Row="24">12.9</AVal>
				<AVal Row="25">12.9</AVal>
				<AVal Row="26">12.9</AVal>
				<AVal Row="27">12.9</AVal>
				<AVal Row="28">12.9</AVal>
				<AVal Row="29">12.9</AVal>
				<AVal Row="30">12.9</AVal>
				<AVal Row="31">12.9</AVal>
				<AVal Row="32">12.9</AVal>
				<AVal Row="33">7</AVal>
				<AVal Row="34">7</AVal>
				<AVal Row="35">7</AVal>
				<AVal Row="36">7</AVal>
				<AVal Row="37">10.5</AVal>
				<AVal Row="38">10.5</AVal>
				<AVal Row="39">10.5</AVal>
				<AVal Row="40">10.5</AVal>
				<AVal Row="41">7</AVal>
				<AVal Row="42">7</AVal>
				<AVal Row="43">7</AVal>
				<AVal Row="44">7</AVal>
				<AVal Row="45">10.5</AVal>
				<AVal Row="46">10.5</AVal>
				<AVal Row="47">10.5</AVal>
				<AVal Row="48">10.5</AVal>
			</ArrayValues>
		</RealNum>
		<RealNum Name="datBrickKgPerM3">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
				<AVal Row="17">0</AVal>
				<AVal Row="18">0</AVal>
				<AVal Row="19">0</AVal>
				<AVal Row="20">0</AVal>
				<AVal Row="21">0</AVal>
				<AVal Row="22">0</AVal>
				<AVal Row="23">0</AVal>
				<AVal Row="24">0</AVal>
				<AVal Row="25">0</AVal>
				<AVal Row="26">0</AVal>
				<AVal Row="27">0</AVal>
				<AVal Row="28">0</AVal>
				<AVal Row="29">0</AVal>
				<AVal Row="30">0</AVal>
				<AVal Row="31">0</AVal>
				<AVal Row="32">0</AVal>
				<AVal Row="33">0</AVal>
				<AVal Row="34">0</AVal>
				<AVal Row="35">0</AVal>
				<AVal Row="36">0</AVal>
				<AVal Row="37">0</AVal>
				<AVal Row="38">0</AVal>
				<AVal Row="39">0</AVal>
				<AVal Row="40">0</AVal>
				<AVal Row="41">0</AVal>
				<AVal Row="42">0</AVal>
				<AVal Row="43">0</AVal>
				<AVal Row="44">0</AVal>
				<AVal Row="45">0</AVal>
				<AVal Row="46">0</AVal>
				<AVal Row="47">0</AVal>
				<AVal Row="48">0</AVal>
			</ArrayValues>
		</RealNum>
		<RealNum Name="datBrickKgPerPc">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
				<AVal Row="17">0</AVal>
				<AVal Row="18">0</AVal>
				<AVal Row="19">0</AVal>
				<AVal Row="20">0</AVal>
				<AVal Row="21">0</AVal>
				<AVal Row="22">0</AVal>
				<AVal Row="23">0</AVal>
				<AVal Row="24">0</AVal>
				<AVal Row="25">0</AVal>
				<AVal Row="26">0</AVal>
				<AVal Row="27">0</AVal>
				<AVal Row="28">0</AVal>
				<AVal Row="29">0</AVal>
				<AVal Row="30">0</AVal>
				<AVal Row="31">0</AVal>
				<AVal Row="32">0</AVal>
				<AVal Row="33">0</AVal>
				<AVal Row="34">0</AVal>
				<AVal Row="35">0</AVal>
				<AVal Row="36">0</AVal>
				<AVal Row="37">0</AVal>
				<AVal Row="38">0</AVal>
				<AVal Row="39">0</AVal>
				<AVal Row="40">0</AVal>
				<AVal Row="41">0</AVal>
				<AVal Row="42">0</AVal>
				<AVal Row="43">0</AVal>
				<AVal Row="44">0</AVal>
				<AVal Row="45">0</AVal>
				<AVal Row="46">0</AVal>
				<AVal Row="47">0</AVal>
				<AVal Row="48">0</AVal>
			</ArrayValues>
		</RealNum>
		<RealNum Name="datBrickPcPerM2">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
				<AVal Row="17">0</AVal>
				<AVal Row="18">0</AVal>
				<AVal Row="19">0</AVal>
				<AVal Row="20">0</AVal>
				<AVal Row="21">0</AVal>
				<AVal Row="22">0</AVal>
				<AVal Row="23">0</AVal>
				<AVal Row="24">0</AVal>
				<AVal Row="25">0</AVal>
				<AVal Row="26">0</AVal>
				<AVal Row="27">0</AVal>
				<AVal Row="28">0</AVal>
				<AVal Row="29">0</AVal>
				<AVal Row="30">0</AVal>
				<AVal Row="31">0</AVal>
				<AVal Row="32">0</AVal>
				<AVal Row="33">0</AVal>
				<AVal Row="34">0</AVal>
				<AVal Row="35">0</AVal>
				<AVal Row="36">0</AVal>
				<AVal Row="37">0</AVal>
				<AVal Row="38">0</AVal>
				<AVal Row="39">0</AVal>
				<AVal Row="40">0</AVal>
				<AVal Row="41">0</AVal>
				<AVal Row="42">0</AVal>
				<AVal Row="43">0</AVal>
				<AVal Row="44">0</AVal>
				<AVal Row="45">0</AVal>
				<AVal Row="46">0</AVal>
				<AVal Row="47">0</AVal>
				<AVal Row="48">0</AVal>
			</ArrayValues>
		</RealNum>
		<RealNum Name="datBrickM2PerPc">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
				<AVal Row="17">0</AVal>
				<AVal Row="18">0</AVal>
				<AVal Row="19">0</AVal>
				<AVal Row="20">0</AVal>
				<AVal Row="21">0</AVal>
				<AVal Row="22">0</AVal>
				<AVal Row="23">0</AVal>
				<AVal Row="24">0</AVal>
				<AVal Row="25">0</AVal>
				<AVal Row="26">0</AVal>
				<AVal Row="27">0</AVal>
				<AVal Row="28">0</AVal>
				<AVal Row="29">0</AVal>
				<AVal Row="30">0</AVal>
				<AVal Row="31">0</AVal>
				<AVal Row="32">0</AVal>
				<AVal Row="33">0</AVal>
				<AVal Row="34">0</AVal>
				<AVal Row="35">0</AVal>
				<AVal Row="36">0</AVal>
				<AVal Row="37">0</AVal>
				<AVal Row="38">0</AVal>
				<AVal Row="39">0</AVal>
				<AVal Row="40">0</AVal>
				<AVal Row="41">0</AVal>
				<AVal Row="42">0</AVal>
				<AVal Row="43">0</AVal>
				<AVal Row="44">0</AVal>
				<AVal Row="45">0</AVal>
				<AVal Row="46">0</AVal>
				<AVal Row="47">0</AVal>
				<AVal Row="48">0</AVal>
			</ArrayValues>
		</RealNum>
		<RealNum Name="datBrickGrossDensity">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
				<AVal Row="17">0</AVal>
				<AVal Row="18">0</AVal>
				<AVal Row="19">0</AVal>
				<AVal Row="20">0</AVal>
				<AVal Row="21">0</AVal>
				<AVal Row="22">0</AVal>
				<AVal Row="23">0</AVal>
				<AVal Row="24">0</AVal>
				<AVal Row="25">0</AVal>
				<AVal Row="26">0</AVal>
				<AVal Row="27">0</AVal>
				<AVal Row="28">0</AVal>
				<AVal Row="29">0</AVal>
				<AVal Row="30">0</AVal>
				<AVal Row="31">0</AVal>
				<AVal Row="32">0</AVal>
				<AVal Row="33">0</AVal>
				<AVal Row="34">0</AVal>
				<AVal Row="35">0</AVal>
				<AVal Row="36">0</AVal>
				<AVal Row="37">0</AVal>
				<AVal Row="38">0</AVal>
				<AVal Row="39">0</AVal>
				<AVal Row="40">0</AVal>
				<AVal Row="41">0</AVal>
				<AVal Row="42">0</AVal>
				<AVal Row="43">0</AVal>
				<AVal Row="44">0</AVal>
				<AVal Row="45">0</AVal>
				<AVal Row="46">0</AVal>
				<AVal Row="47">0</AVal>
				<AVal Row="48">0</AVal>
			</ArrayValues>
		</RealNum>
		<RealNum Name="datBrickShearStrength">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
				<AVal Row="17">0</AVal>
				<AVal Row="18">0</AVal>
				<AVal Row="19">0</AVal>
				<AVal Row="20">0</AVal>
				<AVal Row="21">0</AVal>
				<AVal Row="22">0</AVal>
				<AVal Row="23">0</AVal>
				<AVal Row="24">0</AVal>
				<AVal Row="25">0</AVal>
				<AVal Row="26">0</AVal>
				<AVal Row="27">0</AVal>
				<AVal Row="28">0</AVal>
				<AVal Row="29">0</AVal>
				<AVal Row="30">0</AVal>
				<AVal Row="31">0</AVal>
				<AVal Row="32">0</AVal>
				<AVal Row="33">0</AVal>
				<AVal Row="34">0</AVal>
				<AVal Row="35">0</AVal>
				<AVal Row="36">0</AVal>
				<AVal Row="37">0</AVal>
				<AVal Row="38">0</AVal>
				<AVal Row="39">0</AVal>
				<AVal Row="40">0</AVal>
				<AVal Row="41">0</AVal>
				<AVal Row="42">0</AVal>
				<AVal Row="43">0</AVal>
				<AVal Row="44">0</AVal>
				<AVal Row="45">0</AVal>
				<AVal Row="46">0</AVal>
				<AVal Row="47">0</AVal>
				<AVal Row="48">0</AVal>
			</ArrayValues>
		</RealNum>
		<RealNum Name="datBrickFk">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
				<AVal Row="17">0</AVal>
				<AVal Row="18">0</AVal>
				<AVal Row="19">0</AVal>
				<AVal Row="20">0</AVal>
				<AVal Row="21">0</AVal>
				<AVal Row="22">0</AVal>
				<AVal Row="23">0</AVal>
				<AVal Row="24">0</AVal>
				<AVal Row="25">0</AVal>
				<AVal Row="26">0</AVal>
				<AVal Row="27">0</AVal>
				<AVal Row="28">0</AVal>
				<AVal Row="29">0</AVal>
				<AVal Row="30">0</AVal>
				<AVal Row="31">0</AVal>
				<AVal Row="32">0</AVal>
				<AVal Row="33">0</AVal>
				<AVal Row="34">0</AVal>
				<AVal Row="35">0</AVal>
				<AVal Row="36">0</AVal>
				<AVal Row="37">0</AVal>
				<AVal Row="38">0</AVal>
				<AVal Row="39">0</AVal>
				<AVal Row="40">0</AVal>
				<AVal Row="41">0</AVal>
				<AVal Row="42">0</AVal>
				<AVal Row="43">0</AVal>
				<AVal Row="44">0</AVal>
				<AVal Row="45">0</AVal>
				<AVal Row="46">0</AVal>
				<AVal Row="47">0</AVal>
				<AVal Row="48">0</AVal>
			</ArrayValues>
		</RealNum>
		<RealNum Name="datBrickKNperm3">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">18</AVal>
				<AVal Row="2">18</AVal>
				<AVal Row="3">18</AVal>
				<AVal Row="4">18</AVal>
				<AVal Row="5">18</AVal>
				<AVal Row="6">18</AVal>
				<AVal Row="7">18</AVal>
				<AVal Row="8">18</AVal>
				<AVal Row="9">18</AVal>
				<AVal Row="10">18</AVal>
				<AVal Row="11">18</AVal>
				<AVal Row="12">18</AVal>
				<AVal Row="13">18</AVal>
				<AVal Row="14">18</AVal>
				<AVal Row="15">18</AVal>
				<AVal Row="16">18</AVal>
				<AVal Row="17">18</AVal>
				<AVal Row="18">18</AVal>
				<AVal Row="19">18</AVal>
				<AVal Row="20">18</AVal>
				<AVal Row="21">18</AVal>
				<AVal Row="22">20</AVal>
				<AVal Row="23">20</AVal>
				<AVal Row="24">20</AVal>
				<AVal Row="25">20</AVal>
				<AVal Row="26">20</AVal>
				<AVal Row="27">20</AVal>
				<AVal Row="28">20</AVal>
				<AVal Row="29">22</AVal>
				<AVal Row="30">22</AVal>
				<AVal Row="31">22</AVal>
				<AVal Row="32">22</AVal>
				<AVal Row="33">18</AVal>
				<AVal Row="34">18</AVal>
				<AVal Row="35">18</AVal>
				<AVal Row="36">18</AVal>
				<AVal Row="37">18</AVal>
				<AVal Row="38">18</AVal>
				<AVal Row="39">18</AVal>
				<AVal Row="40">18</AVal>
				<AVal Row="41">20</AVal>
				<AVal Row="42">20</AVal>
				<AVal Row="43">20</AVal>
				<AVal Row="44">20</AVal>
				<AVal Row="45">20</AVal>
				<AVal Row="46">20</AVal>
				<AVal Row="47">20</AVal>
				<AVal Row="48">20</AVal>
			</ArrayValues>
		</RealNum>
		<RealNum Name="datBrickMortarPerM2">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
				<AVal Row="17">0</AVal>
				<AVal Row="18">0</AVal>
				<AVal Row="19">0</AVal>
				<AVal Row="20">0</AVal>
				<AVal Row="21">0</AVal>
				<AVal Row="22">0</AVal>
				<AVal Row="23">0</AVal>
				<AVal Row="24">0</AVal>
				<AVal Row="25">0</AVal>
				<AVal Row="26">0</AVal>
				<AVal Row="27">0</AVal>
				<AVal Row="28">0</AVal>
				<AVal Row="29">0</AVal>
				<AVal Row="30">0</AVal>
				<AVal Row="31">0</AVal>
				<AVal Row="32">0</AVal>
				<AVal Row="33">0</AVal>
				<AVal Row="34">0</AVal>
				<AVal Row="35">0</AVal>
				<AVal Row="36">0</AVal>
				<AVal Row="37">0</AVal>
				<AVal Row="38">0</AVal>
				<AVal Row="39">0</AVal>
				<AVal Row="40">0</AVal>
				<AVal Row="41">0</AVal>
				<AVal Row="42">0</AVal>
				<AVal Row="43">0</AVal>
				<AVal Row="44">0</AVal>
				<AVal Row="45">0</AVal>
				<AVal Row="46">0</AVal>
				<AVal Row="47">0</AVal>
				<AVal Row="48">0</AVal>
			</ArrayValues>
		</RealNum>
		<String Name="datBrickMortarPerM2Str">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
				<AVal Row="3"><![CDATA[""]]></AVal>
				<AVal Row="4"><![CDATA[""]]></AVal>
				<AVal Row="5"><![CDATA[""]]></AVal>
				<AVal Row="6"><![CDATA[""]]></AVal>
				<AVal Row="7"><![CDATA[""]]></AVal>
				<AVal Row="8"><![CDATA[""]]></AVal>
				<AVal Row="9"><![CDATA[""]]></AVal>
				<AVal Row="10"><![CDATA[""]]></AVal>
				<AVal Row="11"><![CDATA[""]]></AVal>
				<AVal Row="12"><![CDATA[""]]></AVal>
				<AVal Row="13"><![CDATA[""]]></AVal>
				<AVal Row="14"><![CDATA[""]]></AVal>
				<AVal Row="15"><![CDATA[""]]></AVal>
				<AVal Row="16"><![CDATA[""]]></AVal>
				<AVal Row="17"><![CDATA[""]]></AVal>
				<AVal Row="18"><![CDATA[""]]></AVal>
				<AVal Row="19"><![CDATA[""]]></AVal>
				<AVal Row="20"><![CDATA[""]]></AVal>
				<AVal Row="21"><![CDATA[""]]></AVal>
				<AVal Row="22"><![CDATA[""]]></AVal>
				<AVal Row="23"><![CDATA[""]]></AVal>
				<AVal Row="24"><![CDATA[""]]></AVal>
				<AVal Row="25"><![CDATA[""]]></AVal>
				<AVal Row="26"><![CDATA[""]]></AVal>
				<AVal Row="27"><![CDATA[""]]></AVal>
				<AVal Row="28"><![CDATA[""]]></AVal>
				<AVal Row="29"><![CDATA[""]]></AVal>
				<AVal Row="30"><![CDATA[""]]></AVal>
				<AVal Row="31"><![CDATA[""]]></AVal>
				<AVal Row="32"><![CDATA[""]]></AVal>
				<AVal Row="33"><![CDATA[""]]></AVal>
				<AVal Row="34"><![CDATA[""]]></AVal>
				<AVal Row="35"><![CDATA[""]]></AVal>
				<AVal Row="36"><![CDATA[""]]></AVal>
				<AVal Row="37"><![CDATA[""]]></AVal>
				<AVal Row="38"><![CDATA[""]]></AVal>
				<AVal Row="39"><![CDATA[""]]></AVal>
				<AVal Row="40"><![CDATA[""]]></AVal>
				<AVal Row="41"><![CDATA[""]]></AVal>
				<AVal Row="42"><![CDATA[""]]></AVal>
				<AVal Row="43"><![CDATA[""]]></AVal>
				<AVal Row="44"><![CDATA[""]]></AVal>
				<AVal Row="45"><![CDATA[""]]></AVal>
				<AVal Row="46"><![CDATA[""]]></AVal>
				<AVal Row="47"><![CDATA[""]]></AVal>
				<AVal Row="48"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<RealNum Name="datBrickWorkHperStructure">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
				<AVal Row="17">0</AVal>
				<AVal Row="18">0</AVal>
				<AVal Row="19">0</AVal>
				<AVal Row="20">0</AVal>
				<AVal Row="21">0</AVal>
				<AVal Row="22">0</AVal>
				<AVal Row="23">0</AVal>
				<AVal Row="24">0</AVal>
				<AVal Row="25">0</AVal>
				<AVal Row="26">0</AVal>
				<AVal Row="27">0</AVal>
				<AVal Row="28">0</AVal>
				<AVal Row="29">0</AVal>
				<AVal Row="30">0</AVal>
				<AVal Row="31">0</AVal>
				<AVal Row="32">0</AVal>
				<AVal Row="33">0</AVal>
				<AVal Row="34">0</AVal>
				<AVal Row="35">0</AVal>
				<AVal Row="36">0</AVal>
				<AVal Row="37">0</AVal>
				<AVal Row="38">0</AVal>
				<AVal Row="39">0</AVal>
				<AVal Row="40">0</AVal>
				<AVal Row="41">0</AVal>
				<AVal Row="42">0</AVal>
				<AVal Row="43">0</AVal>
				<AVal Row="44">0</AVal>
				<AVal Row="45">0</AVal>
				<AVal Row="46">0</AVal>
				<AVal Row="47">0</AVal>
				<AVal Row="48">0</AVal>
			</ArrayValues>
		</RealNum>
		<RealNum Name="datBrickWorkHperFull">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
				<AVal Row="17">0</AVal>
				<AVal Row="18">0</AVal>
				<AVal Row="19">0</AVal>
				<AVal Row="20">0</AVal>
				<AVal Row="21">0</AVal>
				<AVal Row="22">0</AVal>
				<AVal Row="23">0</AVal>
				<AVal Row="24">0</AVal>
				<AVal Row="25">0</AVal>
				<AVal Row="26">0</AVal>
				<AVal Row="27">0</AVal>
				<AVal Row="28">0</AVal>
				<AVal Row="29">0</AVal>
				<AVal Row="30">0</AVal>
				<AVal Row="31">0</AVal>
				<AVal Row="32">0</AVal>
				<AVal Row="33">0</AVal>
				<AVal Row="34">0</AVal>
				<AVal Row="35">0</AVal>
				<AVal Row="36">0</AVal>
				<AVal Row="37">0</AVal>
				<AVal Row="38">0</AVal>
				<AVal Row="39">0</AVal>
				<AVal Row="40">0</AVal>
				<AVal Row="41">0</AVal>
				<AVal Row="42">0</AVal>
				<AVal Row="43">0</AVal>
				<AVal Row="44">0</AVal>
				<AVal Row="45">0</AVal>
				<AVal Row="46">0</AVal>
				<AVal Row="47">0</AVal>
				<AVal Row="48">0</AVal>
			</ArrayValues>
		</RealNum>
		<String Name="datBrickFireResistance">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
				<AVal Row="3"><![CDATA[""]]></AVal>
				<AVal Row="4"><![CDATA[""]]></AVal>
				<AVal Row="5"><![CDATA[""]]></AVal>
				<AVal Row="6"><![CDATA[""]]></AVal>
				<AVal Row="7"><![CDATA[""]]></AVal>
				<AVal Row="8"><![CDATA[""]]></AVal>
				<AVal Row="9"><![CDATA[""]]></AVal>
				<AVal Row="10"><![CDATA[""]]></AVal>
				<AVal Row="11"><![CDATA[""]]></AVal>
				<AVal Row="12"><![CDATA[""]]></AVal>
				<AVal Row="13"><![CDATA[""]]></AVal>
				<AVal Row="14"><![CDATA[""]]></AVal>
				<AVal Row="15"><![CDATA[""]]></AVal>
				<AVal Row="16"><![CDATA[""]]></AVal>
				<AVal Row="17"><![CDATA[""]]></AVal>
				<AVal Row="18"><![CDATA[""]]></AVal>
				<AVal Row="19"><![CDATA[""]]></AVal>
				<AVal Row="20"><![CDATA[""]]></AVal>
				<AVal Row="21"><![CDATA[""]]></AVal>
				<AVal Row="22"><![CDATA[""]]></AVal>
				<AVal Row="23"><![CDATA[""]]></AVal>
				<AVal Row="24"><![CDATA[""]]></AVal>
				<AVal Row="25"><![CDATA[""]]></AVal>
				<AVal Row="26"><![CDATA[""]]></AVal>
				<AVal Row="27"><![CDATA[""]]></AVal>
				<AVal Row="28"><![CDATA[""]]></AVal>
				<AVal Row="29"><![CDATA[""]]></AVal>
				<AVal Row="30"><![CDATA[""]]></AVal>
				<AVal Row="31"><![CDATA[""]]></AVal>
				<AVal Row="32"><![CDATA[""]]></AVal>
				<AVal Row="33"><![CDATA[""]]></AVal>
				<AVal Row="34"><![CDATA[""]]></AVal>
				<AVal Row="35"><![CDATA[""]]></AVal>
				<AVal Row="36"><![CDATA[""]]></AVal>
				<AVal Row="37"><![CDATA[""]]></AVal>
				<AVal Row="38"><![CDATA[""]]></AVal>
				<AVal Row="39"><![CDATA[""]]></AVal>
				<AVal Row="40"><![CDATA[""]]></AVal>
				<AVal Row="41"><![CDATA[""]]></AVal>
				<AVal Row="42"><![CDATA[""]]></AVal>
				<AVal Row="43"><![CDATA[""]]></AVal>
				<AVal Row="44"><![CDATA[""]]></AVal>
				<AVal Row="45"><![CDATA[""]]></AVal>
				<AVal Row="46"><![CDATA[""]]></AVal>
				<AVal Row="47"><![CDATA[""]]></AVal>
				<AVal Row="48"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<String Name="datBrickAcustic">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
				<AVal Row="3"><![CDATA[""]]></AVal>
				<AVal Row="4"><![CDATA[""]]></AVal>
				<AVal Row="5"><![CDATA[""]]></AVal>
				<AVal Row="6"><![CDATA[""]]></AVal>
				<AVal Row="7"><![CDATA[""]]></AVal>
				<AVal Row="8"><![CDATA[""]]></AVal>
				<AVal Row="9"><![CDATA[""]]></AVal>
				<AVal Row="10"><![CDATA[""]]></AVal>
				<AVal Row="11"><![CDATA[""]]></AVal>
				<AVal Row="12"><![CDATA[""]]></AVal>
				<AVal Row="13"><![CDATA[""]]></AVal>
				<AVal Row="14"><![CDATA[""]]></AVal>
				<AVal Row="15"><![CDATA[""]]></AVal>
				<AVal Row="16"><![CDATA[""]]></AVal>
				<AVal Row="17"><![CDATA[""]]></AVal>
				<AVal Row="18"><![CDATA[""]]></AVal>
				<AVal Row="19"><![CDATA[""]]></AVal>
				<AVal Row="20"><![CDATA[""]]></AVal>
				<AVal Row="21"><![CDATA[""]]></AVal>
				<AVal Row="22"><![CDATA[""]]></AVal>
				<AVal Row="23"><![CDATA[""]]></AVal>
				<AVal Row="24"><![CDATA[""]]></AVal>
				<AVal Row="25"><![CDATA[""]]></AVal>
				<AVal Row="26"><![CDATA[""]]></AVal>
				<AVal Row="27"><![CDATA[""]]></AVal>
				<AVal Row="28"><![CDATA[""]]></AVal>
				<AVal Row="29"><![CDATA[""]]></AVal>
				<AVal Row="30"><![CDATA[""]]></AVal>
				<AVal Row="31"><![CDATA[""]]></AVal>
				<AVal Row="32"><![CDATA[""]]></AVal>
				<AVal Row="33"><![CDATA[""]]></AVal>
				<AVal Row="34"><![CDATA[""]]></AVal>
				<AVal Row="35"><![CDATA[""]]></AVal>
				<AVal Row="36"><![CDATA[""]]></AVal>
				<AVal Row="37"><![CDATA[""]]></AVal>
				<AVal Row="38"><![CDATA[""]]></AVal>
				<AVal Row="39"><![CDATA[""]]></AVal>
				<AVal Row="40"><![CDATA[""]]></AVal>
				<AVal Row="41"><![CDATA[""]]></AVal>
				<AVal Row="42"><![CDATA[""]]></AVal>
				<AVal Row="43"><![CDATA[""]]></AVal>
				<AVal Row="44"><![CDATA[""]]></AVal>
				<AVal Row="45"><![CDATA[""]]></AVal>
				<AVal Row="46"><![CDATA[""]]></AVal>
				<AVal Row="47"><![CDATA[""]]></AVal>
				<AVal Row="48"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<RealNum Name="datBrickUvalue">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="48" SecondDimension="0">
				<AVal Row="1">0.99</AVal>
				<AVal Row="2">0.99</AVal>
				<AVal Row="3">0.99</AVal>
				<AVal Row="4">0.99</AVal>
				<AVal Row="5">0.99</AVal>
				<AVal Row="6">0.99</AVal>
				<AVal Row="7">0.99</AVal>
				<AVal Row="8">0.99</AVal>
				<AVal Row="9">0.99</AVal>
				<AVal Row="10">0.99</AVal>
				<AVal Row="11">0.99</AVal>
				<AVal Row="12">0.99</AVal>
				<AVal Row="13">0.99</AVal>
				<AVal Row="14">0.99</AVal>
				<AVal Row="15">0.99</AVal>
				<AVal Row="16">0.99</AVal>
				<AVal Row="17">0.99</AVal>
				<AVal Row="18">0.99</AVal>
				<AVal Row="19">0.99</AVal>
				<AVal Row="20">0.99</AVal>
				<AVal Row="21">0.99</AVal>
				<AVal Row="22">1.1</AVal>
				<AVal Row="23">1.1</AVal>
				<AVal Row="24">1.1</AVal>
				<AVal Row="25">1.1</AVal>
				<AVal Row="26">1.1</AVal>
				<AVal Row="27">1.1</AVal>
				<AVal Row="28">1.1</AVal>
				<AVal Row="29">1.3</AVal>
				<AVal Row="30">1.3</AVal>
				<AVal Row="31">1.3</AVal>
				<AVal Row="32">1.3</AVal>
				<AVal Row="33">0.99</AVal>
				<AVal Row="34">0.99</AVal>
				<AVal Row="35">0.99</AVal>
				<AVal Row="36">0.99</AVal>
				<AVal Row="37">0.99</AVal>
				<AVal Row="38">0.99</AVal>
				<AVal Row="39">0.99</AVal>
				<AVal Row="40">0.99</AVal>
				<AVal Row="41">1.1</AVal>
				<AVal Row="42">1.1</AVal>
				<AVal Row="43">1.1</AVal>
				<AVal Row="44">1.1</AVal>
				<AVal Row="45">1.1</AVal>
				<AVal Row="46">1.1</AVal>
				<AVal Row="47">1.1</AVal>
				<AVal Row="48">1.1</AVal>
			</ArrayValues>
		</RealNum>
		<Separator Name="data_beamFamilys">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
		</Separator>
		<Integer Name="datProdBeamLang">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">1</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="datProdBeamIdx">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">100</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="datProdBeamType">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">4</AVal>
			</ArrayValues>
		</Integer>
		<String Name="datProdBeamName">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1"><![CDATA["KS-Quadro beam"]]></AVal>
			</ArrayValues>
		</String>
		<Boolean Name="datProdBeamCuttable">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</Boolean>
		<Boolean Name="datProdBeamMulti">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</Boolean>
		<String Name="datProdBeamCert">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<RealNum Name="datProdBeamKgPerM3">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</RealNum>
		<RealNum Name="datProdBeamKnPerM3">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</RealNum>
		<RealNum Name="datProdBeamLambdaDry">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</RealNum>
		<RealNum Name="datProdBeamLambdaNormal">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</RealNum>
		<Length Name="datProdBeamGroutBottom">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="datProdBeamGroutTop">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="datProdBeamVerticalGlue">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">1</AVal>
			</ArrayValues>
		</Integer>
		<Separator Name="data_beams">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
		</Separator>
		<Integer Name="datBeamLang">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="datBeamIdx">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="datBeamFamily">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</Integer>
		<String Name="datBeamName">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<String Name="datBeamArtNo">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<String Name="datBeamDbNo">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<String Name="datBeamEan">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<Boolean Name="datBeamCustom">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</Boolean>
		<Length Name="datBeamSize">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="5">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
				<AVal Column="4" Row="1">0</AVal>
				<AVal Column="5" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="datBeamOverhang">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<RealNum Name="datBeamLoadCapacity">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</RealNum>
		<RealNum Name="datBeamKgPerPc">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</RealNum>
		<RealNum Name="datBeamMortarPerM">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</RealNum>

		<!-- gs_wall_addon: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_wall_addon">
			<Description><![CDATA["Accessories Add-On Parameters"]]></Description>
		</Title>
		<Boolean Name="gs_gdl_debug">
			<Description><![CDATA["Debug"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="ac_addon_access">
			<Description><![CDATA["Add-On Access"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="ac_accessory_debug">
			<Description><![CDATA["Accessory Debug Function"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="ac_wall_height">
			<Description><![CDATA["Wall Height"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>2.7</Value>
		</Length>
		<Length Name="ac_wall_length">
			<Description><![CDATA["Wall Length"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>4.5</Value>
		</Length>
		<Boolean Name="ac_curved_wall">
			<Description><![CDATA["Curved Wall ( Off - Straight )"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="ac_wall_radius">
			<Description><![CDATA["Wall Radius"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Integer Name="ac_wall_resol">
			<Description><![CDATA["Wall Resolution"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="ac_wall_thk1">
			<Description><![CDATA["Wall Thickness - Start"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="ac_wall_thk2">
			<Description><![CDATA["Wall Thickness - End"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="ac_refside">
			<Description><![CDATA["Build on the Right Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Angle Name="ac_angles">
			<Description><![CDATA["Angles of Opening"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">90</AVal>
				<AVal Column="2" Row="1">90</AVal>
			</ArrayValues>
		</Angle>
		<Length Name="ac_side_poly">
			<Description><![CDATA["Side Polygon"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="ac_top_poly">
			<Description><![CDATA["Top Polygon of the Wall"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<ArrayValues FirstDimension="3" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">2.7</AVal>
				<AVal Column="1" Row="2">3</AVal>
				<AVal Column="2" Row="2">2.7</AVal>
				<AVal Column="1" Row="3">4.5</AVal>
				<AVal Column="2" Row="3">1.7</AVal>
			</ArrayValues>
		</Length>
		<Length Name="ac_bot_poly">
			<Description><![CDATA["Bottom Polygon of the Wall"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<ArrayValues FirstDimension="5" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">1</AVal>
				<AVal Column="1" Row="2">1.5</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="1" Row="3">2.5</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="1" Row="4">3.5</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="1" Row="5">4.5</AVal>
				<AVal Column="2" Row="5">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="ac_wd_poly">
			<Description><![CDATA["Window - Door Polygon"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="9">
				<AVal Column="1" Row="1">0.1016</AVal>
				<AVal Column="2" Row="1">1</AVal>
				<AVal Column="3" Row="1">0.9</AVal>
				<AVal Column="4" Row="1">1</AVal>
				<AVal Column="5" Row="1">2.1</AVal>
				<AVal Column="6" Row="1">2</AVal>
				<AVal Column="7" Row="1">2.1</AVal>
				<AVal Column="8" Row="1">2</AVal>
				<AVal Column="9" Row="1">0.9</AVal>
				<AVal Column="1" Row="2">0.1016</AVal>
				<AVal Column="2" Row="2">2.5</AVal>
				<AVal Column="3" Row="2">0</AVal>
				<AVal Column="4" Row="2">2.5</AVal>
				<AVal Column="5" Row="2">2.1</AVal>
				<AVal Column="6" Row="2">3.5</AVal>
				<AVal Column="7" Row="2">2.1</AVal>
				<AVal Column="8" Row="2">3.5</AVal>
				<AVal Column="9" Row="2">0</AVal>
			</ArrayValues>
		</Length>
		<Material Name="ac_left_mat">
			<Description><![CDATA["Left Side Material"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Material>
		<Material Name="ac_right_mat">
			<Description><![CDATA["Right Side Material"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Material>
		<Material Name="ac_edge_mat">
			<Description><![CDATA["Edge Material"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Material>
		<PenColor Name="ac_cont_pen">
			<Description><![CDATA["Contour Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="ac_back_pen">
			<Description><![CDATA["Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="ac_fill_pen">
			<Description><![CDATA["Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<LineType Name="ac_line_type">
			<Description><![CDATA["Line Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</LineType>
		<FillPattern Name="ac_fill_type">
			<Description><![CDATA["Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</FillPattern>
		<RealNum Name="checkSum">
			<Description><![CDATA["Geometri Checksum"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>247.5</Value>
		</RealNum>

		<!-- bSideView: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="bSideView">
			<Description><![CDATA["Side View"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="sideViewPos">
			<Description><![CDATA["View Position"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Angle Name="sideViewRot">
			<Description><![CDATA["View Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Angle>

		<!-- gs_2D_representation: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_2D_representation">
			<Description><![CDATA["2D Representation"]]></Description>
		</Title>
		<Boolean Name="bProj2D">
			<Description><![CDATA["Projected 2D"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="AC_symb_display_option">
			<Description><![CDATA["Floor Plan Display"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Integer Name="AC_symb_show_projection_to">
			<Description><![CDATA["Show Projection"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<String Name="gs_symb_display_option">
			<Description><![CDATA["Floor Plan Display"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA["Symbolic View"]]></Value>
		</String>
		<Boolean Name="gs_use_3D_view_attributes">
			<Description><![CDATA["Use 3D View Attributes"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<String Name="gs_symb_show_projection_to">
			<Description><![CDATA["Show Projection"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Entire Element"]]></Value>
		</String>
		<String Name="gs_detlevel_2D">
			<Description><![CDATA["2D Detail Level"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Detailed"]]></Value>
		</String>
		<Integer Name="iDetlevel2D">
			<Description><![CDATA["2D Detail Level"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<LineType Name="gs_cont_line">
			<Description><![CDATA["Contour Lines"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</LineType>
		<PenColor Name="gs_cont_pen">
			<Description><![CDATA["Contour Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2</Value>
		</PenColor>
		<Integer Name="iContpen">
			<Description><![CDATA["Contour Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<FillPattern Name="gs_fill_type">
			<Description><![CDATA["Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>65</Value>
		</FillPattern>
		<PenColor Name="gs_fill_pen">
			<Description><![CDATA["Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>
		<Integer Name="iFillPen">
			<Description><![CDATA["Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>19</Value>
		</Integer>
		<PenColor Name="gs_back_pen">
			<Description><![CDATA["Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>
		<Integer Name="iBackPen">
			<Description><![CDATA["Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>19</Value>
		</Integer>
		<LineType Name="AC_cut_linetype">
			<Description><![CDATA["Cut Lines"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</LineType>
		<PenColor Name="gs_cut_pen">
			<Description><![CDATA["Cut Line Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>24</Value>
		</PenColor>
		<Integer Name="iCutPen">
			<Description><![CDATA["Cut Line Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>24</Value>
		</Integer>
		<LineType Name="AC_overhead_linetype">
			<Description><![CDATA["Overhead Lines"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>21</Value>
		</LineType>
		<PenColor Name="AC_overhead_pen">
			<Description><![CDATA["Overhead Line Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</PenColor>
		<Integer Name="iOverHeadPen">
			<Description><![CDATA["Overhead Line Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Boolean Name="gs_2D_projection">
			<Description><![CDATA["2D Symbol"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="gs_2D_projection_type">
			<Description><![CDATA["2D Projection Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="gs_cutplane_height">
			<Description><![CDATA["Height of the Cutplane"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_top_range_height">
			<Description><![CDATA["Height of the Top Cutplane"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_bottom_range_height">
			<Description><![CDATA["Height of the Bottom Cutplane"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_3D_representation: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_3D_representation">
			<Description><![CDATA["3D Representation"]]></Description>
		</Title>
		<String Name="gs_detlevel_3D">
			<Description><![CDATA["3D Detail Level"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Detailed"]]></Value>
		</String>
		<Integer Name="iDetlevel3D">
			<Description><![CDATA["3D Detail Level"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<PenColor Name="pen3D">
			<Description><![CDATA["3D Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2</Value>
		</PenColor>
		<Integer Name="iPen3D">
			<Description><![CDATA["3D Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Boolean Name="bShowGrout">
			<Description><![CDATA["Show Grout"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Integer Name="gs_resol">
			<Description><![CDATA["Resolution"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>24</Value>
		</Integer>

		<!-- gs_list: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_list">
			<Description><![CDATA["Parameters for Listing"]]></Description>
		</Title>
		<RealNum Name="gs_list_cost">
			<Description><![CDATA["Cost"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</RealNum>
		<String Name="gs_list_manufacturer">
			<Description><![CDATA["Manufacturer"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["KS-Quadro"]]></Value>
		</String>
		<String Name="gs_list_note">
			<Description><![CDATA["Note/Remarks"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_location">
			<Description><![CDATA["Location"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_accessories">
			<Description><![CDATA["Accessories"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="FM_Type">
			<Description><![CDATA["Group Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="iFMType">
			<Description><![CDATA["Group Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>25</Value>
		</Integer>
		<String Name="FM_InventoryNumber">
			<Description><![CDATA["Inventory Number"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="FM_SerialNumber">
			<Description><![CDATA["Serial Number"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="FM_ProductionYear">
			<Description><![CDATA["Production Year"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<RealNum Name="FM_ObjectWeight">
			<Description><![CDATA["Object Weight"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</RealNum>
		<String Name="FM_ObjectWeightUnit">
			<Description><![CDATA["Object Weight Unit"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA["kg"]]></Value>
		</String>
		<String Name="gs_list_custom1">
			<Description><![CDATA["User Defined 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom2">
			<Description><![CDATA["User Defined 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom3">
			<Description><![CDATA["User Defined 3"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom4">
			<Description><![CDATA["User Defined 4"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom5">
			<Description><![CDATA["User Defined 5"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>

		<!-- gui: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gui">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
		</Title>
		<Integer Name="gs_ui_current_page">
			<Description><![CDATA["Current Page"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="nUiStart_T">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="nUiStart_C">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>

		<!-- BO_Title: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="BO_Title">
			<Description><![CDATA["BIMobject Information"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
		</Title>
		<Separator Name="BO_Separator">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
		</Separator>

		<!-- BO_prodinfo: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<String Name="BO_prodinfo">
			<Description><![CDATA["Name of the object"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_prodsku">
			<Description><![CDATA["Product SKU"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_Manufac">
			<Description><![CDATA["Brand:"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_brandurl">
			<Description><![CDATA["Brand url:"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_prodfam">
			<Description><![CDATA["Product family:"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_prodgroup">
			<Description><![CDATA["Product group:"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_mancont">
			<Description><![CDATA["Manufacturer country:"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_designcont">
			<Description><![CDATA["Design country:"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_publisdat">
			<Description><![CDATA["Date of publishing:"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="BO_edinum">
			<Description><![CDATA["Edition number:"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>-1</Value>
		</Integer>
		<RealNum Name="BO_width">
			<Description><![CDATA["Width (mm):"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</RealNum>
		<RealNum Name="BO_height">
			<Description><![CDATA["Height (mm):"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</RealNum>
		<RealNum Name="BO_depth">
			<Description><![CDATA["Depth (mm):"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</RealNum>
		<RealNum Name="BO_weight">
			<Description><![CDATA["Weight Net (Kg):"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</RealNum>
		<String Name="BO_productguid">
			<Description><![CDATA["Unique identifier of the object"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>

		<!-- BO_links: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<String Name="BO_links">
			<Description><![CDATA["Links"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_boqrurl">
			<Description><![CDATA["BIMobject QR code url:"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_prodaturl">
			<Description><![CDATA["Product data url:"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_producturl">
			<Description><![CDATA["Product url:"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_montins">
			<Description><![CDATA["Installation instructions:"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_prodcert">
			<Description><![CDATA["Product certification:"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_techcert">
			<Description><![CDATA["Technical description:"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_youtube">
			<Description><![CDATA["Instruction video:"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_ean">
			<Description><![CDATA["EAN code:"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>

		<!-- BO_real: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<String Name="BO_real">
			<Description><![CDATA["Related"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_mainmat">
			<Description><![CDATA["Material main:"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_secmat">
			<Description><![CDATA["Material secondary:"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>

		<!-- BO_classific: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<String Name="BO_classific">
			<Description><![CDATA["Classifications"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_bocat">
			<Description><![CDATA["BIMobject Category:"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_ifcclas">
			<Description><![CDATA["IFC Classification:"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_unspc">
			<Description><![CDATA["UNSPC code:"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_uniclass_1_4_code">
			<Description><![CDATA["Uniclass 1.4 Code"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_uniclass_1_4_desc">
			<Description><![CDATA["Uniclass 1.4 Description"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_uniclass_2_0_code">
			<Description><![CDATA["Uniclass 2.0 Code"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_uniclass_2_0_desc">
			<Description><![CDATA["Uniclass 2.0 Description"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_uniclass2015_code">
			<Description><![CDATA["Uniclass 2015 Code"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_uniclass2015_desc">
			<Description><![CDATA["Uniclass 2015 Description"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_nbs_ref">
			<Description><![CDATA["NBS Reference"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_nbs_desc">
			<Description><![CDATA["NBS Reference Description"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_omniclass_code">
			<Description><![CDATA["OmniClass Code"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_omniclass_name">
			<Description><![CDATA["OmniClass Description"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_masterformat2014_code">
			<Description><![CDATA["Masterformat 2014 Code"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_masterformat2014_name">
			<Description><![CDATA["Masterformat 2014 Description"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_uniformat2_code">
			<Description><![CDATA["Uniformat II Code"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_uniformat2_name">
			<Description><![CDATA["Uniformat II Description"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_cobie_type_cat">
			<Description><![CDATA["COBIe Type Category"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>

		<!-- BO_regions: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<String Name="BO_regions">
			<Description><![CDATA["Regions"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_europe">
			<Description><![CDATA["Region Europe"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_northamerica">
			<Description><![CDATA["Region North America"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_southamerica">
			<Description><![CDATA["Region South America"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_middleeast">
			<Description><![CDATA["Region Middle East"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_asia">
			<Description><![CDATA["Region Asia"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_oceania">
			<Description><![CDATA["Region Oceania"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_africa">
			<Description><![CDATA["Region Africa"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="BO_antarctica">
			<Description><![CDATA["Region Antarctica"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Separator Name="BO_Separator2">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
		</Separator>
		<Integer Name="nVersionNumber">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">20140613</AVal>
				<AVal Column="2" Row="1">0</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="iVersionNumber">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">20140613</AVal>
				<AVal Column="2" Row="1">0</AVal>
			</ArrayValues>
		</Integer>
		<String Name="sSaved_BO_params">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="44" SecondDimension="9">
				<AVal Column="1" Row="1"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="1"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="1"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="1"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="1"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="1"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="1"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="1"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="1"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="2"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="2"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="2"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="2"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="2"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="2"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="2"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="2"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="2"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="3"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="3"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="3"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="3"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="3"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="3"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="3"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="3"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="3"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="4"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="4"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="4"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="4"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="4"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="4"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="4"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="4"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="4"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="5"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="5"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="5"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="5"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="5"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="5"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="5"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="5"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="5"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="6"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="6"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="6"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="6"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="6"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="6"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="6"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="6"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="6"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="7"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="7"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="7"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="7"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="7"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="7"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="7"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="7"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="7"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="8"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="8"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="8"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="8"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="8"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="8"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="8"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="8"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="8"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="9"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="9"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="9"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="9"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="9"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="9"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="9"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="9"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="9"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="10"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="10"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="10"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="10"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="10"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="10"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="10"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="10"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="10"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="11"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="11"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="11"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="11"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="11"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="11"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="11"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="11"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="11"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="12"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="12"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="12"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="12"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="12"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="12"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="12"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="12"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="12"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="13"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="13"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="13"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="13"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="13"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="13"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="13"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="13"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="13"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="14"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="14"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="14"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="14"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="14"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="14"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="14"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="14"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="14"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="15"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="15"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="15"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="15"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="15"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="15"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="15"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="15"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="15"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="16"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="16"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="16"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="16"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="16"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="16"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="16"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="16"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="16"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="17"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="17"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="17"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="17"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="17"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="17"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="17"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="17"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="17"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="18"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="18"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="18"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="18"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="18"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="18"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="18"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="18"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="18"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="19"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="19"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="19"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="19"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="19"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="19"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="19"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="19"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="19"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="20"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="20"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="20"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="20"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="20"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="20"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="20"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="20"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="20"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="21"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="21"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="21"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="21"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="21"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="21"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="21"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="21"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="21"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="22"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="22"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="22"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="22"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="22"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="22"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="22"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="22"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="22"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="23"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="23"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="23"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="23"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="23"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="23"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="23"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="23"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="23"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="24"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="24"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="24"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="24"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="24"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="24"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="24"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="24"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="24"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="25"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="25"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="25"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="25"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="25"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="25"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="25"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="25"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="25"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="26"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="26"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="26"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="26"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="26"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="26"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="26"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="26"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="26"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="27"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="27"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="27"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="27"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="27"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="27"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="27"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="27"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="27"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="28"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="28"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="28"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="28"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="28"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="28"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="28"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="28"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="28"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="29"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="29"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="29"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="29"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="29"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="29"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="29"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="29"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="29"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="30"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="30"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="30"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="30"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="30"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="30"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="30"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="30"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="30"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="31"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="31"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="31"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="31"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="31"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="31"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="31"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="31"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="31"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="32"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="32"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="32"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="32"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="32"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="32"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="32"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="32"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="32"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="33"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="33"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="33"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="33"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="33"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="33"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="33"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="33"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="33"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="34"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="34"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="34"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="34"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="34"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="34"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="34"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="34"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="34"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="35"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="35"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="35"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="35"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="35"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="35"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="35"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="35"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="35"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="36"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="36"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="36"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="36"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="36"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="36"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="36"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="36"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="36"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="37"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="37"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="37"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="37"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="37"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="37"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="37"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="37"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="37"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="38"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="38"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="38"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="38"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="38"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="38"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="38"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="38"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="38"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="39"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="39"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="39"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="39"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="39"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="39"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="39"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="39"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="39"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="40"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="40"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="40"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="40"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="40"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="40"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="40"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="40"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="40"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="41"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="41"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="41"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="41"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="41"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="41"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="41"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="41"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="41"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="42"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="42"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="42"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="42"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="42"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="42"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="42"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="42"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="42"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="43"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="43"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="43"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="43"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="43"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="43"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="43"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="43"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="43"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="44"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="44"><![CDATA[""]]></AVal>
				<AVal Column="3" Row="44"><![CDATA[""]]></AVal>
				<AVal Column="4" Row="44"><![CDATA[""]]></AVal>
				<AVal Column="5" Row="44"><![CDATA[""]]></AVal>
				<AVal Column="6" Row="44"><![CDATA[""]]></AVal>
				<AVal Column="7" Row="44"><![CDATA[""]]></AVal>
				<AVal Column="8" Row="44"><![CDATA[""]]></AVal>
				<AVal Column="9" Row="44"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<Integer Name="iSaved_BO_params">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="9">
				<AVal Column="1" Row="1">-1</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
				<AVal Column="4" Row="1">0</AVal>
				<AVal Column="5" Row="1">0</AVal>
				<AVal Column="6" Row="1">0</AVal>
				<AVal Column="7" Row="1">0</AVal>
				<AVal Column="8" Row="1">0</AVal>
				<AVal Column="9" Row="1">0</AVal>
			</ArrayValues>
		</Integer>
		<RealNum Name="rSaved_BO_params">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="4" SecondDimension="9">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
				<AVal Column="4" Row="1">0</AVal>
				<AVal Column="5" Row="1">0</AVal>
				<AVal Column="6" Row="1">0</AVal>
				<AVal Column="7" Row="1">0</AVal>
				<AVal Column="8" Row="1">0</AVal>
				<AVal Column="9" Row="1">0</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="3" Row="2">0</AVal>
				<AVal Column="4" Row="2">0</AVal>
				<AVal Column="5" Row="2">0</AVal>
				<AVal Column="6" Row="2">0</AVal>
				<AVal Column="7" Row="2">0</AVal>
				<AVal Column="8" Row="2">0</AVal>
				<AVal Column="9" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="3" Row="3">0</AVal>
				<AVal Column="4" Row="3">0</AVal>
				<AVal Column="5" Row="3">0</AVal>
				<AVal Column="6" Row="3">0</AVal>
				<AVal Column="7" Row="3">0</AVal>
				<AVal Column="8" Row="3">0</AVal>
				<AVal Column="9" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="3" Row="4">0</AVal>
				<AVal Column="4" Row="4">0</AVal>
				<AVal Column="5" Row="4">0</AVal>
				<AVal Column="6" Row="4">0</AVal>
				<AVal Column="7" Row="4">0</AVal>
				<AVal Column="8" Row="4">0</AVal>
				<AVal Column="9" Row="4">0</AVal>
			</ArrayValues>
		</RealNum>
		<Integer Name="iPrevFamily">
			<Description><![CDATA[""]]></Description>
			<Value>10000</Value>
		</Integer>
		<Integer Name="idLastSavedBO">
			<Description><![CDATA[""]]></Description>
			<Value>1</Value>
		</Integer>

		<!-- bModifiedByAPI: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="bModifiedByAPI">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_BoldName/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="nPolygonPoint">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>9</Value>
		</Integer>
		<Length Name="contourPoints">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="9" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">1</AVal>
				<AVal Column="1" Row="2">1.5</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="1" Row="3">2.5</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="1" Row="4">3.5</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="1" Row="5">4.5</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="1" Row="6">4.5</AVal>
				<AVal Column="2" Row="6">1.7</AVal>
				<AVal Column="1" Row="7">3</AVal>
				<AVal Column="2" Row="7">2.7</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">2.7</AVal>
				<AVal Column="1" Row="9">0</AVal>
				<AVal Column="2" Row="9">1</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="contourDirection">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>-1</Value>
		</Integer>
		<Integer Name="nWallSide">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="minXpointNumber">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="maxXpointNumber">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>6</Value>
		</Integer>
		<Integer Name="iBorderModes">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">4</AVal>
				<AVal Row="2">3</AVal>
				<AVal Row="3">3</AVal>
				<AVal Row="4">3</AVal>
				<AVal Row="5">5</AVal>
				<AVal Row="6">2</AVal>
				<AVal Row="7">1</AVal>
				<AVal Row="8">6</AVal>
			</ArrayValues>
		</Integer>
		<Angle Name="contourAngles">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">326.309932474</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">90</AVal>
				<AVal Row="6">146.309932474</AVal>
				<AVal Row="7">180</AVal>
				<AVal Row="8">270</AVal>
			</ArrayValues>
		</Angle>
		<Length Name="contourOutPoints">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="9" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">1</AVal>
				<AVal Column="1" Row="2">1.5</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="1" Row="3">2.5</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="1" Row="4">3.5</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="1" Row="5">4.5</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="1" Row="6">4.5</AVal>
				<AVal Column="2" Row="6">1.7</AVal>
				<AVal Column="1" Row="7">3</AVal>
				<AVal Column="2" Row="7">2.7</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">2.7</AVal>
				<AVal Column="1" Row="9">0</AVal>
				<AVal Column="2" Row="9">1</AVal>
			</ArrayValues>
		</Length>
		<Length Name="baseCubePoints">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="9" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">1</AVal>
				<AVal Column="1" Row="2">1.5</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="1" Row="3">2.5</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="1" Row="4">3.5</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="1" Row="5">4.5</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="1" Row="6">4.5</AVal>
				<AVal Column="2" Row="6">1.7</AVal>
				<AVal Column="1" Row="7">3</AVal>
				<AVal Column="2" Row="7">2.7</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">2.7</AVal>
				<AVal Column="1" Row="9">0</AVal>
				<AVal Column="2" Row="9">1</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="nUniContourPoint">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>7</Value>
		</Integer>
		<Length Name="uniContourPoint">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="7" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">1</AVal>
				<AVal Column="1" Row="2">1.5</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="1" Row="3">4.5</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="1" Row="4">4.5</AVal>
				<AVal Column="2" Row="4">1.7</AVal>
				<AVal Column="1" Row="5">3</AVal>
				<AVal Column="2" Row="5">2.7</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">2.7</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">1</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="iBorderUni">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="6" SecondDimension="0">
				<AVal Row="1">4</AVal>
				<AVal Row="2">3</AVal>
				<AVal Row="3">5</AVal>
				<AVal Row="4">2</AVal>
				<AVal Row="5">1</AVal>
				<AVal Row="6">6</AVal>
			</ArrayValues>
		</Integer>
		<Angle Name="uniAngles">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="6" SecondDimension="0">
				<AVal Row="1">326.309932474</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">90</AVal>
				<AVal Row="4">146.309932474</AVal>
				<AVal Row="5">180</AVal>
				<AVal Row="6">270</AVal>
			</ArrayValues>
		</Angle>
		<Integer Name="numWD">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Integer Name="nOpeningPolygons">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Boolean Name="bHasCornerWindow">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="origOpeningPoligons">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="10" SecondDimension="3">
				<AVal Column="1" Row="1">3.5</AVal>
				<AVal Column="2" Row="1">2.1</AVal>
				<AVal Column="3" Row="1">15</AVal>
				<AVal Column="1" Row="2">2.5</AVal>
				<AVal Column="2" Row="2">2.1</AVal>
				<AVal Column="3" Row="2">15</AVal>
				<AVal Column="1" Row="3">2.5</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="3" Row="3">15</AVal>
				<AVal Column="1" Row="4">3.5</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="3" Row="4">15</AVal>
				<AVal Column="1" Row="5">3.5</AVal>
				<AVal Column="2" Row="5">2.1</AVal>
				<AVal Column="3" Row="5">-1</AVal>
				<AVal Column="1" Row="6">1</AVal>
				<AVal Column="2" Row="6">0.9</AVal>
				<AVal Column="3" Row="6">15</AVal>
				<AVal Column="1" Row="7">2</AVal>
				<AVal Column="2" Row="7">0.9</AVal>
				<AVal Column="3" Row="7">15</AVal>
				<AVal Column="1" Row="8">2</AVal>
				<AVal Column="2" Row="8">2.1</AVal>
				<AVal Column="3" Row="8">15</AVal>
				<AVal Column="1" Row="9">1</AVal>
				<AVal Column="2" Row="9">2.1</AVal>
				<AVal Column="3" Row="9">15</AVal>
				<AVal Column="1" Row="10">1</AVal>
				<AVal Column="2" Row="10">0.9</AVal>
				<AVal Column="3" Row="10">-1</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="origOpeningStartEnd">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="2">
				<AVal Column="1" Row="1">1</AVal>
				<AVal Column="2" Row="1">5</AVal>
				<AVal Column="1" Row="2">6</AVal>
				<AVal Column="2" Row="2">10</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="origOpeningBoundingBox">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="4">
				<AVal Column="1" Row="1">2.5</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">3.5</AVal>
				<AVal Column="4" Row="1">2.1</AVal>
				<AVal Column="1" Row="2">1</AVal>
				<AVal Column="2" Row="2">0.9</AVal>
				<AVal Column="3" Row="2">2</AVal>
				<AVal Column="4" Row="2">2.1</AVal>
			</ArrayValues>
		</Length>
		<Length Name="origOpeningHoles">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="4">
				<AVal Column="1" Row="1">1</AVal>
				<AVal Column="2" Row="1">0.9</AVal>
				<AVal Column="3" Row="1">2</AVal>
				<AVal Column="4" Row="1">2.1</AVal>
				<AVal Column="1" Row="2">2.5</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="3" Row="2">3.5</AVal>
				<AVal Column="4" Row="2">2.1</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="origOpeningForms">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">1</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="origOpeningDirections">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">1</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="openingOrigSize">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="2">
				<AVal Column="1" Row="1">1</AVal>
				<AVal Column="2" Row="1">2.1</AVal>
				<AVal Column="1" Row="2">1</AVal>
				<AVal Column="2" Row="2">1.2</AVal>
			</ArrayValues>
		</Length>
		<Angle Name="doorAngleBorder">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="9" SecondDimension="0">
				<AVal Row="1">180</AVal>
				<AVal Row="2">270</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">90</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">90</AVal>
				<AVal Row="8">180</AVal>
				<AVal Row="9">270</AVal>
			</ArrayValues>
		</Angle>
		<Integer Name="iDoorBorder">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="9" SecondDimension="0">
				<AVal Row="1">11</AVal>
				<AVal Row="2">10</AVal>
				<AVal Row="3">11</AVal>
				<AVal Row="4">10</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">11</AVal>
				<AVal Row="7">10</AVal>
				<AVal Row="8">11</AVal>
				<AVal Row="9">10</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="surfaceDir">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>-1</Value>
		</Integer>
		<Boolean Name="bCsorba1">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bCsorba2">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="csorbaX1">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.2495</Value>
		</Length>
		<Length Name="csorbaX2">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.2495</Value>
		</Length>
		<Boolean Name="bOverrideJoint1">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bOverrideJoint2">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="iCalcJointType1">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Integer Name="iCalcJointType2">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Angle Name="cutAngle01">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Angle Name="cutAngle02">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="boundingRef">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="4">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">4.5</AVal>
				<AVal Column="4" Row="1">2.7</AVal>
			</ArrayValues>
		</Length>
		<Length Name="boundingOther">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="4">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">4.5</AVal>
				<AVal Column="4" Row="1">2.7</AVal>
			</ArrayValues>
		</Length>
		<Length Name="surfaceXmin">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="surfaceXmax">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4.5</Value>
		</Length>
		<Length Name="surfaceYmin">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="surfaceYmax">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2.7</Value>
		</Length>
		<Length Name="surfaceX">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4.5</Value>
		</Length>
		<Length Name="surfaceY">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2.7</Value>
		</Length>
		<Length Name="connWallStartThk">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.175</Value>
		</Length>
		<Integer Name="connWallStartIangle">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Angle Name="connWallStartAngle">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>180</Value>
		</Angle>
		<Length Name="connWallEndThk">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.175</Value>
		</Length>
		<Integer Name="connWallEndIangle">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Angle Name="connWallEndAngle">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>180</Value>
		</Angle>
		<Boolean Name="bResetBrick">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_BoldName/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="nMagPoint">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>6</Value>
		</Integer>
		<Length Name="rowHeights">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="6" SecondDimension="2">
				<AVal Column="1" Row="1">0.499</AVal>
				<AVal Column="2" Row="1">0.02</AVal>
				<AVal Column="1" Row="2">0.499</AVal>
				<AVal Column="2" Row="2">0.519</AVal>
				<AVal Column="1" Row="3">0.499</AVal>
				<AVal Column="2" Row="3">1.018</AVal>
				<AVal Column="1" Row="4">0.499</AVal>
				<AVal Column="2" Row="4">1.517</AVal>
				<AVal Column="1" Row="5">0.499</AVal>
				<AVal Column="2" Row="5">2.016</AVal>
				<AVal Column="1" Row="6">0.185</AVal>
				<AVal Column="2" Row="6">2.515</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="rowTypes">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="6" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">1</AVal>
				<AVal Row="3">1</AVal>
				<AVal Row="4">1</AVal>
				<AVal Row="5">1</AVal>
				<AVal Row="6">3</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="nLinder">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="linderCoords">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="6">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
				<AVal Column="4" Row="1">0</AVal>
				<AVal Column="5" Row="1">0</AVal>
				<AVal Column="6" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="linderTypes">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="9">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
				<AVal Column="4" Row="1">0</AVal>
				<AVal Column="5" Row="1">0</AVal>
				<AVal Column="6" Row="1">0</AVal>
				<AVal Column="7" Row="1">0</AVal>
				<AVal Column="8" Row="1">0</AVal>
				<AVal Column="9" Row="1">0</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="nLinderUsed">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="usedLinderCoords">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="6">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
				<AVal Column="4" Row="1">0</AVal>
				<AVal Column="5" Row="1">0</AVal>
				<AVal Column="6" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="usedLinderTypes">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="9">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
				<AVal Column="4" Row="1">0</AVal>
				<AVal Column="5" Row="1">0</AVal>
				<AVal Column="6" Row="1">0</AVal>
				<AVal Column="7" Row="1">0</AVal>
				<AVal Column="8" Row="1">0</AVal>
				<AVal Column="9" Row="1">0</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="nLinderGeomUnified">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="unifiedGeomLinderCoords">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="6">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
				<AVal Column="4" Row="1">0</AVal>
				<AVal Column="5" Row="1">0</AVal>
				<AVal Column="6" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="nVerticalGlue">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="verticalGlue">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="4">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
				<AVal Column="4" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="edgeSection">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="6" SecondDimension="16">
				<AVal Column="1" Row="1">0.721499944866</AVal>
				<AVal Column="2" Row="1">0.02</AVal>
				<AVal Column="3" Row="1">2.5</AVal>
				<AVal Column="4" Row="1">0.02</AVal>
				<AVal Column="5" Row="1">3.5</AVal>
				<AVal Column="6" Row="1">0.02</AVal>
				<AVal Column="7" Row="1">4.49999997765</AVal>
				<AVal Column="8" Row="1">0.02</AVal>
				<AVal Column="9" Row="1">0</AVal>
				<AVal Column="10" Row="1">0</AVal>
				<AVal Column="11" Row="1">0</AVal>
				<AVal Column="12" Row="1">0</AVal>
				<AVal Column="13" Row="1">0</AVal>
				<AVal Column="14" Row="1">0</AVal>
				<AVal Column="15" Row="1">0</AVal>
				<AVal Column="16" Row="1">0</AVal>
				<AVal Column="1" Row="2">2.23517631071e-008</AVal>
				<AVal Column="2" Row="2">0.519</AVal>
				<AVal Column="3" Row="2">1</AVal>
				<AVal Column="4" Row="2">0.519</AVal>
				<AVal Column="5" Row="2">1.001</AVal>
				<AVal Column="6" Row="2">0.519</AVal>
				<AVal Column="7" Row="2">1.999</AVal>
				<AVal Column="8" Row="2">0.519</AVal>
				<AVal Column="9" Row="2">2</AVal>
				<AVal Column="10" Row="2">0.519</AVal>
				<AVal Column="11" Row="2">2.5</AVal>
				<AVal Column="12" Row="2">0.519</AVal>
				<AVal Column="13" Row="2">3.5</AVal>
				<AVal Column="14" Row="2">0.519</AVal>
				<AVal Column="15" Row="2">4.49999997765</AVal>
				<AVal Column="16" Row="2">0.519</AVal>
				<AVal Column="1" Row="3">2.23517631071e-008</AVal>
				<AVal Column="2" Row="3">1.018</AVal>
				<AVal Column="3" Row="3">1</AVal>
				<AVal Column="4" Row="3">1.018</AVal>
				<AVal Column="5" Row="3">2</AVal>
				<AVal Column="6" Row="3">1.018</AVal>
				<AVal Column="7" Row="3">2.5</AVal>
				<AVal Column="8" Row="3">1.018</AVal>
				<AVal Column="9" Row="3">3.5</AVal>
				<AVal Column="10" Row="3">1.018</AVal>
				<AVal Column="11" Row="3">4.49999997765</AVal>
				<AVal Column="12" Row="3">1.018</AVal>
				<AVal Column="13" Row="3">0</AVal>
				<AVal Column="14" Row="3">0</AVal>
				<AVal Column="15" Row="3">0</AVal>
				<AVal Column="16" Row="3">0</AVal>
				<AVal Column="1" Row="4">2.23517631071e-008</AVal>
				<AVal Column="2" Row="4">1.517</AVal>
				<AVal Column="3" Row="4">1</AVal>
				<AVal Column="4" Row="4">1.517</AVal>
				<AVal Column="5" Row="4">2</AVal>
				<AVal Column="6" Row="4">1.517</AVal>
				<AVal Column="7" Row="4">2.5</AVal>
				<AVal Column="8" Row="4">1.517</AVal>
				<AVal Column="9" Row="4">3.5</AVal>
				<AVal Column="10" Row="4">1.517</AVal>
				<AVal Column="11" Row="4">4.49999997765</AVal>
				<AVal Column="12" Row="4">1.517</AVal>
				<AVal Column="13" Row="4">0</AVal>
				<AVal Column="14" Row="4">0</AVal>
				<AVal Column="15" Row="4">0</AVal>
				<AVal Column="16" Row="4">0</AVal>
				<AVal Column="1" Row="5">2.23517631071e-008</AVal>
				<AVal Column="2" Row="5">2.016</AVal>
				<AVal Column="3" Row="5">1</AVal>
				<AVal Column="4" Row="5">2.016</AVal>
				<AVal Column="5" Row="5">2</AVal>
				<AVal Column="6" Row="5">2.016</AVal>
				<AVal Column="7" Row="5">2.5</AVal>
				<AVal Column="8" Row="5">2.016</AVal>
				<AVal Column="9" Row="5">3.5</AVal>
				<AVal Column="10" Row="5">2.016</AVal>
				<AVal Column="11" Row="5">4.02599999553</AVal>
				<AVal Column="12" Row="5">2.016</AVal>
				<AVal Column="13" Row="5">0</AVal>
				<AVal Column="14" Row="5">0</AVal>
				<AVal Column="15" Row="5">0</AVal>
				<AVal Column="16" Row="5">0</AVal>
				<AVal Column="1" Row="6">2.23517631071e-008</AVal>
				<AVal Column="2" Row="6">2.515</AVal>
				<AVal Column="3" Row="6">3.27750003725</AVal>
				<AVal Column="4" Row="6">2.515</AVal>
				<AVal Column="5" Row="6">0</AVal>
				<AVal Column="6" Row="6">0</AVal>
				<AVal Column="7" Row="6">0</AVal>
				<AVal Column="8" Row="6">0</AVal>
				<AVal Column="9" Row="6">0</AVal>
				<AVal Column="10" Row="6">0</AVal>
				<AVal Column="11" Row="6">0</AVal>
				<AVal Column="12" Row="6">0</AVal>
				<AVal Column="13" Row="6">0</AVal>
				<AVal Column="14" Row="6">0</AVal>
				<AVal Column="15" Row="6">0</AVal>
				<AVal Column="16" Row="6">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="nEdgePoint">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="6" SecondDimension="0">
				<AVal Row="1">4</AVal>
				<AVal Row="2">8</AVal>
				<AVal Row="3">6</AVal>
				<AVal Row="4">6</AVal>
				<AVal Row="5">6</AVal>
				<AVal Row="6">2</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="edgeStatus">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="6" SecondDimension="8">
				<AVal Column="1" Row="1">1</AVal>
				<AVal Column="2" Row="1">6</AVal>
				<AVal Column="3" Row="1">6</AVal>
				<AVal Column="4" Row="1">2</AVal>
				<AVal Column="5" Row="1">0</AVal>
				<AVal Column="6" Row="1">0</AVal>
				<AVal Column="7" Row="1">0</AVal>
				<AVal Column="8" Row="1">0</AVal>
				<AVal Column="1" Row="2">2</AVal>
				<AVal Column="2" Row="2">6</AVal>
				<AVal Column="3" Row="2">11</AVal>
				<AVal Column="4" Row="2">11</AVal>
				<AVal Column="5" Row="2">6</AVal>
				<AVal Column="6" Row="2">6</AVal>
				<AVal Column="7" Row="2">6</AVal>
				<AVal Column="8" Row="2">2</AVal>
				<AVal Column="1" Row="3">2</AVal>
				<AVal Column="2" Row="3">6</AVal>
				<AVal Column="3" Row="3">6</AVal>
				<AVal Column="4" Row="3">6</AVal>
				<AVal Column="5" Row="3">6</AVal>
				<AVal Column="6" Row="3">2</AVal>
				<AVal Column="7" Row="3">0</AVal>
				<AVal Column="8" Row="3">0</AVal>
				<AVal Column="1" Row="4">2</AVal>
				<AVal Column="2" Row="4">6</AVal>
				<AVal Column="3" Row="4">6</AVal>
				<AVal Column="4" Row="4">6</AVal>
				<AVal Column="5" Row="4">6</AVal>
				<AVal Column="6" Row="4">2</AVal>
				<AVal Column="7" Row="4">0</AVal>
				<AVal Column="8" Row="4">0</AVal>
				<AVal Column="1" Row="5">2</AVal>
				<AVal Column="2" Row="5">6</AVal>
				<AVal Column="3" Row="5">6</AVal>
				<AVal Column="4" Row="5">6</AVal>
				<AVal Column="5" Row="5">6</AVal>
				<AVal Column="6" Row="5">1</AVal>
				<AVal Column="7" Row="5">0</AVal>
				<AVal Column="8" Row="5">0</AVal>
				<AVal Column="1" Row="6">2</AVal>
				<AVal Column="2" Row="6">1</AVal>
				<AVal Column="3" Row="6">0</AVal>
				<AVal Column="4" Row="6">0</AVal>
				<AVal Column="5" Row="6">0</AVal>
				<AVal Column="6" Row="6">0</AVal>
				<AVal Column="7" Row="6">0</AVal>
				<AVal Column="8" Row="6">0</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="nColumnDatas">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="6" SecondDimension="0">
				<AVal Row="1">2</AVal>
				<AVal Row="2">4</AVal>
				<AVal Row="3">3</AVal>
				<AVal Row="4">3</AVal>
				<AVal Row="5">3</AVal>
				<AVal Row="6">1</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="columnDatas">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="6" SecondDimension="60">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">3</AVal>
				<AVal Column="3" Row="1">1</AVal>
				<AVal Column="4" Row="1">6</AVal>
				<AVal Column="5" Row="1">0</AVal>
				<AVal Column="6" Row="1">0</AVal>
				<AVal Column="7" Row="1">0.721499944866</AVal>
				<AVal Column="8" Row="1">2.5</AVal>
				<AVal Column="9" Row="1">0.0199</AVal>
				<AVal Column="10" Row="1">0</AVal>
				<AVal Column="11" Row="1">0</AVal>
				<AVal Column="12" Row="1">0</AVal>
				<AVal Column="13" Row="1">0</AVal>
				<AVal Column="14" Row="1">2</AVal>
				<AVal Column="15" Row="1">6</AVal>
				<AVal Column="16" Row="1">2</AVal>
				<AVal Column="17" Row="1">0</AVal>
				<AVal Column="18" Row="1">0</AVal>
				<AVal Column="19" Row="1">3.5</AVal>
				<AVal Column="20" Row="1">4.25049997765</AVal>
				<AVal Column="21" Row="1">0.0199</AVal>
				<AVal Column="22" Row="1">0</AVal>
				<AVal Column="23" Row="1">0</AVal>
				<AVal Column="24" Row="1">0</AVal>
				<AVal Column="25" Row="1">0</AVal>
				<AVal Column="26" Row="1">0</AVal>
				<AVal Column="27" Row="1">0</AVal>
				<AVal Column="28" Row="1">0</AVal>
				<AVal Column="29" Row="1">0</AVal>
				<AVal Column="30" Row="1">0</AVal>
				<AVal Column="31" Row="1">0</AVal>
				<AVal Column="32" Row="1">0</AVal>
				<AVal Column="33" Row="1">0</AVal>
				<AVal Column="34" Row="1">0</AVal>
				<AVal Column="35" Row="1">0</AVal>
				<AVal Column="36" Row="1">0</AVal>
				<AVal Column="37" Row="1">0</AVal>
				<AVal Column="38" Row="1">0</AVal>
				<AVal Column="39" Row="1">0</AVal>
				<AVal Column="40" Row="1">0</AVal>
				<AVal Column="41" Row="1">0</AVal>
				<AVal Column="42" Row="1">0</AVal>
				<AVal Column="43" Row="1">0</AVal>
				<AVal Column="44" Row="1">0</AVal>
				<AVal Column="45" Row="1">0</AVal>
				<AVal Column="46" Row="1">0</AVal>
				<AVal Column="47" Row="1">0</AVal>
				<AVal Column="48" Row="1">0</AVal>
				<AVal Column="49" Row="1">0</AVal>
				<AVal Column="50" Row="1">0</AVal>
				<AVal Column="51" Row="1">0</AVal>
				<AVal Column="52" Row="1">0</AVal>
				<AVal Column="53" Row="1">0</AVal>
				<AVal Column="54" Row="1">0</AVal>
				<AVal Column="55" Row="1">0</AVal>
				<AVal Column="56" Row="1">0</AVal>
				<AVal Column="57" Row="1">0</AVal>
				<AVal Column="58" Row="1">0</AVal>
				<AVal Column="59" Row="1">0</AVal>
				<AVal Column="60" Row="1">0</AVal>
				<AVal Column="1" Row="2">1</AVal>
				<AVal Column="2" Row="2">2</AVal>
				<AVal Column="3" Row="2">2</AVal>
				<AVal Column="4" Row="2">6</AVal>
				<AVal Column="5" Row="2">0</AVal>
				<AVal Column="6" Row="2">0</AVal>
				<AVal Column="7" Row="2">0.249500022352</AVal>
				<AVal Column="8" Row="2">1</AVal>
				<AVal Column="9" Row="2">0.5189</AVal>
				<AVal Column="10" Row="2">0</AVal>
				<AVal Column="11" Row="2">0</AVal>
				<AVal Column="12" Row="2">0</AVal>
				<AVal Column="13" Row="2">1</AVal>
				<AVal Column="14" Row="2">2</AVal>
				<AVal Column="15" Row="2">11</AVal>
				<AVal Column="16" Row="2">11</AVal>
				<AVal Column="17" Row="2">0</AVal>
				<AVal Column="18" Row="2">0</AVal>
				<AVal Column="19" Row="2">1.001</AVal>
				<AVal Column="20" Row="2">1.999</AVal>
				<AVal Column="21" Row="2">0.5189</AVal>
				<AVal Column="22" Row="2">0</AVal>
				<AVal Column="23" Row="2">0</AVal>
				<AVal Column="24" Row="2">0</AVal>
				<AVal Column="25" Row="2">1</AVal>
				<AVal Column="26" Row="2">1</AVal>
				<AVal Column="27" Row="2">6</AVal>
				<AVal Column="28" Row="2">6</AVal>
				<AVal Column="29" Row="2">0</AVal>
				<AVal Column="30" Row="2">0</AVal>
				<AVal Column="31" Row="2">2</AVal>
				<AVal Column="32" Row="2">2.5</AVal>
				<AVal Column="33" Row="2">0.5189</AVal>
				<AVal Column="34" Row="2">0</AVal>
				<AVal Column="35" Row="2">0</AVal>
				<AVal Column="36" Row="2">0</AVal>
				<AVal Column="37" Row="2">1</AVal>
				<AVal Column="38" Row="2">2</AVal>
				<AVal Column="39" Row="2">6</AVal>
				<AVal Column="40" Row="2">2</AVal>
				<AVal Column="41" Row="2">0</AVal>
				<AVal Column="42" Row="2">1</AVal>
				<AVal Column="43" Row="2">3.5</AVal>
				<AVal Column="44" Row="2">4.49999997765</AVal>
				<AVal Column="45" Row="2">0.5189</AVal>
				<AVal Column="46" Row="2">0</AVal>
				<AVal Column="47" Row="2">0</AVal>
				<AVal Column="48" Row="2">0</AVal>
				<AVal Column="49" Row="2">0</AVal>
				<AVal Column="50" Row="2">0</AVal>
				<AVal Column="51" Row="2">0</AVal>
				<AVal Column="52" Row="2">0</AVal>
				<AVal Column="53" Row="2">0</AVal>
				<AVal Column="54" Row="2">0</AVal>
				<AVal Column="55" Row="2">0</AVal>
				<AVal Column="56" Row="2">0</AVal>
				<AVal Column="57" Row="2">0</AVal>
				<AVal Column="58" Row="2">0</AVal>
				<AVal Column="59" Row="2">0</AVal>
				<AVal Column="60" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">2</AVal>
				<AVal Column="3" Row="3">2</AVal>
				<AVal Column="4" Row="3">6</AVal>
				<AVal Column="5" Row="3">1</AVal>
				<AVal Column="6" Row="3">0</AVal>
				<AVal Column="7" Row="3">2.23517631071e-008</AVal>
				<AVal Column="8" Row="3">1</AVal>
				<AVal Column="9" Row="3">1.0179</AVal>
				<AVal Column="10" Row="3">1</AVal>
				<AVal Column="11" Row="3">0</AVal>
				<AVal Column="12" Row="3">0</AVal>
				<AVal Column="13" Row="3">0</AVal>
				<AVal Column="14" Row="3">1</AVal>
				<AVal Column="15" Row="3">6</AVal>
				<AVal Column="16" Row="3">6</AVal>
				<AVal Column="17" Row="3">0</AVal>
				<AVal Column="18" Row="3">0</AVal>
				<AVal Column="19" Row="3">2</AVal>
				<AVal Column="20" Row="3">2.5</AVal>
				<AVal Column="21" Row="3">1.0179</AVal>
				<AVal Column="22" Row="3">0</AVal>
				<AVal Column="23" Row="3">0</AVal>
				<AVal Column="24" Row="3">0</AVal>
				<AVal Column="25" Row="3">0</AVal>
				<AVal Column="26" Row="3">2</AVal>
				<AVal Column="27" Row="3">6</AVal>
				<AVal Column="28" Row="3">2</AVal>
				<AVal Column="29" Row="3">0</AVal>
				<AVal Column="30" Row="3">0</AVal>
				<AVal Column="31" Row="3">3.5</AVal>
				<AVal Column="32" Row="3">4.25049997765</AVal>
				<AVal Column="33" Row="3">1.0179</AVal>
				<AVal Column="34" Row="3">0</AVal>
				<AVal Column="35" Row="3">0</AVal>
				<AVal Column="36" Row="3">0</AVal>
				<AVal Column="37" Row="3">0</AVal>
				<AVal Column="38" Row="3">0</AVal>
				<AVal Column="39" Row="3">0</AVal>
				<AVal Column="40" Row="3">0</AVal>
				<AVal Column="41" Row="3">0</AVal>
				<AVal Column="42" Row="3">0</AVal>
				<AVal Column="43" Row="3">0</AVal>
				<AVal Column="44" Row="3">0</AVal>
				<AVal Column="45" Row="3">0</AVal>
				<AVal Column="46" Row="3">0</AVal>
				<AVal Column="47" Row="3">0</AVal>
				<AVal Column="48" Row="3">0</AVal>
				<AVal Column="49" Row="3">0</AVal>
				<AVal Column="50" Row="3">0</AVal>
				<AVal Column="51" Row="3">0</AVal>
				<AVal Column="52" Row="3">0</AVal>
				<AVal Column="53" Row="3">0</AVal>
				<AVal Column="54" Row="3">0</AVal>
				<AVal Column="55" Row="3">0</AVal>
				<AVal Column="56" Row="3">0</AVal>
				<AVal Column="57" Row="3">0</AVal>
				<AVal Column="58" Row="3">0</AVal>
				<AVal Column="59" Row="3">0</AVal>
				<AVal Column="60" Row="3">0</AVal>
				<AVal Column="1" Row="4">1</AVal>
				<AVal Column="2" Row="4">2</AVal>
				<AVal Column="3" Row="4">2</AVal>
				<AVal Column="4" Row="4">6</AVal>
				<AVal Column="5" Row="4">0</AVal>
				<AVal Column="6" Row="4">0</AVal>
				<AVal Column="7" Row="4">0.249500022352</AVal>
				<AVal Column="8" Row="4">1</AVal>
				<AVal Column="9" Row="4">1.5169</AVal>
				<AVal Column="10" Row="4">0</AVal>
				<AVal Column="11" Row="4">0</AVal>
				<AVal Column="12" Row="4">0</AVal>
				<AVal Column="13" Row="4">1</AVal>
				<AVal Column="14" Row="4">1</AVal>
				<AVal Column="15" Row="4">6</AVal>
				<AVal Column="16" Row="4">6</AVal>
				<AVal Column="17" Row="4">0</AVal>
				<AVal Column="18" Row="4">0</AVal>
				<AVal Column="19" Row="4">2</AVal>
				<AVal Column="20" Row="4">2.5</AVal>
				<AVal Column="21" Row="4">1.5169</AVal>
				<AVal Column="22" Row="4">0</AVal>
				<AVal Column="23" Row="4">0</AVal>
				<AVal Column="24" Row="4">0</AVal>
				<AVal Column="25" Row="4">1</AVal>
				<AVal Column="26" Row="4">2</AVal>
				<AVal Column="27" Row="4">6</AVal>
				<AVal Column="28" Row="4">2</AVal>
				<AVal Column="29" Row="4">0</AVal>
				<AVal Column="30" Row="4">1</AVal>
				<AVal Column="31" Row="4">3.5</AVal>
				<AVal Column="32" Row="4">4.49999997765</AVal>
				<AVal Column="33" Row="4">1.5169</AVal>
				<AVal Column="34" Row="4">0</AVal>
				<AVal Column="35" Row="4">0</AVal>
				<AVal Column="36" Row="4">0</AVal>
				<AVal Column="37" Row="4">0</AVal>
				<AVal Column="38" Row="4">0</AVal>
				<AVal Column="39" Row="4">0</AVal>
				<AVal Column="40" Row="4">0</AVal>
				<AVal Column="41" Row="4">0</AVal>
				<AVal Column="42" Row="4">0</AVal>
				<AVal Column="43" Row="4">0</AVal>
				<AVal Column="44" Row="4">0</AVal>
				<AVal Column="45" Row="4">0</AVal>
				<AVal Column="46" Row="4">0</AVal>
				<AVal Column="47" Row="4">0</AVal>
				<AVal Column="48" Row="4">0</AVal>
				<AVal Column="49" Row="4">0</AVal>
				<AVal Column="50" Row="4">0</AVal>
				<AVal Column="51" Row="4">0</AVal>
				<AVal Column="52" Row="4">0</AVal>
				<AVal Column="53" Row="4">0</AVal>
				<AVal Column="54" Row="4">0</AVal>
				<AVal Column="55" Row="4">0</AVal>
				<AVal Column="56" Row="4">0</AVal>
				<AVal Column="57" Row="4">0</AVal>
				<AVal Column="58" Row="4">0</AVal>
				<AVal Column="59" Row="4">0</AVal>
				<AVal Column="60" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">2</AVal>
				<AVal Column="3" Row="5">2</AVal>
				<AVal Column="4" Row="5">6</AVal>
				<AVal Column="5" Row="5">1</AVal>
				<AVal Column="6" Row="5">0</AVal>
				<AVal Column="7" Row="5">2.23517631071e-008</AVal>
				<AVal Column="8" Row="5">1</AVal>
				<AVal Column="9" Row="5">2.0159</AVal>
				<AVal Column="10" Row="5">1</AVal>
				<AVal Column="11" Row="5">0</AVal>
				<AVal Column="12" Row="5">0</AVal>
				<AVal Column="13" Row="5">0</AVal>
				<AVal Column="14" Row="5">1</AVal>
				<AVal Column="15" Row="5">6</AVal>
				<AVal Column="16" Row="5">6</AVal>
				<AVal Column="17" Row="5">0</AVal>
				<AVal Column="18" Row="5">0</AVal>
				<AVal Column="19" Row="5">2</AVal>
				<AVal Column="20" Row="5">2.5</AVal>
				<AVal Column="21" Row="5">2.0159</AVal>
				<AVal Column="22" Row="5">0</AVal>
				<AVal Column="23" Row="5">0</AVal>
				<AVal Column="24" Row="5">0</AVal>
				<AVal Column="25" Row="5">0</AVal>
				<AVal Column="26" Row="5">1</AVal>
				<AVal Column="27" Row="5">6</AVal>
				<AVal Column="28" Row="5">1</AVal>
				<AVal Column="29" Row="5">0</AVal>
				<AVal Column="30" Row="5">0</AVal>
				<AVal Column="31" Row="5">3.5</AVal>
				<AVal Column="32" Row="5">4.02599999553</AVal>
				<AVal Column="33" Row="5">2.0159</AVal>
				<AVal Column="34" Row="5">0</AVal>
				<AVal Column="35" Row="5">0</AVal>
				<AVal Column="36" Row="5">0</AVal>
				<AVal Column="37" Row="5">0</AVal>
				<AVal Column="38" Row="5">0</AVal>
				<AVal Column="39" Row="5">0</AVal>
				<AVal Column="40" Row="5">0</AVal>
				<AVal Column="41" Row="5">0</AVal>
				<AVal Column="42" Row="5">0</AVal>
				<AVal Column="43" Row="5">0</AVal>
				<AVal Column="44" Row="5">0</AVal>
				<AVal Column="45" Row="5">0</AVal>
				<AVal Column="46" Row="5">0</AVal>
				<AVal Column="47" Row="5">0</AVal>
				<AVal Column="48" Row="5">0</AVal>
				<AVal Column="49" Row="5">0</AVal>
				<AVal Column="50" Row="5">0</AVal>
				<AVal Column="51" Row="5">0</AVal>
				<AVal Column="52" Row="5">0</AVal>
				<AVal Column="53" Row="5">0</AVal>
				<AVal Column="54" Row="5">0</AVal>
				<AVal Column="55" Row="5">0</AVal>
				<AVal Column="56" Row="5">0</AVal>
				<AVal Column="57" Row="5">0</AVal>
				<AVal Column="58" Row="5">0</AVal>
				<AVal Column="59" Row="5">0</AVal>
				<AVal Column="60" Row="5">0</AVal>
				<AVal Column="1" Row="6">1</AVal>
				<AVal Column="2" Row="6">4</AVal>
				<AVal Column="3" Row="6">2</AVal>
				<AVal Column="4" Row="6">1</AVal>
				<AVal Column="5" Row="6">0</AVal>
				<AVal Column="6" Row="6">0</AVal>
				<AVal Column="7" Row="6">0.249500022352</AVal>
				<AVal Column="8" Row="6">3.27750003725</AVal>
				<AVal Column="9" Row="6">2.5149</AVal>
				<AVal Column="10" Row="6">0</AVal>
				<AVal Column="11" Row="6">0</AVal>
				<AVal Column="12" Row="6">0</AVal>
				<AVal Column="13" Row="6">0</AVal>
				<AVal Column="14" Row="6">0</AVal>
				<AVal Column="15" Row="6">0</AVal>
				<AVal Column="16" Row="6">0</AVal>
				<AVal Column="17" Row="6">0</AVal>
				<AVal Column="18" Row="6">0</AVal>
				<AVal Column="19" Row="6">0</AVal>
				<AVal Column="20" Row="6">0</AVal>
				<AVal Column="21" Row="6">0</AVal>
				<AVal Column="22" Row="6">0</AVal>
				<AVal Column="23" Row="6">0</AVal>
				<AVal Column="24" Row="6">0</AVal>
				<AVal Column="25" Row="6">0</AVal>
				<AVal Column="26" Row="6">0</AVal>
				<AVal Column="27" Row="6">0</AVal>
				<AVal Column="28" Row="6">0</AVal>
				<AVal Column="29" Row="6">0</AVal>
				<AVal Column="30" Row="6">0</AVal>
				<AVal Column="31" Row="6">0</AVal>
				<AVal Column="32" Row="6">0</AVal>
				<AVal Column="33" Row="6">0</AVal>
				<AVal Column="34" Row="6">0</AVal>
				<AVal Column="35" Row="6">0</AVal>
				<AVal Column="36" Row="6">0</AVal>
				<AVal Column="37" Row="6">0</AVal>
				<AVal Column="38" Row="6">0</AVal>
				<AVal Column="39" Row="6">0</AVal>
				<AVal Column="40" Row="6">0</AVal>
				<AVal Column="41" Row="6">0</AVal>
				<AVal Column="42" Row="6">0</AVal>
				<AVal Column="43" Row="6">0</AVal>
				<AVal Column="44" Row="6">0</AVal>
				<AVal Column="45" Row="6">0</AVal>
				<AVal Column="46" Row="6">0</AVal>
				<AVal Column="47" Row="6">0</AVal>
				<AVal Column="48" Row="6">0</AVal>
				<AVal Column="49" Row="6">0</AVal>
				<AVal Column="50" Row="6">0</AVal>
				<AVal Column="51" Row="6">0</AVal>
				<AVal Column="52" Row="6">0</AVal>
				<AVal Column="53" Row="6">0</AVal>
				<AVal Column="54" Row="6">0</AVal>
				<AVal Column="55" Row="6">0</AVal>
				<AVal Column="56" Row="6">0</AVal>
				<AVal Column="57" Row="6">0</AVal>
				<AVal Column="58" Row="6">0</AVal>
				<AVal Column="59" Row="6">0</AVal>
				<AVal Column="60" Row="6">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="rowIndex">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="6" SecondDimension="2">
				<AVal Column="1" Row="1">1</AVal>
				<AVal Column="2" Row="1">6</AVal>
				<AVal Column="1" Row="2">7</AVal>
				<AVal Column="2" Row="2">15</AVal>
				<AVal Column="1" Row="3">16</AVal>
				<AVal Column="2" Row="3">20</AVal>
				<AVal Column="1" Row="4">21</AVal>
				<AVal Column="2" Row="4">26</AVal>
				<AVal Column="1" Row="5">27</AVal>
				<AVal Column="2" Row="5">31</AVal>
				<AVal Column="1" Row="6">32</AVal>
				<AVal Column="2" Row="6">39</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="nBrick">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>39</Value>
		</Integer>
		<Length Name="brickCoord">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="39" SecondDimension="5">
				<AVal Column="1" Row="1">0.721499944866</AVal>
				<AVal Column="2" Row="1">0.02</AVal>
				<AVal Column="3" Row="1">0.404250055134</AVal>
				<AVal Column="4" Row="1">0.721499944866</AVal>
				<AVal Column="5" Row="1">0.498</AVal>
				<AVal Column="1" Row="2">1.12675</AVal>
				<AVal Column="2" Row="2">0.02</AVal>
				<AVal Column="3" Row="2">0.498</AVal>
				<AVal Column="4" Row="2">1.12675</AVal>
				<AVal Column="5" Row="2">0.498</AVal>
				<AVal Column="1" Row="3">1.62575</AVal>
				<AVal Column="2" Row="3">0.02</AVal>
				<AVal Column="3" Row="3">0.498</AVal>
				<AVal Column="4" Row="3">1.62575</AVal>
				<AVal Column="5" Row="3">0.498</AVal>
				<AVal Column="1" Row="4">2.12475</AVal>
				<AVal Column="2" Row="4">0.02</AVal>
				<AVal Column="3" Row="4">0.37525</AVal>
				<AVal Column="4" Row="4">2.12475</AVal>
				<AVal Column="5" Row="4">0.498</AVal>
				<AVal Column="1" Row="5">3.5</AVal>
				<AVal Column="2" Row="5">0.02</AVal>
				<AVal Column="3" Row="5">0.450249988824</AVal>
				<AVal Column="4" Row="5">3.5</AVal>
				<AVal Column="5" Row="5">0.498</AVal>
				<AVal Column="1" Row="6">3.95124998882</AVal>
				<AVal Column="2" Row="6">0.02</AVal>
				<AVal Column="3" Row="6">0.299249988824</AVal>
				<AVal Column="4" Row="6">3.95124998882</AVal>
				<AVal Column="5" Row="6">0.498</AVal>
				<AVal Column="1" Row="7">0.249500022352</AVal>
				<AVal Column="2" Row="7">0.519</AVal>
				<AVal Column="3" Row="7">0.368</AVal>
				<AVal Column="4" Row="7">0.249500022352</AVal>
				<AVal Column="5" Row="7">0.498</AVal>
				<AVal Column="1" Row="8">0.618500022352</AVal>
				<AVal Column="2" Row="8">0.519</AVal>
				<AVal Column="3" Row="8">0.381499977648</AVal>
				<AVal Column="4" Row="8">0.618500022352</AVal>
				<AVal Column="5" Row="8">0.498</AVal>
				<AVal Column="1" Row="9">1.001</AVal>
				<AVal Column="2" Row="9">0.519</AVal>
				<AVal Column="3" Row="9">0.37475</AVal>
				<AVal Column="4" Row="9">1.001</AVal>
				<AVal Column="5" Row="9">0.498</AVal>
				<AVal Column="1" Row="10">1.37675</AVal>
				<AVal Column="2" Row="10">0.519</AVal>
				<AVal Column="3" Row="10">0.46225</AVal>
				<AVal Column="4" Row="10">1.37675</AVal>
				<AVal Column="5" Row="10">0.498</AVal>
				<AVal Column="1" Row="11">1.84</AVal>
				<AVal Column="2" Row="11">0.519</AVal>
				<AVal Column="3" Row="11">0.159</AVal>
				<AVal Column="4" Row="11">1.84</AVal>
				<AVal Column="5" Row="11">0.498</AVal>
				<AVal Column="1" Row="12">2</AVal>
				<AVal Column="2" Row="12">0.519</AVal>
				<AVal Column="3" Row="12">0.498</AVal>
				<AVal Column="4" Row="12">2</AVal>
				<AVal Column="5" Row="12">0.498</AVal>
				<AVal Column="1" Row="13">3.5</AVal>
				<AVal Column="2" Row="13">0.519</AVal>
				<AVal Column="3" Row="13">0.225374994412</AVal>
				<AVal Column="4" Row="13">3.5</AVal>
				<AVal Column="5" Row="13">0.498</AVal>
				<AVal Column="1" Row="14">3.72637499441</AVal>
				<AVal Column="2" Row="14">0.519</AVal>
				<AVal Column="3" Row="14">0.424124983236</AVal>
				<AVal Column="4" Row="14">3.72637499441</AVal>
				<AVal Column="5" Row="14">0.498</AVal>
				<AVal Column="1" Row="15">4.15149997765</AVal>
				<AVal Column="2" Row="15">0.519</AVal>
				<AVal Column="3" Row="15">0.3485</AVal>
				<AVal Column="4" Row="15">4.15149997765</AVal>
				<AVal Column="5" Row="15">0.498</AVal>
				<AVal Column="1" Row="16">2.23517631071e-008</AVal>
				<AVal Column="2" Row="16">1.018</AVal>
				<AVal Column="3" Row="16">0.498</AVal>
				<AVal Column="4" Row="16">2.23517631071e-008</AVal>
				<AVal Column="5" Row="16">0.498</AVal>
				<AVal Column="1" Row="17">0.499000022352</AVal>
				<AVal Column="2" Row="17">1.018</AVal>
				<AVal Column="3" Row="17">0.498</AVal>
				<AVal Column="4" Row="17">0.499000022352</AVal>
				<AVal Column="5" Row="17">0.498</AVal>
				<AVal Column="1" Row="18">2</AVal>
				<AVal Column="2" Row="18">1.018</AVal>
				<AVal Column="3" Row="18">0.498</AVal>
				<AVal Column="4" Row="18">2</AVal>
				<AVal Column="5" Row="18">0.498</AVal>
				<AVal Column="1" Row="19">3.5</AVal>
				<AVal Column="2" Row="19">1.018</AVal>
				<AVal Column="3" Row="19">0.43843748603</AVal>
				<AVal Column="4" Row="19">3.5</AVal>
				<AVal Column="5" Row="19">0.498</AVal>
				<AVal Column="1" Row="20">3.93943748603</AVal>
				<AVal Column="2" Row="20">1.018</AVal>
				<AVal Column="3" Row="20">0.311062491618</AVal>
				<AVal Column="4" Row="20">3.93943748603</AVal>
				<AVal Column="5" Row="20">0.498</AVal>
				<AVal Column="1" Row="21">0.249500022352</AVal>
				<AVal Column="2" Row="21">1.517</AVal>
				<AVal Column="3" Row="21">0.498</AVal>
				<AVal Column="4" Row="21">0.249500022352</AVal>
				<AVal Column="5" Row="21">0.498</AVal>
				<AVal Column="1" Row="22">0.748500022352</AVal>
				<AVal Column="2" Row="22">1.517</AVal>
				<AVal Column="3" Row="22">0.251499977648</AVal>
				<AVal Column="4" Row="22">0.748500022352</AVal>
				<AVal Column="5" Row="22">0.498</AVal>
				<AVal Column="1" Row="23">2</AVal>
				<AVal Column="2" Row="23">1.517</AVal>
				<AVal Column="3" Row="23">0.498</AVal>
				<AVal Column="4" Row="23">2</AVal>
				<AVal Column="5" Row="23">0.498</AVal>
				<AVal Column="1" Row="24">3.5</AVal>
				<AVal Column="2" Row="24">1.517</AVal>
				<AVal Column="3" Row="24">0.219468743015</AVal>
				<AVal Column="4" Row="24">3.5</AVal>
				<AVal Column="5" Row="24">0.498</AVal>
				<AVal Column="1" Row="25">3.72046874302</AVal>
				<AVal Column="2" Row="25">1.517</AVal>
				<AVal Column="3" Row="25">0.430031234633</AVal>
				<AVal Column="4" Row="25">3.72046874302</AVal>
				<AVal Column="5" Row="25">0.498</AVal>
				<AVal Column="1" Row="26">4.15149997765</AVal>
				<AVal Column="2" Row="26">1.517</AVal>
				<AVal Column="3" Row="26">0.3485</AVal>
				<AVal Column="4" Row="26">4.15149997765</AVal>
				<AVal Column="5" Row="26">0.498</AVal>
				<AVal Column="1" Row="27">2.23517631071e-008</AVal>
				<AVal Column="2" Row="27">2.016</AVal>
				<AVal Column="3" Row="27">0.498</AVal>
				<AVal Column="4" Row="27">2.23517631071e-008</AVal>
				<AVal Column="5" Row="27">0.498</AVal>
				<AVal Column="1" Row="28">0.499000022352</AVal>
				<AVal Column="2" Row="28">2.016</AVal>
				<AVal Column="3" Row="28">0.498</AVal>
				<AVal Column="4" Row="28">0.499000022352</AVal>
				<AVal Column="5" Row="28">0.498</AVal>
				<AVal Column="1" Row="29">2</AVal>
				<AVal Column="2" Row="29">2.016</AVal>
				<AVal Column="3" Row="29">0.498</AVal>
				<AVal Column="4" Row="29">2</AVal>
				<AVal Column="5" Row="29">0.498</AVal>
				<AVal Column="1" Row="30">3.5</AVal>
				<AVal Column="2" Row="30">2.016</AVal>
				<AVal Column="3" Row="30">0.36599999553</AVal>
				<AVal Column="4" Row="30">3.5</AVal>
				<AVal Column="5" Row="30">0.498</AVal>
				<AVal Column="1" Row="31">3.86699999553</AVal>
				<AVal Column="2" Row="31">2.016</AVal>
				<AVal Column="3" Row="31">0.159</AVal>
				<AVal Column="4" Row="31">3.86699999553</AVal>
				<AVal Column="5" Row="31">0.498</AVal>
				<AVal Column="1" Row="32">0.249500022352</AVal>
				<AVal Column="2" Row="32">2.515</AVal>
				<AVal Column="3" Row="32">0.498</AVal>
				<AVal Column="4" Row="32">0.249500022352</AVal>
				<AVal Column="5" Row="32">0.498</AVal>
				<AVal Column="1" Row="33">0.748500022352</AVal>
				<AVal Column="2" Row="33">2.515</AVal>
				<AVal Column="3" Row="33">0.498</AVal>
				<AVal Column="4" Row="33">0.748500022352</AVal>
				<AVal Column="5" Row="33">0.498</AVal>
				<AVal Column="1" Row="34">1.24750002235</AVal>
				<AVal Column="2" Row="34">2.515</AVal>
				<AVal Column="3" Row="34">0.252499977648</AVal>
				<AVal Column="4" Row="34">1.24750002235</AVal>
				<AVal Column="5" Row="34">0.498</AVal>
				<AVal Column="1" Row="35">1.501</AVal>
				<AVal Column="2" Row="35">2.515</AVal>
				<AVal Column="3" Row="35">0.403</AVal>
				<AVal Column="4" Row="35">1.501</AVal>
				<AVal Column="5" Row="35">0.498</AVal>
				<AVal Column="1" Row="36">1.905</AVal>
				<AVal Column="2" Row="36">2.515</AVal>
				<AVal Column="3" Row="36">0.34425</AVal>
				<AVal Column="4" Row="36">1.905</AVal>
				<AVal Column="5" Row="36">0.498</AVal>
				<AVal Column="1" Row="37">2.25025</AVal>
				<AVal Column="2" Row="37">2.515</AVal>
				<AVal Column="3" Row="37">0.498</AVal>
				<AVal Column="4" Row="37">2.25025</AVal>
				<AVal Column="5" Row="37">0.498</AVal>
				<AVal Column="1" Row="38">2.74925</AVal>
				<AVal Column="2" Row="38">2.515</AVal>
				<AVal Column="3" Row="38">0.368250037253</AVal>
				<AVal Column="4" Row="38">2.74925</AVal>
				<AVal Column="5" Row="38">0.498</AVal>
				<AVal Column="1" Row="39">3.11850003725</AVal>
				<AVal Column="2" Row="39">2.515</AVal>
				<AVal Column="3" Row="39">0.159</AVal>
				<AVal Column="4" Row="39">3.11850003725</AVal>
				<AVal Column="5" Row="39">0.498</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="brickDef">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="39" SecondDimension="6">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">10003</AVal>
				<AVal Column="4" Row="1">3</AVal>
				<AVal Column="5" Row="1">1</AVal>
				<AVal Column="6" Row="1">0</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="3" Row="2">10003</AVal>
				<AVal Column="4" Row="2">3</AVal>
				<AVal Column="5" Row="2">1</AVal>
				<AVal Column="6" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="3" Row="3">10003</AVal>
				<AVal Column="4" Row="3">3</AVal>
				<AVal Column="5" Row="3">1</AVal>
				<AVal Column="6" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="3" Row="4">10003</AVal>
				<AVal Column="4" Row="4">3</AVal>
				<AVal Column="5" Row="4">1</AVal>
				<AVal Column="6" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="3" Row="5">10003</AVal>
				<AVal Column="4" Row="5">3</AVal>
				<AVal Column="5" Row="5">1</AVal>
				<AVal Column="6" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="3" Row="6">10003</AVal>
				<AVal Column="4" Row="6">3</AVal>
				<AVal Column="5" Row="6">1</AVal>
				<AVal Column="6" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="3" Row="7">10003</AVal>
				<AVal Column="4" Row="7">3</AVal>
				<AVal Column="5" Row="7">1</AVal>
				<AVal Column="6" Row="7">0</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">0</AVal>
				<AVal Column="3" Row="8">10003</AVal>
				<AVal Column="4" Row="8">3</AVal>
				<AVal Column="5" Row="8">1</AVal>
				<AVal Column="6" Row="8">0</AVal>
				<AVal Column="1" Row="9">0</AVal>
				<AVal Column="2" Row="9">0</AVal>
				<AVal Column="3" Row="9">10003</AVal>
				<AVal Column="4" Row="9">3</AVal>
				<AVal Column="5" Row="9">1</AVal>
				<AVal Column="6" Row="9">0</AVal>
				<AVal Column="1" Row="10">0</AVal>
				<AVal Column="2" Row="10">0</AVal>
				<AVal Column="3" Row="10">10003</AVal>
				<AVal Column="4" Row="10">3</AVal>
				<AVal Column="5" Row="10">1</AVal>
				<AVal Column="6" Row="10">0</AVal>
				<AVal Column="1" Row="11">0</AVal>
				<AVal Column="2" Row="11">0</AVal>
				<AVal Column="3" Row="11">10003</AVal>
				<AVal Column="4" Row="11">3</AVal>
				<AVal Column="5" Row="11">1</AVal>
				<AVal Column="6" Row="11">0</AVal>
				<AVal Column="1" Row="12">0</AVal>
				<AVal Column="2" Row="12">0</AVal>
				<AVal Column="3" Row="12">10003</AVal>
				<AVal Column="4" Row="12">3</AVal>
				<AVal Column="5" Row="12">1</AVal>
				<AVal Column="6" Row="12">0</AVal>
				<AVal Column="1" Row="13">0</AVal>
				<AVal Column="2" Row="13">0</AVal>
				<AVal Column="3" Row="13">10003</AVal>
				<AVal Column="4" Row="13">3</AVal>
				<AVal Column="5" Row="13">1</AVal>
				<AVal Column="6" Row="13">0</AVal>
				<AVal Column="1" Row="14">0</AVal>
				<AVal Column="2" Row="14">0</AVal>
				<AVal Column="3" Row="14">10003</AVal>
				<AVal Column="4" Row="14">3</AVal>
				<AVal Column="5" Row="14">1</AVal>
				<AVal Column="6" Row="14">0</AVal>
				<AVal Column="1" Row="15">0</AVal>
				<AVal Column="2" Row="15">0</AVal>
				<AVal Column="3" Row="15">10003</AVal>
				<AVal Column="4" Row="15">3</AVal>
				<AVal Column="5" Row="15">1</AVal>
				<AVal Column="6" Row="15">0</AVal>
				<AVal Column="1" Row="16">0</AVal>
				<AVal Column="2" Row="16">1</AVal>
				<AVal Column="3" Row="16">10003</AVal>
				<AVal Column="4" Row="16">3</AVal>
				<AVal Column="5" Row="16">1</AVal>
				<AVal Column="6" Row="16">0</AVal>
				<AVal Column="1" Row="17">0</AVal>
				<AVal Column="2" Row="17">1</AVal>
				<AVal Column="3" Row="17">10003</AVal>
				<AVal Column="4" Row="17">3</AVal>
				<AVal Column="5" Row="17">1</AVal>
				<AVal Column="6" Row="17">0</AVal>
				<AVal Column="1" Row="18">0</AVal>
				<AVal Column="2" Row="18">0</AVal>
				<AVal Column="3" Row="18">10003</AVal>
				<AVal Column="4" Row="18">3</AVal>
				<AVal Column="5" Row="18">1</AVal>
				<AVal Column="6" Row="18">0</AVal>
				<AVal Column="1" Row="19">0</AVal>
				<AVal Column="2" Row="19">0</AVal>
				<AVal Column="3" Row="19">10003</AVal>
				<AVal Column="4" Row="19">3</AVal>
				<AVal Column="5" Row="19">1</AVal>
				<AVal Column="6" Row="19">0</AVal>
				<AVal Column="1" Row="20">0</AVal>
				<AVal Column="2" Row="20">0</AVal>
				<AVal Column="3" Row="20">10003</AVal>
				<AVal Column="4" Row="20">3</AVal>
				<AVal Column="5" Row="20">1</AVal>
				<AVal Column="6" Row="20">0</AVal>
				<AVal Column="1" Row="21">0</AVal>
				<AVal Column="2" Row="21">0</AVal>
				<AVal Column="3" Row="21">10003</AVal>
				<AVal Column="4" Row="21">3</AVal>
				<AVal Column="5" Row="21">1</AVal>
				<AVal Column="6" Row="21">0</AVal>
				<AVal Column="1" Row="22">0</AVal>
				<AVal Column="2" Row="22">0</AVal>
				<AVal Column="3" Row="22">10003</AVal>
				<AVal Column="4" Row="22">3</AVal>
				<AVal Column="5" Row="22">1</AVal>
				<AVal Column="6" Row="22">0</AVal>
				<AVal Column="1" Row="23">0</AVal>
				<AVal Column="2" Row="23">0</AVal>
				<AVal Column="3" Row="23">10003</AVal>
				<AVal Column="4" Row="23">3</AVal>
				<AVal Column="5" Row="23">1</AVal>
				<AVal Column="6" Row="23">0</AVal>
				<AVal Column="1" Row="24">0</AVal>
				<AVal Column="2" Row="24">0</AVal>
				<AVal Column="3" Row="24">10003</AVal>
				<AVal Column="4" Row="24">3</AVal>
				<AVal Column="5" Row="24">1</AVal>
				<AVal Column="6" Row="24">0</AVal>
				<AVal Column="1" Row="25">0</AVal>
				<AVal Column="2" Row="25">0</AVal>
				<AVal Column="3" Row="25">10003</AVal>
				<AVal Column="4" Row="25">3</AVal>
				<AVal Column="5" Row="25">1</AVal>
				<AVal Column="6" Row="25">0</AVal>
				<AVal Column="1" Row="26">0</AVal>
				<AVal Column="2" Row="26">0</AVal>
				<AVal Column="3" Row="26">10003</AVal>
				<AVal Column="4" Row="26">3</AVal>
				<AVal Column="5" Row="26">1</AVal>
				<AVal Column="6" Row="26">0</AVal>
				<AVal Column="1" Row="27">0</AVal>
				<AVal Column="2" Row="27">1</AVal>
				<AVal Column="3" Row="27">10003</AVal>
				<AVal Column="4" Row="27">3</AVal>
				<AVal Column="5" Row="27">1</AVal>
				<AVal Column="6" Row="27">0</AVal>
				<AVal Column="1" Row="28">0</AVal>
				<AVal Column="2" Row="28">1</AVal>
				<AVal Column="3" Row="28">10003</AVal>
				<AVal Column="4" Row="28">3</AVal>
				<AVal Column="5" Row="28">1</AVal>
				<AVal Column="6" Row="28">0</AVal>
				<AVal Column="1" Row="29">0</AVal>
				<AVal Column="2" Row="29">0</AVal>
				<AVal Column="3" Row="29">10003</AVal>
				<AVal Column="4" Row="29">3</AVal>
				<AVal Column="5" Row="29">1</AVal>
				<AVal Column="6" Row="29">0</AVal>
				<AVal Column="1" Row="30">0</AVal>
				<AVal Column="2" Row="30">0</AVal>
				<AVal Column="3" Row="30">10003</AVal>
				<AVal Column="4" Row="30">3</AVal>
				<AVal Column="5" Row="30">1</AVal>
				<AVal Column="6" Row="30">0</AVal>
				<AVal Column="1" Row="31">0</AVal>
				<AVal Column="2" Row="31">0</AVal>
				<AVal Column="3" Row="31">10003</AVal>
				<AVal Column="4" Row="31">3</AVal>
				<AVal Column="5" Row="31">1</AVal>
				<AVal Column="6" Row="31">0</AVal>
				<AVal Column="1" Row="32">0</AVal>
				<AVal Column="2" Row="32">0</AVal>
				<AVal Column="3" Row="32">10003</AVal>
				<AVal Column="4" Row="32">3</AVal>
				<AVal Column="5" Row="32">1</AVal>
				<AVal Column="6" Row="32">0</AVal>
				<AVal Column="1" Row="33">0</AVal>
				<AVal Column="2" Row="33">0</AVal>
				<AVal Column="3" Row="33">10003</AVal>
				<AVal Column="4" Row="33">3</AVal>
				<AVal Column="5" Row="33">1</AVal>
				<AVal Column="6" Row="33">0</AVal>
				<AVal Column="1" Row="34">0</AVal>
				<AVal Column="2" Row="34">0</AVal>
				<AVal Column="3" Row="34">10003</AVal>
				<AVal Column="4" Row="34">3</AVal>
				<AVal Column="5" Row="34">1</AVal>
				<AVal Column="6" Row="34">0</AVal>
				<AVal Column="1" Row="35">0</AVal>
				<AVal Column="2" Row="35">0</AVal>
				<AVal Column="3" Row="35">10003</AVal>
				<AVal Column="4" Row="35">3</AVal>
				<AVal Column="5" Row="35">1</AVal>
				<AVal Column="6" Row="35">0</AVal>
				<AVal Column="1" Row="36">0</AVal>
				<AVal Column="2" Row="36">0</AVal>
				<AVal Column="3" Row="36">10003</AVal>
				<AVal Column="4" Row="36">3</AVal>
				<AVal Column="5" Row="36">1</AVal>
				<AVal Column="6" Row="36">0</AVal>
				<AVal Column="1" Row="37">0</AVal>
				<AVal Column="2" Row="37">0</AVal>
				<AVal Column="3" Row="37">10003</AVal>
				<AVal Column="4" Row="37">3</AVal>
				<AVal Column="5" Row="37">1</AVal>
				<AVal Column="6" Row="37">0</AVal>
				<AVal Column="1" Row="38">0</AVal>
				<AVal Column="2" Row="38">0</AVal>
				<AVal Column="3" Row="38">10003</AVal>
				<AVal Column="4" Row="38">3</AVal>
				<AVal Column="5" Row="38">1</AVal>
				<AVal Column="6" Row="38">0</AVal>
				<AVal Column="1" Row="39">0</AVal>
				<AVal Column="2" Row="39">0</AVal>
				<AVal Column="3" Row="39">10003</AVal>
				<AVal Column="4" Row="39">3</AVal>
				<AVal Column="5" Row="39">1</AVal>
				<AVal Column="6" Row="39">0</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="brickCut">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="39" SecondDimension="3">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0.0937499448657</AVal>
				<AVal Column="3" Row="1">0</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="3" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="3" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0.12275</AVal>
				<AVal Column="3" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0.0477500111759</AVal>
				<AVal Column="3" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0.198750011176</AVal>
				<AVal Column="3" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0.13</AVal>
				<AVal Column="3" Row="7">0</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">0.116500022352</AVal>
				<AVal Column="3" Row="8">0</AVal>
				<AVal Column="1" Row="9">0</AVal>
				<AVal Column="2" Row="9">0.12325</AVal>
				<AVal Column="3" Row="9">0.117</AVal>
				<AVal Column="1" Row="10">0</AVal>
				<AVal Column="2" Row="10">0.03575</AVal>
				<AVal Column="3" Row="10">0.117</AVal>
				<AVal Column="1" Row="11">0</AVal>
				<AVal Column="2" Row="11">0.339</AVal>
				<AVal Column="3" Row="11">0.117</AVal>
				<AVal Column="1" Row="12">0</AVal>
				<AVal Column="2" Row="12">0</AVal>
				<AVal Column="3" Row="12">0</AVal>
				<AVal Column="1" Row="13">0</AVal>
				<AVal Column="2" Row="13">0.272625005588</AVal>
				<AVal Column="3" Row="13">0</AVal>
				<AVal Column="1" Row="14">0</AVal>
				<AVal Column="2" Row="14">0.0738750167638</AVal>
				<AVal Column="3" Row="14">0</AVal>
				<AVal Column="1" Row="15">0</AVal>
				<AVal Column="2" Row="15">0.1495</AVal>
				<AVal Column="3" Row="15">0</AVal>
				<AVal Column="1" Row="16">0</AVal>
				<AVal Column="2" Row="16">0</AVal>
				<AVal Column="3" Row="16">0</AVal>
				<AVal Column="1" Row="17">0</AVal>
				<AVal Column="2" Row="17">0</AVal>
				<AVal Column="3" Row="17">0</AVal>
				<AVal Column="1" Row="18">0</AVal>
				<AVal Column="2" Row="18">0</AVal>
				<AVal Column="3" Row="18">0</AVal>
				<AVal Column="1" Row="19">0</AVal>
				<AVal Column="2" Row="19">0.0595625139699</AVal>
				<AVal Column="3" Row="19">0</AVal>
				<AVal Column="1" Row="20">0</AVal>
				<AVal Column="2" Row="20">0.186937508382</AVal>
				<AVal Column="3" Row="20">0</AVal>
				<AVal Column="1" Row="21">0</AVal>
				<AVal Column="2" Row="21">0</AVal>
				<AVal Column="3" Row="21">0</AVal>
				<AVal Column="1" Row="22">0</AVal>
				<AVal Column="2" Row="22">0.246500022352</AVal>
				<AVal Column="3" Row="22">0</AVal>
				<AVal Column="1" Row="23">0</AVal>
				<AVal Column="2" Row="23">0</AVal>
				<AVal Column="3" Row="23">0</AVal>
				<AVal Column="1" Row="24">0</AVal>
				<AVal Column="2" Row="24">0.278531256985</AVal>
				<AVal Column="3" Row="24">0</AVal>
				<AVal Column="1" Row="25">0</AVal>
				<AVal Column="2" Row="25">0.0679687653668</AVal>
				<AVal Column="3" Row="25">0</AVal>
				<AVal Column="1" Row="26">0</AVal>
				<AVal Column="2" Row="26">0.1495</AVal>
				<AVal Column="3" Row="26">0</AVal>
				<AVal Column="1" Row="27">0</AVal>
				<AVal Column="2" Row="27">0</AVal>
				<AVal Column="3" Row="27">0</AVal>
				<AVal Column="1" Row="28">0</AVal>
				<AVal Column="2" Row="28">0</AVal>
				<AVal Column="3" Row="28">0</AVal>
				<AVal Column="1" Row="29">0</AVal>
				<AVal Column="2" Row="29">0</AVal>
				<AVal Column="3" Row="29">0</AVal>
				<AVal Column="1" Row="30">0</AVal>
				<AVal Column="2" Row="30">0.13200000447</AVal>
				<AVal Column="3" Row="30">0</AVal>
				<AVal Column="1" Row="31">0</AVal>
				<AVal Column="2" Row="31">0.339</AVal>
				<AVal Column="3" Row="31">0</AVal>
				<AVal Column="1" Row="32">0</AVal>
				<AVal Column="2" Row="32">0</AVal>
				<AVal Column="3" Row="32">0.323</AVal>
				<AVal Column="1" Row="33">0</AVal>
				<AVal Column="2" Row="33">0</AVal>
				<AVal Column="3" Row="33">0.323</AVal>
				<AVal Column="1" Row="34">0</AVal>
				<AVal Column="2" Row="34">0.245500022352</AVal>
				<AVal Column="3" Row="34">0.323</AVal>
				<AVal Column="1" Row="35">0</AVal>
				<AVal Column="2" Row="35">0.095</AVal>
				<AVal Column="3" Row="35">0.323</AVal>
				<AVal Column="1" Row="36">0</AVal>
				<AVal Column="2" Row="36">0.15375</AVal>
				<AVal Column="3" Row="36">0.323</AVal>
				<AVal Column="1" Row="37">0</AVal>
				<AVal Column="2" Row="37">0</AVal>
				<AVal Column="3" Row="37">0.323</AVal>
				<AVal Column="1" Row="38">0</AVal>
				<AVal Column="2" Row="38">0.129749962747</AVal>
				<AVal Column="3" Row="38">0.323</AVal>
				<AVal Column="1" Row="39">0</AVal>
				<AVal Column="2" Row="39">0.339</AVal>
				<AVal Column="3" Row="39">0.323</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="nBrickCutter">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="brickCutters">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="brickCuttersType">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="nRowCutters">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="6" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="rowCutters">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="6" SecondDimension="4">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
				<AVal Column="4" Row="1">0</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="3" Row="2">0</AVal>
				<AVal Column="4" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="3" Row="3">0</AVal>
				<AVal Column="4" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="3" Row="4">0</AVal>
				<AVal Column="4" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="3" Row="5">0</AVal>
				<AVal Column="4" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="3" Row="6">0</AVal>
				<AVal Column="4" Row="6">0</AVal>
			</ArrayValues>
		</Integer>
	</Parameters>
</ParamSection>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_FWM SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_FWM>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_BWM SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_BWM>

<Copyright SectVersion="1" SectionFlags="0" SubIdent="0">
	<Author></Author>
	<License>
		<Type>CC BY-ND</Type>
		<Version>3.0</Version>
	</License>
</Copyright>

<Keywords SectVersion="1" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Keywords>

</Symbol>
